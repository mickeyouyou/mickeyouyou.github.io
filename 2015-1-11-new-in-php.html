<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <link rel="stylesheet" href="/css/main.css" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">
    
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link href="http://download.easyicon.net/icns/1097218/32/" rel="shortcut icon" type="image/x-icon"/>

    
    <title>New Features from PHP5.2 to 5.6</title>
</head>

<body>

<h2 id="New_Features_from_PHP5-2_to_5-6">New Features from PHP5.2 to 5.6</h2><p>自10年开始php，自己在改变，PHP本身也在发生着变化。截至目前( 2015.01 )，PHP的最新稳定版本是PHP5.6.4，但有差不多一半的用户仍然在使用已经不在维护的PHP5.2，其余的一半用户在使用PHP5.3 ( PHP5.3也于2014年9月停止支持 )。因为PHP那 “ 集百家之长 ”的蛋疼语法，加上社区氛围不太好，许多人对新版本，新特性并无兴趣。</p>
<p>本文会介绍自PHP5.2起，直到PHP5.6中增加的新特性。</p>
<ul>
<li>PHP5.6：常量增强，可变函数参数，命名空间增强</li>
<li>PHP5.5：yield，list()可用于foreach循环，细节修改</li>
<li>PHP5.4：Short Open Tag，数组简写形式，Traits，内置web服务器，细节修改</li>
<li>PHP5.3：弃用的功能，匿名函数，新增魔术方法，命名空间，延迟静态绑定，Heredoc和Nowdoc，const，三元运算符，Phar</li>
<li>PHP5.2：JSON的支持</li>
<li>PHP5.2以前：autoload, PDO和MySQLi, 类型约束</li>
</ul>
<h3 id="PHP5-6_2014-8">PHP5.6 2014.8</h3><h5 id="常量表达式">常量表达式</h5><p>在常量、属性声明和函数参数默认值声明时，以前版本只允许常量值，PHP5.6开始允许使用包含数字、字符串字面值和常量的标量表达式。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ONE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> TWO = ONE * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> THREE = TWO + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ONE_THIRD = ONE / <span class="keyword">self</span>::THREE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> SENTENCE = <span class="string">'The value of '</span>.<span class="keyword">self</span>::THREE.<span class="string">' is 3'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> <span class="params">(<span class="variable">$a</span> = ONE + self::THREE)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$a</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> (<span class="keyword">new</span> C)-&gt;f();  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> C::SENTENCE;   <span class="comment">//The value of 3 is 3</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="可变参数函数">可变参数函数</h5><p>可变函数的实现，不再依赖func_get_args()函数，现在可以通过新增的操作符…更简洁地实现。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(<span class="variable">$req</span>, <span class="variable">$opt</span> = null, ...<span class="variable">$params</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"\$req: %d; \$opt: %d; number of params: %d\n"</span>,</span><br><span class="line">                <span class="variable">$req</span>, <span class="variable">$opt</span>, count(<span class="variable">$params</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(<span class="number">1</span>);</span><br><span class="line">    foo(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$req: 1; $opt: 0; number of params: 0&#10;   $req: 1; $opt: 2; number of params: 0&#10;   $req: 1; $opt: 2; number of params: 1&#10;   $req: 1; $opt: 2; number of params: 2&#10;   $req: 1; $opt: 2; number of params: 3</span><br></pre></td></tr></table></figure></p>
<h5 id="参数解包功能">参数解包功能</h5><p>在调用函数时，通过…操作符可以把数组或者可遍历对象解包到参数列表，这和Ruby等语言中的扩张(splat)操作符类似。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(<span class="variable">$a</span>, <span class="variable">$b</span>, <span class="variable">$c</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$a</span> + <span class="variable">$b</span> + <span class="variable">$c</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$operators</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> add(...<span class="variable">$operators</span>);    <span class="comment">//6</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br><span class="line">```			</span><br><span class="line"><span class="comment">#####导入函数和常量</span></span><br><span class="line"><span class="keyword">use</span> 操作符开始支持函数和常量的导入。 <span class="title">use</span> <span class="title">function</span> 和 <span class="title">use</span> <span class="title">const</span> 结构的用法的示例：</span><br><span class="line">```<span class="title">php</span></span><br><span class="line">&lt;?<span class="title">php</span></span><br><span class="line"></span><br><span class="line">    <span class="title">namespace</span> <span class="title">cc</span>\<span class="title">jaylee</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title">const</span> <span class="title">FOO</span> = 11;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title">use</span> <span class="title">const</span> <span class="title">cc</span>\<span class="title">jaylee</span>\<span class="title">FOO</span>;</span><br><span class="line">        <span class="keyword">use</span> <span class="title">function</span> <span class="title">cc</span>\<span class="title">jaylee</span>\<span class="title">f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> FOO;   \\ <span class="number">11</span></span><br><span class="line"></span><br><span class="line">        f();        \\ cc\jaylee\f</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br><span class="line">```			</span><br><span class="line"><span class="comment">#####phpdbg</span></span><br><span class="line">PHP自带了一个交互式调试器phpdbg，它是一个SAPI模块，更多信息参考 phpdbg 文档。</span><br><span class="line"><span class="comment">#####php://input可以被复用</span></span><br><span class="line">php:<span class="comment">//input 开始支持多次打开和读取，这给处理POST数据的模块的内存占用带来了极大的改善。</span></span><br><span class="line"><span class="comment">#####大文件上传支持</span></span><br><span class="line">可以上传超过<span class="number">2</span>G的大文件。</span><br><span class="line"><span class="comment">#####GMP支持操作符重载</span></span><br><span class="line"><span class="comment">#####新增gost-crypto哈希算法</span></span><br><span class="line"><span class="comment">#####SSL/TSL改进</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###PHP5.5 2013</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####yield关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span>关键字用于当函数需要返回一个迭代器的时候，逐个返回值。</span><br><span class="line"></span><br><span class="line">该函数返回一个迭代器对象。</span><br><span class="line"></span><br><span class="line"><span class="comment">#####list()用于foreach</span></span><br><span class="line"></span><br><span class="line">该特性可以在<span class="keyword">foreach</span>中解析嵌套的数组：</span><br><span class="line">```php</span><br><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$arr</span> = [</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="keyword">list</span>(<span class="variable">$a</span>, <span class="variable">$b</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$a</span>.<span class="string">"=="</span>.<span class="variable">$b</span>.<span class="string">"=="</span>.<span class="variable">$c</span>.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>==<span class="number">2</span>==<span class="number">3</span></span><br><span class="line">a==b==c</span><br></pre></td></tr></table></figure></p>
<h5 id="其他修改">其他修改</h5><ul>
<li><p>不推荐使用 mysql 函数，推荐使用 PDO 或 MySQLi, 参见前文。</p>
</li>
<li><p>不再支持Windows XP.</p>
</li>
<li><p>可用 MyClass::class 取到一个类的完整限定名(包括命名空间)。</p>
</li>
<li><p>empty() 支持表达式作为参数。</p>
</li>
<li><p>try-catch 结构新增 finally 块。</p>
</li>
</ul>
<h3 id="PHP5-4_2012">PHP5.4  2012</h3><h5 id="Short_Open_Tag">Short Open Tag</h5><p>Short Open Tag 自PHP5.4起总是可用。</p>
<p>在这里集中讲一下有关 PHP 起止标签的问题。即：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通常就是上面的形式，除此之外还有一种简写形式：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?</span> <span class="comment">/*  code  */</span> <span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>还可以把<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?</span> <span class="keyword">echo</span> <span class="variable">$foo</span>;<span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>简写成：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?</span>=<span class="variable">$foo</span><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这种简写形式被称为 Short Open Tag, 在 PHP5.3 起被默认开启，在 PHP5.4 起总是可用。 使用这种简写形式在 HTML 中嵌入 PHP 变量将会非常方便。</p>
<p>对于纯 PHP 文件(如类实现文件), PHP 官方建议顶格写起始标记，同时 省略 结束标记。 这样可以确保整个 PHP 文件都是 PHP 代码，没有任何输出，否则当你包含该文件后，设置 Header 和 Cookie 时会遇到一些麻烦（Header 和 Cookie 必须在输出任何内容之前被发送）。</p>
<h5 id="数组简写形式">数组简写形式</h5><p>这是非常方便的一项特征！<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原来数组的写法</span></span><br><span class="line">    <span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">"key"</span> =&gt; <span class="string">"value"</span>, <span class="string">"key2"</span> =&gt; <span class="string">"value2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简写形式</span></span><br><span class="line">    <span class="variable">$arr</span> = [<span class="string">"key"</span> =&gt; <span class="string">"value"</span>, <span class="string">"key2"</span> =&gt; <span class="string">"value2"</span>];</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Traits">Traits</h5><p>所谓Traits就是“构件”，是用来替代继承的一种机制。PHP中无法进行多重继承，但一个类可以包含多个Traits.</p>
<p>详细内部请看这里还有这里</p>
<h5 id="内置_Web_服务器">内置 Web 服务器</h5><p>PHP从5.4开始内置一个轻量级的Web服务器，不支持并发，定位是用于开发和调试环境。</p>
<p>在开发环境使用它的确非常方便。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S localhost:<span class="number">8000</span></span><br></pre></td></tr></table></figure></p>
<p>这样就在当前目录建立起了一个Web服务器，你可以通过 <a href="http://localhost:8000/" target="_blank" rel="external">http://localhost:8000/</a> 来访问。</p>
<p>其中localhost是监听的ip，8000是监听的端口，可以自行修改。</p>
<p>很多应用中，都会进行URL重写，所以PHP提供了一个设置路由脚本的功能:<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S localhost:<span class="number">8000</span> index.php</span><br></pre></td></tr></table></figure></p>
<p>这样一来，所有的请求都会由index.php来处理。</p>
<h5 id="细节修改">细节修改</h5><p>PHP5.4 新增了动态访问静态方法的方式：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    <span class="variable">$func</span> = <span class="string">"Foo"</span>;</span><br><span class="line">    A::&#123;<span class="variable">$func</span>&#125;();   <span class="comment">// 相当于 A::Foo();</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>新增在实例化时访问类成员的特征：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    (<span class="keyword">new</span> MyClass())-&gt;foo();</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>新增支持对函数返回数组的成员访问解析(这种写法在之前版本是会报错的)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    var_dump( func()[<span class="number">0</span>] );</span><br><span class="line">    <span class="comment">//如果func返回一个数据，这里直接取第0项元素</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="PHP5-3_2009-2012">PHP5.3 2009-2012</h3><h5 id="匿名函数">匿名函数</h5><p>匿名函数也叫闭包(Closures)，经常被用来临时性的创建一个无名函数，用于回调函数等用途。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$func</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        var_dump(func_get_args());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$func</span>(<span class="string">"Hello"</span>,<span class="string">"world"</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上代码定义了一个匿名函数，并赋值给了func。</p>
<p>可以看到定义匿名函数依然使用function关键字，只不过省略了函数名，直接是参数列表。</p>
<p>然后我们又调用了$func所储存的匿名函数。</p>
<p>匿名函数还可以通过use关键字来捕捉外部变量。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ArrayPlus</span><span class="params">(<span class="variable">$array</span>, <span class="variable">$num</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        array_walk(<span class="variable">$array</span>, <span class="function"><span class="keyword">function</span><span class="params">(&amp;<span class="variable">$v</span>)</span> <span class="title">use</span><span class="params">(<span class="variable">$num</span>)</span></span>&#123;</span><br><span class="line">            <span class="variable">$v</span> *= <span class="variable">$num</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$array</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var_dump(ArrayPlus([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">6</span>));</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码定义了一个ArrayPlus()函数（这不是匿名函数），它会将一个数组（$array）中的每一项，加上一个指定的数字（$num）。</p>
<p>在ArrayPlus()的实现中，我们使用了array_walk()函数，它会为一个数组的每一项执行一个回调函数，即我们定义的匿名函数。</p>
<p>在匿名函数的参数列表后，我们用use关键字将匿名函数外的$num捕捉到了函数内部，以便我们知道该加多少。</p>
<h5 id="魔术方法:_invoke(),_callStatic()">魔术方法: <strong>invoke(), </strong>callStatic()</h5><p>PHP的面向对象体系中，提供了若干“魔术方法”，用于实现类似其它语言中的“重载”，如访问不存在的方法、属性时触发某个魔术方法。</p>
<p>随着匿名函数的加入，PHP引入了一个新的魔术方法__invoke()。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(<span class="variable">$str</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"A::__invoke:&#123;$str&#125;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="variable">$a</span>(<span class="string">"jaylee.cc"</span>);    <span class="comment">//A::__invoke:jaylee.cc</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>__callStatic()则会在调用一个不存在的静态方法时被调用。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">(<span class="variable">$methodName</span>, <span class="variable">$args</span>)</span></span>&#123;</span><br><span class="line">            var_dump(<span class="variable">$methodName</span>, <span class="variable">$args</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A::test(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="命名空间">命名空间</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名空间的分隔符是反斜杠，该声明语句必须在文件第一行。</span></span><br><span class="line">    <span class="comment">// 命名空间中可以包含任意代码，但只有类，函数，常量受命名空间的影响</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Jaylee</span>\<span class="title">Test</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该类的完整限定名是\Jaylee\Test\A，其中第一个反斜杠表示全局命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"namespace:"</span>.<span class="keyword">__NAMESPACE__</span>.<span class="string">", "</span>.<span class="keyword">__CLASS__</span>.<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你还可以在命名空间中定义第二个命名空间，接下来的代码都位于\Other\Test2</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Other</span>\<span class="title">Test2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化来自其它命名空间中的对象</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> \Jaylee\Test\A;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"namespace:"</span>.<span class="keyword">__NAMESPACE__</span>.<span class="string">", "</span>.<span class="keyword">__CLASS__</span>.<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Other</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化来自子命名空间的对象</span></span><br><span class="line">    <span class="variable">$b</span> = <span class="keyword">new</span> Test2\B;</span><br><span class="line">    <span class="variable">$b</span>-&gt;test();</span><br><span class="line">    <span class="comment">// 导入来自其它命名空间的名称，并重命名</span></span><br><span class="line">    <span class="comment">// 注意只能导入类，不能用于函数和常量</span></span><br><span class="line">    <span class="keyword">use</span> \<span class="title">Jaylee</span>\<span class="title">Test</span>\<span class="title">A</span> <span class="title">as</span> <span class="title">ClassA</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> ClassA();</span><br><span class="line">    <span class="variable">$a</span>-&gt;test();</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多有关命名空间的语法介绍请参见官网。</p>
<p>命名空间经常和autoload一起使用，用于自动加载类文件：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    spl_autoload_register(</span><br><span class="line">        <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$className</span>)</span></span>&#123;</span><br><span class="line">            spl_autoload(str_replace(<span class="string">"\\"</span>, <span class="string">"/"</span>, <span class="variable">$className</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当你实例化一个类\Jaylee\Test\TestA的时候，这个类的完整限定名称会被传递给autoload函数，autoload函数将类名中的命名空间分隔符替换为反斜杠，并包含对应文件。</p>
<p>这样可以实现类定义文件分组存储，按需自动加载。</p>
<h5 id="延迟静态绑定">延迟静态绑定</h5><p>PHP的的 OPP 机制，具有继承和类似虚函数的功能，例如如下的代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$this</span>-&gt;foo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A::foo()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B::foo()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$b</span> = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="variable">$b</span>-&gt;callFoo();      <span class="comment">//B::foo();</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，当在A中使用了$this-&gt;foo()时，体现了“虚函数”的机制，实际调用的是B::foo()，然后如果将所有的函数都改为静态函数时：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">self</span>::foo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A::foo()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B::foo()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B::callFoo();   <span class="comment">//A::foo()</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这时，输出的会是A::foo()，这是因为self的语义本来就是“当前类”，所有在PHP5.3给static关键赋予了一个新的功能：延迟静态绑定：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">static</span>::foo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>将self改为static之后，就会像预期一样输出B::foo了。</p>
<h5 id="Heredoc_和_Nowdoc">Heredoc 和 Nowdoc</h5><p>PHP5.3对Heredoc以及Nowdoc进行了一些改进，它们都用于在PHP中嵌入大段的代码。</p>
<p>Heredoc的行为类似于一个双引号字符串：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$name</span> = <span class="string">"Jaylee"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&lt;&lt;&lt;TEXT</span><br><span class="line"></span><br><span class="line">my name is "&#123;$name&#125;"</span><br><span class="line"></span><br><span class="line">TEXT;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Heredoc以三个尖括号开始，后面跟一个标识符（TEXT）,直到一个同样的定格标识符（不能缩进）结束。 就像双引号字符串一样，其中可以嵌入变量。</p>
<p>Heredoc还可以用于函数参数，以及类成员初始化：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">var_dump(<span class="string">&lt;&lt;&lt;EOD</span><br><span class="line">    hello world</span><br><span class="line">EOD</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    const name = &lt;&lt;&lt;EOD</span><br><span class="line">hello world</span><br><span class="line">EOD;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$foo</span> = <span class="string">&lt;&lt;&lt;EOD</span><br><span class="line">hello world2</span><br><span class="line">EOD;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Nowdoc的行为像一个单引号字符串，不能在其中嵌入变量，和Heredoc唯一的区别就是，三个尖括号的标识符要用单引号引起来：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    <span class="variable">$name</span> = <span class="string">"Jaylee"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&lt;&lt;&lt;'EOD'</span><br><span class="line">my name is "&#123;$name&#125;"</span><br><span class="line">EOD;</span></span><br><span class="line">    <span class="comment">//输出：my name is "&#123;$name&#125;"</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="用const定义常量">用const定义常量</h5><p>php5.3起同时支持在全局命名空间和类中使用 const 定义常量。</p>
<p>旧式风格：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    define(<span class="string">"NAME"</span>,<span class="string">"jaylee"</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>新式风格：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> NAME = <span class="string">"Jaylee"</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>const形式仅适用于常量，不适用于运行时才能求值的表达式。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> VALUE = <span class="number">1234</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> VALUE = <span class="number">1000</span>*<span class="number">2</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="三元运算符的简写形式">三元运算符的简写形式</h5><p>旧式风格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;?php&#10;&#10;    echo $a ? $a : &#34;No VALUE&#34;;&#10;&#10;?&#62;</span><br></pre></td></tr></table></figure></p>
<p>可以简写成：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span> ? : <span class="string">"No Value"</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>即如果省略三元运算符的第二个部分，会默认用第一个部分代替。</p>
<h5 id="Phar">Phar</h5><p>Phar即PHP Archive, 起初只是Pear中的一个库而已，后来在PHP5.3被重新编写成C扩展并内置到 PHP 中。 Phar用来将多个 .php 脚本打包(也可以打包其他文件)成一个 .phar 的压缩文件(通常是ZIP格式)。 目的在于模仿 Java 的 .jar, 不对，目的是为了让发布PHP应用程序更加方便。同时Phar还提供了数字签名验证等功能。</p>
<p>.phar 文件可以像 .php 文件一样被 PHP 引擎解释执行，同时你还可以写出这样的代码来包含 .phar 中的代码。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">require</span> <span class="string">"xxx.phar"</span>;</span><br><span class="line">    <span class="keyword">require</span> <span class="string">"phar://xxx.phar/aa/bb.php"</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>更多信息请参见<a href="http://www.php.net/manual/zh/phar.using.intro.php" target="_blank" rel="external">官网</a>;</p>
<h3 id="PHP5-2">PHP5.2</h3><h5 id="autoload">autoload</h5><p>大家应该都知道__autoload()函数，如果定义了该函数，那么当在代码中使用了一个未定义的类的时候，该函数就会被调用，你可以在该函数中加载相应的类实现文件，如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">(<span class="variable">$className</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">require_once</span> <span class="variable">$className</span>.<span class="string">".class.php"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$foo</span> = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样，在执行new操作的时候，会在当前目录下寻找Foo.class.php这个文件，并加载进来。</p>
<p>但该函数已经不建议使用，原因是一个项目中仅能有一个这样的__autoload()函数，因为PHP不允许函数重名。但当你用到一些类库的时候，难免会出现多个autoload函数的需要，于是spl_autoload_register()取而代之：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">autoloadModel</span><span class="params">(<span class="variable">$className</span>)</span></span>&#123;</span><br><span class="line">        <span class="variable">$filename</span> = <span class="string">"models/"</span>.<span class="variable">$className</span>.<span class="string">".php"</span>;</span><br><span class="line">        <span class="keyword">if</span> ( file_exists(<span class="variable">$filename</span>) )&#123;</span><br><span class="line">            <span class="keyword">require_once</span> <span class="variable">$filename</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">autoloadController</span><span class="params">(<span class="variable">$className</span>)</span></span>&#123;</span><br><span class="line">        <span class="variable">$filename</span> = <span class="string">"controller/"</span>.<span class="variable">$className</span>.<span class="string">".php"</span>;</span><br><span class="line">        <span class="keyword">if</span> ( file_exists(<span class="variable">$filename</span>) )&#123;</span><br><span class="line">            <span class="keyword">require_once</span> <span class="variable">$filename</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spl_autoload_register(<span class="string">"autoloadModel"</span>);</span><br><span class="line">    spl_autoload_register(<span class="string">"autoloadController"</span>);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>spl_autoload_register()会将一个函数注册到autoload函数列表中，当出现未定义的类的时候，SPL会按照注册的顺序逐个调用被注册的autoload函数，这意味着你可以使用spl_autoload_register注册多个autoload函数。</p>
<h5 id="PDO和MySQLi">PDO和MySQLi</h5><p>PDO即PHP Data Object , PHP数据对象，这是PHP的新式数据库访问接口。</p>
<p>按照传统的风格，访问MySQL数据库应该是这个样子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$conn</span> = mysql_connect(<span class="string">"localhost"</span>,<span class="string">"user"</span>,<span class="string">"passwd"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Connection failed"</span>);</span><br><span class="line"></span><br><span class="line">    mysql_select_db(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$type</span> = <span class="variable">$_POST</span>[<span class="string">"type"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">"select * from `table` where `type` = &#123;$type&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$result</span> = mysql_query(<span class="variable">$sql</span>, <span class="variable">$conn</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = mysql_fetch_assoc(<span class="variable">$result</span>))&#123;</span><br><span class="line">        var_dump(<span class="variable">$row</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysql_free_result(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line">    mysql_close(<span class="variable">$conn</span>);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>为了能让代码实现与数据库无关，即同一段代码适用于多种数据库（例如以上代码仅适用于MySQL），PHP官方设计了PDO.</p>
<p>除此之外，PDO还提供了更多的功能，比如：</p>
<p>面对对象风格接口<br>SQL预编译，占位符语法<br>更高的执行效率，作为官方推荐，有特别的性能优化<br>支持大部分SQL数据库，更换数据库无需改动代码<br>上面的代码用PDO实现将会是这个样子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$dsn</span> = <span class="string">"mysql:host=localhost;dbname=test"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$conn</span> = <span class="keyword">new</span> PDO(<span class="variable">$dsn</span>, <span class="string">"user"</span>, <span class="string">"passwd"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$sql</span> = <span class="string">"select * from user where type = :type "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;prepare(<span class="variable">$sql</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$stmt</span>-&gt;bindParams(<span class="string">"type"</span>,<span class="variable">$_POST</span>[<span class="string">"type"</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$stmt</span>-&gt;execute();</span><br><span class="line"></span><br><span class="line">        <span class="variable">$stmt</span>-&gt;fetchAll(PDO::FETCH_ASSOC);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(PDOException <span class="variable">$e</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$e</span>-&gt;getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>PDO是官方推荐的，更为通用的数据库访问方式，如果你没有特殊的需求，那么最好学习和使用POD，但如果你需要使用MySQL所特有的高级功能，那么你可能需要尝试一下MySQLi，因为PDO为了能够同时在多种数据库上使用，不会包含那些MySQL独有的功能。</p>
<h5 id="类型约束">类型约束</h5><p>通过类型约束可以限制参数的类型，不过这一机制并不完善，仅适用于对象，接口，callable，以及array，不适用于string和int，如果参数类型不匹配，则会产生一个fatal error.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;?php&#10;&#10;    function test(callable $callable, array $arr, MyClass $myclass)&#123;&#10;        //...&#10;    &#125;&#10;&#10;?&#62;</span><br></pre></td></tr></table></figure></p>
<h3 id="PHP5-2_2006年_~_2011年">PHP5.2 2006年 ~ 2011年</h3><h5 id="JSON支持">JSON支持</h5><p>包括jsonencode(), jsondecode()等函数，JSON算是在web领域非常实用的数据交换格式，可以被JS直接支持，JSON实际上JS语法的一部分。</p>
<p>JSON系列函数，可以将PHP中的数组结构与JSON字符串进行转换。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">"key"</span>   =&gt;  <span class="string">"value"</span>,</span><br><span class="line">        <span class="string">"array"</span> =&gt;  <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="variable">$json</span> = json_encode(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$json</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$object</span> = json_decode(<span class="variable">$json</span>);</span><br><span class="line"></span><br><span class="line">    print_r(<span class="variable">$object</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#34;key&#34;:&#34;value&#34;,&#34;array&#34;:[1,2,3,4]&#125;&#10;&#10;stdClass Object&#10;(&#10;    [key] =&#62; value&#10;    [array] =&#62; Array&#10;        (&#10;            [0] =&#62; 1&#10;            [1] =&#62; 2&#10;            [2] =&#62; 3&#10;            [3] =&#62; 4&#10;        )&#10;)</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，json_decode()默认会返回一个对象而非数组，如果需要返回数组需要将第二个参数设为true。同时json_encode()在php5.4的时候增加了一个JSON_UNESCAPED_UNICODE的常量，这样，如果键值对中包含中文就不会被编码成unicode字符了。</p>


<!--<a href="http://yoursite.com/2015-1-11-new-in-php.html#disqus_thread" class="article-comment-link">Comments</a>-->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = mickeyouyou; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div>







</body>
</html>