<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>New Features from PHP5.2 to 5.6</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=4.2" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	   <link rel="shortcut icon" type="image/x-icon" href="/rocket_128px_1215034_easyicon.net.ico?v=4.2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>


<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 class="title">New Features from PHP5.2 to 5.6</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2015年1月11日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP5-6-2014-8"><span class="toc-text"><a href="#PHP5-6-2014-8" class="headerlink" title="PHP5.6 2014.8"></a>PHP5.6 2014.8</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常量表达式"><span class="toc-text"><a href="#&#x5E38;&#x91CF;&#x8868;&#x8FBE;&#x5F0F;" class="headerlink" title="&#x5E38;&#x91CF;&#x8868;&#x8FBE;&#x5F0F;"></a>&#x5E38;&#x91CF;&#x8868;&#x8FBE;&#x5F0F;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可变参数函数"><span class="toc-text"><a href="#&#x53EF;&#x53D8;&#x53C2;&#x6570;&#x51FD;&#x6570;" class="headerlink" title="&#x53EF;&#x53D8;&#x53C2;&#x6570;&#x51FD;&#x6570;"></a>&#x53EF;&#x53D8;&#x53C2;&#x6570;&#x51FD;&#x6570;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数解包功能"><span class="toc-text"><a href="#&#x53C2;&#x6570;&#x89E3;&#x5305;&#x529F;&#x80FD;" class="headerlink" title="&#x53C2;&#x6570;&#x89E3;&#x5305;&#x529F;&#x80FD;"></a>&#x53C2;&#x6570;&#x89E3;&#x5305;&#x529F;&#x80FD;</span></a></li></ol></li></ol>
<p>自10年开始php，自己在改变，PHP本身也在发生着变化。截至目前( 2015.01 )，PHP的最新稳定版本是PHP5.6.4，但有差不多一半的用户仍然在使用已经不在维护的PHP5.2，其余的一半用户在使用PHP5.3 ( PHP5.3也于2014年9月停止支持 )。因为PHP那 “ 集百家之长 ”的蛋疼语法，加上社区氛围不太好，许多人对新版本，新特性并无兴趣。</p>
<p>本文会介绍自PHP5.2起，直到PHP5.6中增加的新特性。</p>
<ul>
<li>PHP5.6：常量增强，可变函数参数，命名空间增强</li>
<li>PHP5.5：yield，list()可用于foreach循环，细节修改</li>
<li>PHP5.4：Short Open Tag，数组简写形式，Traits，内置web服务器，细节修改</li>
<li>PHP5.3：弃用的功能，匿名函数，新增魔术方法，命名空间，延迟静态绑定，Heredoc和Nowdoc，const，三元运算符，Phar</li>
<li>PHP5.2：JSON的支持</li>
<li>PHP5.2以前：autoload, PDO和MySQLi, 类型约束</li>
</ul>
<h3 id="PHP5-6-2014-8"><a href="#PHP5-6-2014-8" class="headerlink" title="PHP5.6 2014.8"></a>PHP5.6 2014.8</h3><h4 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h4><p>在常量、属性声明和函数参数默认值声明时，以前版本只允许常量值，PHP5.6开始允许使用包含数字、字符串字面值和常量的标量表达式。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ONE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> TWO = ONE * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> THREE = TWO + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> ONE_THIRD = ONE / <span class="keyword">self</span>::THREE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> SENTENCE = <span class="string">'The value of '</span>.<span class="keyword">self</span>::THREE.<span class="string">' is 3'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> <span class="params">($a = ONE + self::THREE)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> (<span class="keyword">new</span> C)-&gt;f();  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> C::SENTENCE;   <span class="comment">//The value of 3 is 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h4><p>可变函数的实现，不再依赖func_get_args()函数，现在可以通过新增的操作符…更简洁地实现。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">($req, $opt = null, ...$params)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"\$req: %d; \$opt: %d; number of params: %d\n"</span>,</span><br><span class="line">                $req, $opt, count($params));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(<span class="number">1</span>);</span><br><span class="line">    foo(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$req: 1; $opt: 0; number of params: 0</span><br><span class="line">   $req: 1; $opt: 2; number of params: 0</span><br><span class="line">   $req: 1; $opt: 2; number of params: 1</span><br><span class="line">   $req: 1; $opt: 2; number of params: 2</span><br><span class="line">   $req: 1; $opt: 2; number of params: 3</span><br></pre></td></tr></table></figure></p>
<h4 id="参数解包功能"><a href="#参数解包功能" class="headerlink" title="参数解包功能"></a>参数解包功能</h4><p>在调用函数时，通过…操作符可以把数组或者可遍历对象解包到参数列表，这和Ruby等语言中的扩张(splat)操作符类似。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">($a, $b, $c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $a + $b + $c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $operators = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> add(...$operators);    <span class="comment">//6</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 导入函数和常量</span></span><br><span class="line"><span class="keyword">use</span> 操作符开始支持函数和常量的导入。 <span class="title">use</span> <span class="title">function</span> 和 <span class="title">use</span> <span class="title">const</span> 结构的用法的示例：</span><br><span class="line">```<span class="title">php</span></span><br><span class="line">&lt;?<span class="title">php</span></span><br><span class="line"></span><br><span class="line">    <span class="title">namespace</span> <span class="title">cc</span>\<span class="title">jaylee</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title">const</span> <span class="title">FOO</span> = 11;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title">use</span> <span class="title">const</span> <span class="title">cc</span>\<span class="title">jaylee</span>\<span class="title">FOO</span>;</span><br><span class="line">        <span class="keyword">use</span> <span class="title">function</span> <span class="title">cc</span>\<span class="title">jaylee</span>\<span class="title">f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> FOO;   \\ <span class="number">11</span></span><br><span class="line"></span><br><span class="line">        f();        \\ cc\jaylee\f</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">```			</span><br><span class="line"><span class="comment">####phpdbg</span></span><br><span class="line">PHP自带了一个交互式调试器phpdbg，它是一个SAPI模块，更多信息参考 phpdbg 文档。</span><br><span class="line"><span class="comment">####php://input可以被复用</span></span><br><span class="line">php:<span class="comment">//input 开始支持多次打开和读取，这给处理POST数据的模块的内存占用带来了极大的改善。</span></span><br><span class="line"><span class="comment">#####大文件上传支持</span></span><br><span class="line">可以上传超过<span class="number">2</span>G的大文件。</span><br><span class="line"><span class="comment">####GMP支持操作符重载</span></span><br><span class="line"><span class="comment">####新增gost-crypto哈希算法</span></span><br><span class="line"><span class="comment">####SSL/TSL改进</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###PHP5.5 2013</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####yield关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span>关键字用于当函数需要返回一个迭代器的时候，逐个返回值。</span><br><span class="line"></span><br><span class="line">该函数返回一个迭代器对象。</span><br><span class="line"></span><br><span class="line"><span class="comment">####list()用于foreach</span></span><br><span class="line"></span><br><span class="line">该特性可以在<span class="keyword">foreach</span>中解析嵌套的数组：</span><br><span class="line">```php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    $arr = [</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($arr <span class="keyword">as</span> <span class="keyword">list</span>($a, $b, $c))&#123;</span><br><span class="line">        <span class="keyword">echo</span> $a.<span class="string">"=="</span>.$b.<span class="string">"=="</span>.$c.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>==<span class="number">2</span>==<span class="number">3</span></span><br><span class="line">a==b==c</span><br></pre></td></tr></table></figure></p>
<p>####其他修改</p>
<ul>
<li><p>不推荐使用 mysql 函数，推荐使用 PDO 或 MySQLi, 参见前文。</p>
</li>
<li><p>不再支持Windows XP.</p>
</li>
<li><p>可用 MyClass::class 取到一个类的完整限定名(包括命名空间)。</p>
</li>
<li><p>empty() 支持表达式作为参数。</p>
</li>
<li><p>try-catch 结构新增 finally 块。</p>
</li>
</ul>
<p>###PHP5.4  2012</p>
<p>####Short Open Tag<br>Short Open Tag 自PHP5.4起总是可用。</p>
<p>在这里集中讲一下有关 PHP 起止标签的问题。即：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通常就是上面的形式，除此之外还有一种简写形式：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> <span class="comment">/*  code  */</span> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>还可以把<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> <span class="keyword">echo</span> $foo;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>简写成：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>=$foo<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这种简写形式被称为 Short Open Tag, 在 PHP5.3 起被默认开启，在 PHP5.4 起总是可用。 使用这种简写形式在 HTML 中嵌入 PHP 变量将会非常方便。</p>
<p>对于纯 PHP 文件(如类实现文件), PHP 官方建议顶格写起始标记，同时 省略 结束标记。 这样可以确保整个 PHP 文件都是 PHP 代码，没有任何输出，否则当你包含该文件后，设置 Header 和 Cookie 时会遇到一些麻烦（Header 和 Cookie 必须在输出任何内容之前被发送）。</p>
<p>####数组简写形式</p>
<p>这是非常方便的一项特征！<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原来数组的写法</span></span><br><span class="line">    $arr = <span class="keyword">array</span>(<span class="string">"key"</span> =&gt; <span class="string">"value"</span>, <span class="string">"key2"</span> =&gt; <span class="string">"value2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简写形式</span></span><br><span class="line">    $arr = [<span class="string">"key"</span> =&gt; <span class="string">"value"</span>, <span class="string">"key2"</span> =&gt; <span class="string">"value2"</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>####Traits</p>
<p>所谓Traits就是“构件”，是用来替代继承的一种机制。PHP中无法进行多重继承，但一个类可以包含多个Traits.</p>
<p>详细内部请看这里还有这里</p>
<p>####内置 Web 服务器</p>
<p>PHP从5.4开始内置一个轻量级的Web服务器，不支持并发，定位是用于开发和调试环境。</p>
<p>在开发环境使用它的确非常方便。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">php -S localhost:8000</span><br></pre></td></tr></table></figure></p>
<p>这样就在当前目录建立起了一个Web服务器，你可以通过 <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> 来访问。</p>
<p>其中localhost是监听的ip，8000是监听的端口，可以自行修改。</p>
<p>很多应用中，都会进行URL重写，所以PHP提供了一个设置路由脚本的功能:<br> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">php -S localhost:8000 index.php</span><br></pre></td></tr></table></figure></p>
<p>这样一来，所有的请求都会由index.php来处理。</p>
<p>#####细节修改</p>
<p>PHP5.4 新增了动态访问静态方法的方式：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $func = <span class="string">"Foo"</span>;</span><br><span class="line">    A::&#123;$func&#125;();   <span class="comment">// 相当于 A::Foo();</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>新增在实例化时访问类成员的特征：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    (<span class="keyword">new</span> MyClass())-&gt;foo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>新增支持对函数返回数组的成员访问解析(这种写法在之前版本是会报错的)：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    var_dump( func()[<span class="number">0</span>] );</span><br><span class="line">    <span class="comment">//如果func返回一个数据，这里直接取第0项元素</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>###PHP5.3 2009-2012</p>
<p>####匿名函数</p>
<p>匿名函数也叫闭包(Closures)，经常被用来临时性的创建一个无名函数，用于回调函数等用途。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    $func = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        var_dump(func_get_args());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $func(<span class="string">"Hello"</span>,<span class="string">"world"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上代码定义了一个匿名函数，并赋值给了func。</p>
<p>可以看到定义匿名函数依然使用function关键字，只不过省略了函数名，直接是参数列表。</p>
<p>然后我们又调用了$func所储存的匿名函数。</p>
<p>匿名函数还可以通过use关键字来捕捉外部变量。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ArrayPlus</span><span class="params">($array, $num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        array_walk($array, <span class="function"><span class="keyword">function</span><span class="params">(&amp;$v)</span> <span class="title">use</span><span class="params">($num)</span></span>&#123;</span><br><span class="line">            $v *= $num;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var_dump(ArrayPlus([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">6</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码定义了一个ArrayPlus()函数（这不是匿名函数），它会将一个数组（$array）中的每一项，加上一个指定的数字（$num）。</p>
<p>在ArrayPlus()的实现中，我们使用了array_walk()函数，它会为一个数组的每一项执行一个回调函数，即我们定义的匿名函数。</p>
<p>在匿名函数的参数列表后，我们用use关键字将匿名函数外的$num捕捉到了函数内部，以便我们知道该加多少。</p>
<p>####魔术方法: <strong>invoke(), </strong>callStatic()</p>
<p>PHP的面向对象体系中，提供了若干“魔术方法”，用于实现类似其它语言中的“重载”，如访问不存在的方法、属性时触发某个魔术方法。</p>
<p>随着匿名函数的加入，PHP引入了一个新的魔术方法__invoke()。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"A::__invoke:&#123;$str&#125;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    $a(<span class="string">"jaylee.cc"</span>);    <span class="comment">//A::__invoke:jaylee.cc</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>__callStatic()则会在调用一个不存在的静态方法时被调用。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">($methodName, $args)</span></span>&#123;</span><br><span class="line">            var_dump($methodName, $args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A::test(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>####命名空间<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名空间的分隔符是反斜杠，该声明语句必须在文件第一行。</span></span><br><span class="line">    <span class="comment">// 命名空间中可以包含任意代码，但只有类，函数，常量受命名空间的影响</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Jaylee</span>\<span class="title">Test</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该类的完整限定名是\Jaylee\Test\A，其中第一个反斜杠表示全局命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"namespace:"</span>.<span class="keyword">__NAMESPACE__</span>.<span class="string">", "</span>.<span class="keyword">__CLASS__</span>.<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你还可以在命名空间中定义第二个命名空间，接下来的代码都位于\Other\Test2</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Other</span>\<span class="title">Test2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化来自其它命名空间中的对象</span></span><br><span class="line">    $a = <span class="keyword">new</span> \Jaylee\Test\A;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"namespace:"</span>.<span class="keyword">__NAMESPACE__</span>.<span class="string">", "</span>.<span class="keyword">__CLASS__</span>.<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Other</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化来自子命名空间的对象</span></span><br><span class="line">    $b = <span class="keyword">new</span> Test2\B;</span><br><span class="line">    $b-&gt;test();</span><br><span class="line">    <span class="comment">// 导入来自其它命名空间的名称，并重命名</span></span><br><span class="line">    <span class="comment">// 注意只能导入类，不能用于函数和常量</span></span><br><span class="line">    <span class="keyword">use</span> \<span class="title">Jaylee</span>\<span class="title">Test</span>\<span class="title">A</span> <span class="title">as</span> <span class="title">ClassA</span>;</span><br><span class="line">    $a = <span class="keyword">new</span> ClassA();</span><br><span class="line">    $a-&gt;test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>更多有关命名空间的语法介绍请参见官网。</p>
<p>命名空间经常和autoload一起使用，用于自动加载类文件：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    spl_autoload_register(</span><br><span class="line">        <span class="function"><span class="keyword">function</span><span class="params">($className)</span></span>&#123;</span><br><span class="line">            spl_autoload(str_replace(<span class="string">"\\"</span>, <span class="string">"/"</span>, $className));</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当你实例化一个类\Jaylee\Test\TestA的时候，这个类的完整限定名称会被传递给autoload函数，autoload函数将类名中的命名空间分隔符替换为反斜杠，并包含对应文件。</p>
<p>这样可以实现类定义文件分组存储，按需自动加载。</p>
<p>####延迟静态绑定</p>
<p>PHP的的 OPP 机制，具有继承和类似虚函数的功能，例如如下的代码：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;foo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A::foo()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B::foo()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $b = <span class="keyword">new</span> B();</span><br><span class="line">    $b-&gt;callFoo();      <span class="comment">//B::foo();</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，当在A中使用了$this-&gt;foo()时，体现了“虚函数”的机制，实际调用的是B::foo()，然后如果将所有的函数都改为静态函数时：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">self</span>::foo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A::foo()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B::foo()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B::callFoo();   <span class="comment">//A::foo()</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这时，输出的会是A::foo()，这是因为self的语义本来就是“当前类”，所有在PHP5.3给static关键赋予了一个新的功能：延迟静态绑定：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">static</span>::foo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>将self改为static之后，就会像预期一样输出B::foo了。</p>
<p>####Heredoc 和 Nowdoc</p>
<p>PHP5.3对Heredoc以及Nowdoc进行了一些改进，它们都用于在PHP中嵌入大段的代码。</p>
<p>Heredoc的行为类似于一个双引号字符串：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$name = <span class="string">"Jaylee"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&lt;&lt;&lt;TEXT</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my name is "<span class="subst">&#123;$name&#125;</span>"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TEXT;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Heredoc以三个尖括号开始，后面跟一个标识符（TEXT）,直到一个同样的定格标识符（不能缩进）结束。 就像双引号字符串一样，其中可以嵌入变量。</p>
<p>Heredoc还可以用于函数参数，以及类成员初始化：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">var_dump(<span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">    hello world</span></span><br><span class="line"><span class="string">EOD</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">EOD;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $foo = <span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">hello world2</span></span><br><span class="line"><span class="string">EOD;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Nowdoc的行为像一个单引号字符串，不能在其中嵌入变量，和Heredoc唯一的区别就是，三个尖括号的标识符要用单引号引起来：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $name = <span class="string">"Jaylee"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&lt;&lt;&lt;'EOD'</span></span><br><span class="line"><span class="string">my name is "<span class="subst">&#123;$name&#125;</span>"</span></span><br><span class="line"><span class="string">EOD;</span></span><br><span class="line">    <span class="comment">//输出：my name is "&#123;$name&#125;"</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>####用const定义常量</p>
<p>php5.3起同时支持在全局命名空间和类中使用 const 定义常量。</p>
<p>旧式风格：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    define(<span class="string">"NAME"</span>,<span class="string">"jaylee"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>新式风格：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> NAME = <span class="string">"Jaylee"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>const形式仅适用于常量，不适用于运行时才能求值的表达式。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> VALUE = <span class="number">1234</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> VALUE = <span class="number">1000</span>*<span class="number">2</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>####三元运算符的简写形式</p>
<p>旧式风格：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    echo $a ? $a : &quot;No VALUE&quot;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以简写成：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> $a ? : <span class="string">"No Value"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>即如果省略三元运算符的第二个部分，会默认用第一个部分代替。</p>
<p>####Phar</p>
<p>Phar即PHP Archive, 起初只是Pear中的一个库而已，后来在PHP5.3被重新编写成C扩展并内置到 PHP 中。 Phar用来将多个 .php 脚本打包(也可以打包其他文件)成一个 .phar 的压缩文件(通常是ZIP格式)。 目的在于模仿 Java 的 .jar, 不对，目的是为了让发布PHP应用程序更加方便。同时Phar还提供了数字签名验证等功能。</p>
<p>.phar 文件可以像 .php 文件一样被 PHP 引擎解释执行，同时你还可以写出这样的代码来包含 .phar 中的代码。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">require</span> <span class="string">"xxx.phar"</span>;</span><br><span class="line">    <span class="keyword">require</span> <span class="string">"phar://xxx.phar/aa/bb.php"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>更多信息请参见<a href="http://www.php.net/manual/zh/phar.using.intro.php" target="_blank" rel="noopener">官网</a>;</p>
<p>###PHP5.2</p>
<p>####autoload</p>
<p>大家应该都知道__autoload()函数，如果定义了该函数，那么当在代码中使用了一个未定义的类的时候，该函数就会被调用，你可以在该函数中加载相应的类实现文件，如：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($className)</span></span>&#123;</span><br><span class="line">        <span class="keyword">require_once</span> $className.<span class="string">".class.php"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样，在执行new操作的时候，会在当前目录下寻找Foo.class.php这个文件，并加载进来。</p>
<p>但该函数已经不建议使用，原因是一个项目中仅能有一个这样的__autoload()函数，因为PHP不允许函数重名。但当你用到一些类库的时候，难免会出现多个autoload函数的需要，于是spl_autoload_register()取而代之：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">autoloadModel</span><span class="params">($className)</span></span>&#123;</span><br><span class="line">        $filename = <span class="string">"models/"</span>.$className.<span class="string">".php"</span>;</span><br><span class="line">        <span class="keyword">if</span> ( file_exists($filename) )&#123;</span><br><span class="line">            <span class="keyword">require_once</span> $filename;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">autoloadController</span><span class="params">($className)</span></span>&#123;</span><br><span class="line">        $filename = <span class="string">"controller/"</span>.$className.<span class="string">".php"</span>;</span><br><span class="line">        <span class="keyword">if</span> ( file_exists($filename) )&#123;</span><br><span class="line">            <span class="keyword">require_once</span> $filename;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spl_autoload_register(<span class="string">"autoloadModel"</span>);</span><br><span class="line">    spl_autoload_register(<span class="string">"autoloadController"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>spl_autoload_register()会将一个函数注册到autoload函数列表中，当出现未定义的类的时候，SPL会按照注册的顺序逐个调用被注册的autoload函数，这意味着你可以使用spl_autoload_register注册多个autoload函数。</p>
<p>####PDO和MySQLi</p>
<p>PDO即PHP Data Object , PHP数据对象，这是PHP的新式数据库访问接口。</p>
<p>按照传统的风格，访问MySQL数据库应该是这个样子：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    $conn = mysql_connect(<span class="string">"localhost"</span>,<span class="string">"user"</span>,<span class="string">"passwd"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Connection failed"</span>);</span><br><span class="line"></span><br><span class="line">    mysql_select_db(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">    $type = $_POST[<span class="string">"type"</span>];</span><br><span class="line"></span><br><span class="line">    $sql = <span class="string">"select * from `table` where `type` = &#123;$type&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    $result = mysql_query($sql, $conn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>($row = mysql_fetch_assoc($result))&#123;</span><br><span class="line">        var_dump($row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysql_free_result($result);</span><br><span class="line"></span><br><span class="line">    mysql_close($conn);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>为了能让代码实现与数据库无关，即同一段代码适用于多种数据库（例如以上代码仅适用于MySQL），PHP官方设计了PDO.</p>
<p>除此之外，PDO还提供了更多的功能，比如：</p>
<p>面对对象风格接口<br>SQL预编译，占位符语法<br>更高的执行效率，作为官方推荐，有特别的性能优化<br>支持大部分SQL数据库，更换数据库无需改动代码<br>上面的代码用PDO实现将会是这个样子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        $dsn = <span class="string">"mysql:host=localhost;dbname=test"</span>;</span><br><span class="line"></span><br><span class="line">        $conn = <span class="keyword">new</span> PDO($dsn, <span class="string">"user"</span>, <span class="string">"passwd"</span>);</span><br><span class="line"></span><br><span class="line">        $sql = <span class="string">"select * from user where type = :type "</span>;</span><br><span class="line"></span><br><span class="line">        $stmt = $conn-&gt;prepare($sql);</span><br><span class="line"></span><br><span class="line">        $stmt-&gt;bindParams(<span class="string">"type"</span>,$_POST[<span class="string">"type"</span>]);</span><br><span class="line"></span><br><span class="line">        $stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">        $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(PDOException $e)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> $e-&gt;getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>PDO是官方推荐的，更为通用的数据库访问方式，如果你没有特殊的需求，那么最好学习和使用POD，但如果你需要使用MySQL所特有的高级功能，那么你可能需要尝试一下MySQLi，因为PDO为了能够同时在多种数据库上使用，不会包含那些MySQL独有的功能。</p>
<p>####类型约束</p>
<p>通过类型约束可以限制参数的类型，不过这一机制并不完善，仅适用于对象，接口，callable，以及array，不适用于string和int，如果参数类型不匹配，则会产生一个fatal error.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    function test(callable $callable, array $arr, MyClass $myclass)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>###PHP5.2 2006年 ~ 2011年</p>
<p>####JSON支持</p>
<p>包括jsonencode(), jsondecode()等函数，JSON算是在web领域非常实用的数据交换格式，可以被JS直接支持，JSON实际上JS语法的一部分。</p>
<p>JSON系列函数，可以将PHP中的数组结构与JSON字符串进行转换。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    $arr = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">"key"</span>   =&gt;  <span class="string">"value"</span>,</span><br><span class="line">        <span class="string">"array"</span> =&gt;  <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    $json = json_encode($arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> $json;</span><br><span class="line"></span><br><span class="line">    $object = json_decode($json);</span><br><span class="line"></span><br><span class="line">    print_r($object);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;key&quot;:&quot;value&quot;,&quot;array&quot;:[1,2,3,4]&#125;</span><br><span class="line"></span><br><span class="line">stdClass Object</span><br><span class="line">(</span><br><span class="line">    [key] =&gt; value</span><br><span class="line">    [array] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [0] =&gt; 1</span><br><span class="line">            [1] =&gt; 2</span><br><span class="line">            [2] =&gt; 3</span><br><span class="line">            [3] =&gt; 4</span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，json_decode()默认会返回一个对象而非数组，如果需要返回数组需要将第二个参数设为true。同时json_encode()在php5.4的时候增加了一个JSON_UNESCAPED_UNICODE的常量，这样，如果键值对中包含中文就不会被编码成unicode字符了。</p>


  
    <div class="comments" id="comments">
      
        <div onclick="showGitment()" id="gitment-display-button">如果你有不同看法？</div>
        <div id="gitment-container" style="display:none"></div>
      
    </div>
  

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div>




    
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    



      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname, 
            owner: 'mickeyouyou',
            repo: 'blog_comment',
            
            lang: "en" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '27804beebc0d0aa2ae7271191fd5adac6d1b8cb7',
            
                client_id: '57e78fbfba943c338437'
            }});
        gitment.render('gitment-container');
      }

      
          function showGitment(){
            document.getElementById("gitment-display-button").style.display = "none";
            document.getElementById("gitment-container").style.display = "block";
            renderGitment();
          }
      
      </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
    




</body>
</html>