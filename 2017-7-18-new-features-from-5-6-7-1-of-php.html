<html>
<head>
	
	<title>7.0-7.1 的新特性</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js" type="text/javascript"></script>
        <script>
            if(!isMobile()) {
                loadjscssfile('../css/desktop.css', 'css');
                }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/>
    

</head>

<body>

<h2 class="title">7.0-7.1 的新特性</h2>
<p>对于新特性，我们总是后知后觉。之前的5.2到5.6的新特性整理，让我看了一遍又一遍，寻找某个新特性的起始版本，原来就在自己整理过的文档里。</p>
<h2 id="7-1_release_on_2016">7.1 release on 2016</h2><h3 id="可为空（Nullable）类型">可为空（Nullable）类型</h3><p>类型现在允许为空，当启用这个特性时，传入的参数或者函数返回的结果要么是给定的类型，要么是 null 。可以通过在类型前面加上一个问号来使之成为可为空的。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(?string <span class="variable">$name</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    var_dump(<span class="variable">$name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'tpunt'</span>);</span><br><span class="line">test(<span class="keyword">null</span>);</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>以上例程会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(5) &#34;tpunt&#34;&#10;NULL&#10;Uncaught Error: Too few arguments to function test(), 0 passed in...</span><br></pre></td></tr></table></figure>
<h3 id="Void_函数">Void 函数</h3><p>在PHP 7 中引入的其他返回值类型的基础上，一个新的返回值类型void被引入。 返回值声明为 void 类型的方法要么干脆省去 return 语句，要么使用一个空的 return 语句。 对于 void 函数来说，null 不是一个合法的返回值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(&amp;<span class="variable">$left</span>, &amp;<span class="variable">$right</span>)</span> : <span class="title">void</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$left</span> === <span class="variable">$right</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$left</span>;</span><br><span class="line">    <span class="variable">$left</span> = <span class="variable">$right</span>;</span><br><span class="line">    <span class="variable">$right</span> = <span class="variable">$tmp</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line">var_dump(swap(<span class="variable">$a</span>, <span class="variable">$b</span>), <span class="variable">$a</span>, <span class="variable">$b</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null&#10;int(2)&#10;int(1)</span><br></pre></td></tr></table></figure></p>
<p>试图去获取一个 void 方法的返回值会得到 null ，并且不会产生任何警告。这么做的原因是不想影响更高层次的方法。</p>
<h3 id="Symmetric_array_destructuring">Symmetric array destructuring</h3><p>短数组语法（[],又称数组简写，起始于5.6）现在可以用于将数组的值赋给一些变量（包括在foreach中）。 这种方式使从数组中提取值变得更为容易。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$data</span> = [</span><br><span class="line">    [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'Tom'</span>],</span><br><span class="line">    [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'name'</span> =&gt; <span class="string">'Fred'</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ([<span class="string">'id'</span> =&gt; <span class="variable">$id</span>, <span class="string">'name'</span> =&gt; <span class="variable">$name</span>] = <span class="variable">$data</span>) &#123;</span><br><span class="line">    <span class="comment">// logic here with $id and $name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类常量可见性">类常量可见性</h3><p>现在起支持设置类常量的可见性。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstDemo</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> PUBLIC_CONST_A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> PUBLIC_CONST_B = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">const</span> PROTECTED_CONST = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> PRIVATE_CONST = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="iterable_伪类">iterable 伪类</h2><p>现在引入了一个新的被称为iterable的伪类 (与callable类似)。 这可以被用在参数或者返回值类型中，它代表接受数组或者实现了Traversable接口的对象。 至于子类，当用作参数时，子类可以收紧父类的iterable类型到array 或一个实现了Traversable的对象。对于返回值，子类可以拓宽父类的 array或对象返回值类型到iterable。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterator</span><span class="params">(iterable <span class="variable">$iter</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$iter</span> <span class="keyword">as</span> <span class="variable">$val</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多异常捕获处理">多异常捕获处理</h3><p>一个catch语句块现在可以通过管道字符(|)来实现多个异常的捕获。 这对于需要同时处理来自不同类的不同异常时很有用。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FirstException | SecondException <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="comment">// handle first and second exceptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="list()现在支持键名">list()现在支持键名</h3><p>现在<code>list()</code>支持在它内部指定键名。这意味着它可以将任意类型的数组 都赋值给一些变量（与短数组语法类似）。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$data</span> = [</span><br><span class="line">    [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'Tom'</span>],</span><br><span class="line">    [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'name'</span> =&gt; <span class="string">'Fred'</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">list</span>(<span class="string">'id'</span> =&gt; <span class="variable">$id</span>, <span class="string">'name'</span> =&gt; <span class="variable">$name</span>) = <span class="variable">$data</span>) &#123;</span><br><span class="line">    <span class="comment">// logic here with $id and $name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="支持为负的字符串偏移量">支持为负的字符串偏移量</h3><p>现在所有支持偏移量的字符串操作函数 都支持接受负数作为偏移量，包括通过[]或{}操作字符串下标。在这种情况下，一个负数的偏移量会被理解为一个从字符串结尾开始的偏移量。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">var_dump(<span class="string">"abcdef"</span>[-<span class="number">2</span>]);</span><br><span class="line">var_dump(strpos(<span class="string">"aabbcc"</span>, <span class="string">"b"</span>, -<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string (1) &#34;e&#34;&#10;int(3)&#10;Negative string and array offsets are now also supported in the simple variable parsing syntax inside of strings.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"The last character of '$string' is '$string[-1]'.\n"</span>;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The last character of &#39;bar&#39; is &#39;r&#39;.</span><br></pre></td></tr></table></figure></p>
<h3 id="ext/openssl_支持_AEAD">ext/openssl 支持 AEAD</h3><p>通过给<code>openssl_encrypt()</code>和<code>openssl_decrypt()</code> 添加额外参数，现在支持了AEAD (模式 GCM and CCM)。</p>
<h3 id="通过_Closure::fromCallable()_将callables转为闭包">通过 Closure::fromCallable() 将callables转为闭包</h3><p>Closure新增了一个静态方法，用于将callable快速地 转为一个Closure 对象。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exposeFunction</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Closure::fromCallable([<span class="variable">$this</span>, <span class="string">'privateFunction'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">(<span class="variable">$param</span>)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        var_dump(<span class="variable">$param</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$privFunc</span> = (<span class="keyword">new</span> Test)-&gt;exposeFunction();</span><br><span class="line"><span class="variable">$privFunc</span>(<span class="string">'some value'</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(10) &#34;some value&#34;</span><br></pre></td></tr></table></figure></p>
<h3 id="异步信号处理">异步信号处理</h3><p>一个新的名为 <code>pcntl_async_signals()</code> 的方法现在被引入， 用于启用无需 <code>ticks</code>（这会带来很多额外的开销）的异步信号处理。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">pcntl_async_signals(<span class="keyword">true</span>); <span class="comment">// turn on async signals</span></span><br><span class="line"></span><br><span class="line">pcntl_signal(SIGHUP,  <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$sig</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"SIGHUP\n"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">posix_kill(posix_getpid(), SIGHUP);</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：</p>
<p><code>SIGHUP</code></p>
<h3 id="HTTP/2_server_push_support_in_ext/curl">HTTP/2 server push support in ext/curl</h3><p>对服务器推送的支持现在已经被加入到 CURL 扩展中（ 需要版本 7.46 或更高）。这个可以通过 <code>curl_multi_setopt()</code> 函数与新的常量 <code>CURLMOPT_PUSHFUNCTION</code> 来进行调节。常量 <code>CURL_PUST_OK</code> 和 <code>CURL_PUSH_DENY</code>也已经被添加进来，以便服务器推送的回调函数来表明自己会同意或拒绝处理。</p>
<h2 id="7-0_released_on_2015">7.0 released on 2015</h2><h3 id="标量类型声明">标量类型声明</h3><p>标量类型声明 有两种模式: 强制 (默认) 和 严格模式。 现在可以使用下列类型参数（无论用强制模式还是严格模式）： 字符串(string), 整数 (int), 浮点数 (float), 以及布尔值 (bool)。它们扩充了PHP5中引入的其他类型：类名，接口，数组和 回调类型。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="comment">// Coercive mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumOfInts</span><span class="params">(int ...<span class="variable">$ints</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array_sum(<span class="variable">$ints</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(sumOfInts(<span class="number">2</span>, <span class="string">'3'</span>, <span class="number">4.1</span>));</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：</p>
<p><code>int(9)</code><br>要使用严格模式，一个 <code>declare</code> 声明指令必须放在文件的顶部。这意味着严格声明标量是基于文件可配的。 这个指令不仅影响参数的类型声明，也影响到函数的返回值声明（参见 返回值类型声明, 内置的PHP函数以及扩展中加载的PHP函数）。</p>
<h3 id="返回值类型声明">返回值类型声明</h3><p>PHP 7 增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraysSum</span><span class="params">(array ...<span class="variable">$arrays</span>)</span>: <span class="title">array</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array_map(<span class="function"><span class="keyword">function</span><span class="params">(array <span class="variable">$array</span>)</span>: <span class="title">int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array_sum(<span class="variable">$array</span>);</span><br><span class="line">    &#125;, <span class="variable">$arrays</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_r(arraysSum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]));</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array&#10;(&#10;    [0] =&#62; 6&#10;    [1] =&#62; 15&#10;    [2] =&#62; 24&#10;)</span><br></pre></td></tr></table></figure></p>
<p>完整的标量类型声明文档和示例可参见 返回值类型声明.</p>
<h3 id="null合并运算符">null合并运算符</h3><p>由于日常使用中存在大量同时使用三元表达式和 isset()的情况， 我们添加了null合并运算符 (??) 这个语法糖。如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="comment">// Fetches the value of $_GET['user'] and returns 'nobody'</span></span><br><span class="line"><span class="comment">// if it does not exist.</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">'user'</span>] ?? <span class="string">'nobody'</span>;</span><br><span class="line"><span class="comment">// This is equivalent to:</span></span><br><span class="line"><span class="variable">$username</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">'user'</span>]) ? <span class="variable">$_GET</span>[<span class="string">'user'</span>] : <span class="string">'nobody'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coalesces can be chained: this will return the first</span></span><br><span class="line"><span class="comment">// defined value out of $_GET['user'], $_POST['user'], and</span></span><br><span class="line"><span class="comment">// 'nobody'.</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">'user'</span>] ?? <span class="variable">$_POST</span>[<span class="string">'user'</span>] ?? <span class="string">'nobody'</span>;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="太空船操作符（组合比较符）">太空船操作符（组合比较符）</h3><p>太空船操作符用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1。 比较的原则是沿用 PHP 的常规比较规则进行的。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="comment">// 整数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span> &lt;=&gt; <span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1.5</span> &lt;=&gt; <span class="number">1.5</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1.5</span> &lt;=&gt; <span class="number">2.5</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2.5</span> &lt;=&gt; <span class="number">1.5</span>; <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"a"</span> &lt;=&gt; <span class="string">"a"</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"a"</span> &lt;=&gt; <span class="string">"b"</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"b"</span> &lt;=&gt; <span class="string">"a"</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="通过_define()_定义常量数组">通过 define() 定义常量数组</h3><p>Array 类型的常量现在可以通过 define() 来定义。在 PHP5.6 中仅能通过 const 定义。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">define(<span class="string">'ANIMALS'</span>, [</span><br><span class="line">    <span class="string">'dog'</span>,</span><br><span class="line">    <span class="string">'cat'</span>,</span><br><span class="line">    <span class="string">'bird'</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> ANIMALS[<span class="number">1</span>]; <span class="comment">// 输出 "cat"</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="匿名类">匿名类</h3><p>现在支持通过new class 来实例化一个匿名类，这可以用来替代一些“用后即焚”的完整类定义。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(string <span class="variable">$msg</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$logger</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLogger</span><span class="params">()</span>: <span class="title">Logger</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable">$this</span>-&gt;logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setLogger</span><span class="params">(Logger <span class="variable">$logger</span>)</span> </span>&#123;</span><br><span class="line">         <span class="variable">$this</span>-&gt;logger = <span class="variable">$logger</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$app</span> = <span class="keyword">new</span> Application;</span><br><span class="line"><span class="variable">$app</span>-&gt;setLogger(<span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="keyword">implements</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(string <span class="variable">$msg</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$msg</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var_dump(<span class="variable">$app</span>-&gt;getLogger());</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上例代码会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object(class@anonymous)#2 (0) &#123;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>详细文档可以参考 匿名类.</p>
<h3 id="Unicode_codepoint_转译语法">Unicode codepoint 转译语法</h3><p>这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。 可以接受任何有效的 codepoint，并且开头的 0 是可以省略的。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"\u&#123;aa&#125;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\u&#123;0000aa&#125;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\u&#123;9999&#125;"</span>;</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#170;&#10;&#170; (same as before but with optional leading 0&#39;s)&#10;&#39321;</span><br></pre></td></tr></table></figure></p>
<h3 id="Closure::call()">Closure::call()</h3><p>Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;<span class="keyword">private</span> <span class="variable">$x</span> = <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PHP 7 之前版本的代码</span></span><br><span class="line"><span class="variable">$getXCB</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="variable">$this</span>-&gt;x;&#125;;</span><br><span class="line"><span class="variable">$getX</span> = <span class="variable">$getXCB</span>-&gt;bindTo(<span class="keyword">new</span> A, <span class="string">'A'</span>); <span class="comment">// 中间层闭包</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$getX</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// PHP 7+ 及更高版本的代码</span></span><br><span class="line"><span class="variable">$getX</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="variable">$this</span>-&gt;x;&#125;;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$getX</span>-&gt;call(<span class="keyword">new</span> A);</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#10;1</span><br></pre></td></tr></table></figure></p>
<h3 id="为unserialize()提供过滤">为unserialize()提供过滤</h3><p>这个特性旨在提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有的对象都转换为 __PHP_Incomplete_Class 对象</span></span><br><span class="line"><span class="variable">$data</span> = unserialize(<span class="variable">$foo</span>, [<span class="string">"allowed_classes"</span> =&gt; <span class="keyword">false</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将除 MyClass 和 MyClass2 之外的所有对象都转换为 __PHP_Incomplete_Class 对象</span></span><br><span class="line"><span class="variable">$data</span> = unserialize(<span class="variable">$foo</span>, [<span class="string">"allowed_classes"</span> =&gt; [<span class="string">"MyClass"</span>, <span class="string">"MyClass2"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下所有的类都是可接受的，等同于省略第二个参数</span></span><br><span class="line"><span class="variable">$data</span> = unserialize(<span class="variable">$foo</span>, [<span class="string">"allowed_classes"</span> =&gt; <span class="keyword">true</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="IntlChar">IntlChar</h3><p>新增加的 IntlChar 类旨在暴露出更多的 ICU 功能。这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">'%x'</span>, IntlChar::CODEPOINT_MAX);</span><br><span class="line"><span class="keyword">echo</span> IntlChar::charName(<span class="string">'@'</span>);</span><br><span class="line">var_dump(IntlChar::ispunct(<span class="string">'!'</span>));</span><br></pre></td></tr></table></figure>
<p>以上例程会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10ffff&#10;COMMERCIAL AT&#10;bool(true)</span><br></pre></td></tr></table></figure>
<p>若要使用此类，请先安装Intl扩展</p>
<h3 id="预期">预期</h3><p>预期是向后兼用并增强之前的 <code>assert()</code> 的方法。 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。</p>
<p>老版本的API出于兼容目的将继续被维护，assert()现在是一个语言结构，它允许第一个参数是一个表达式，而不仅仅是一个待计算的 string或一个待测试的boolean。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">'assert.exception'</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomError</span> <span class="keyword">extends</span> <span class="title">AssertionError</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">assert(<span class="keyword">false</span>, <span class="keyword">new</span> CustomError(<span class="string">'Some error message'</span>));</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fatal error: Uncaught CustomError: Some error message</span><br></pre></td></tr></table></figure></p>
<p>关于这个特性的完整说明，包括如何在开发和生产环境中配置它，可以在assert()的 expectations section章节找到。</p>
<h3 id="Group_use_declarations">Group use declarations</h3><p>从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PHP 7 之前的代码</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">ClassA</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">ClassB</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">ClassC</span> <span class="title">as</span> <span class="title">C</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">function</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">fn_a</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">function</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">fn_b</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">function</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">fn_c</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">const</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">ConstA</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">const</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">ConstB</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">const</span> <span class="title">some</span>\<span class="title">namespace</span>\<span class="title">ConstC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PHP 7+ 及更高版本的代码</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">some</span>\<span class="title">namespace</span>\&#123;<span class="title">ClassA</span>, <span class="title">ClassB</span>, <span class="title">ClassC</span> <span class="title">as</span> <span class="title">C</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> <span class="title">function</span> <span class="title">some</span>\<span class="title">namespace</span>\&#123;<span class="title">fn_a</span>, <span class="title">fn_b</span>, <span class="title">fn_c</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> <span class="title">const</span> <span class="title">some</span>\<span class="title">namespace</span>\&#123;<span class="title">ConstA</span>, <span class="title">ConstB</span>, <span class="title">ConstC</span>&#125;;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="生成器可以返回表达式">生成器可以返回表达式</h3><p>此特性基于 PHP 5.5 版本中引入的生成器特性构建的。 它允许在生成器函数中通过使用 return 语法来返回一个表达式 （但是不允许返回引用值）， 可以通过调用 Generator::getReturn() 方法来获取生成器的返回值， 但是这个方法只能在生成器完成产生工作以后调用一次。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$gen</span> = (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$gen</span> <span class="keyword">as</span> <span class="variable">$val</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$val</span>, PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$gen</span>-&gt;getReturn(), PHP_EOL;</span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#10;2&#10;3</span><br></pre></td></tr></table></figure></p>
<p>在生成器中能够返回最终的值是一个非常便利的特性， 因为它使得调用生成器的客户端代码可以直接得到生成器（或者其他协同计算）的返回值， 相对于之前版本中客户端代码必须先检查生成器是否产生了最终的值然后再进行响应处理 来得方便多了。</p>
<h3 id="Generator_delegation">Generator delegation</h3><p>现在，只需在最外层生成其中使用 yield from， 就可以把一个生成器自动委派给其他的生成器， Traversable 对象或者 array。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> from gen2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen2</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (gen() <span class="keyword">as</span> <span class="variable">$val</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$val</span>, PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#10;2&#10;3&#10;4</span><br></pre></td></tr></table></figure></p>
<h3 id="整数除法函数_intdiv()">整数除法函数 intdiv()</h3><p>新加的函数 intdiv() 用来进行 整数的除法运算。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">var_dump(intdiv(<span class="number">10</span>, <span class="number">3</span>));</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int(3)</span><br></pre></td></tr></table></figure></p>
<h3 id="会话选项">会话选项</h3><p>session_start() 可以接受一个 array 作为参数， 用来覆盖 php.ini 文件中设置的 会话配置选项。</p>
<p>在调用 session_start() 的时候， 传入的选项参数中也支持 session.lazy_write 行为， 默认情况下这个配置项是打开的。它的作用是控制 PHP 只有在会话中的数据发生变化的时候才 写入会话存储文件，如果会话中的数据没有发生改变，那么 PHP 会在读取完会话数据之后， 立即关闭会话存储文件，不做任何修改，可以通过设置 read_and_close 来实现。</p>
<p>例如，下列代码设置 session.cache_limiter 为 private，并且在读取完毕会话数据之后马上关闭会话存储文件。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">session_start([</span><br><span class="line">    <span class="string">'cache_limiter'</span> =&gt; <span class="string">'private'</span>,</span><br><span class="line">    <span class="string">'read_and_close'</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="preg_replace_callback_array()">preg_replace_callback_array()</h3><p>在 PHP 7 之前，当使用 <code>preg_replace_callback()</code> 函数的时候， 由于针对每个正则表达式都要执行回调函数，可能导致过多的分支代码。 而使用新加的 <code>preg_replace_callback_array()</code>函数，可以使得代码更加简洁。</p>
<p>现在，可以使用一个关联数组来对每个正则表达式注册回调函数， 正则表达式本身作为关联数组的键， 而对应的回调函数就是关联数组的值。</p>
<h3 id="CSPRNG_Functions">CSPRNG Functions</h3><p>新加入两个跨平台的函数： random_bytes() 和 random_int() 用来产生高安全级别的随机字符串和随机整数。</p>
<p>可以使用 list() 函数来展开实现了 ArrayAccess 接口的对象 ¶</p>
<p>在之前版本中，list() 函数不能保证 正确的展开实现了 ArrayAccess 接口的对象， 现在这个问题已经被修复。</p>
<h3 id="其他特性">其他特性</h3><p>允许在克隆表达式上访问对象成员，例如： (clone $foo)-&gt;bar()。</p>
<h2 id="参考">参考</h2><p>-<a href="http://talks.php.net/show/php7-brightonphp16/13" target="_blank" rel="external">derick’s Talk in php.net</a></p>


<!--<a href="http://yoursite.com/2017-7-18-new-features-from-5-6-7-1-of-php.html#disqus_thread" class="article-comment-link">Comments</a>-->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'mickeyouyou'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div>







</body>
</html>