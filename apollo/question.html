<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>Apollo代码阅读笔记</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js" type="text/javascript"></script>
        <script>
            if(!isMobile()) {
                loadjscssfile('../css/desktop.css', 'css');
                }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>


<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 class="title">Apollo代码阅读笔记</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年8月14日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Words"><span class="toc-text">Words</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protobuf"><span class="toc-text">Protobuf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过ROS服务的驾驶控制"><span class="toc-text">通过ROS服务的驾驶控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RPC服务定义"><span class="toc-text">RPC服务定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gRPCServer"><span class="toc-text">gRPCServer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确保进入驾驶模式"><span class="toc-text">确保进入驾驶模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SendPadMessage方法"><span class="toc-text">SendPadMessage方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AdapterManager"><span class="toc-text">AdapterManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APOLLO-MAIN-MACRO"><span class="toc-text">APOLLO_MAIN MACRO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#决策模块"><span class="toc-text">决策模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#控制模块"><span class="toc-text">控制模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#初始化方法"><span class="toc-text">初始化方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#启动方法"><span class="toc-text">启动方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#关闭方法"><span class="toc-text">关闭方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#驾驶模块"><span class="toc-text">驾驶模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
<h3 id="Words"><a href="#Words" class="headerlink" title="Words"></a>Words</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHASSIS &#24213;&#30424; &#10;CANBUS CAN&#24635;&#32447;&#10;CHASSIS DETAIL &#24213;&#30424;&#32454;&#33410;&#10;IMU Inertial Measurement Unit &#24815;&#24615;&#27979;&#37327;&#35013;&#32622;&#10;PLANNING TRAJECTORY &#36712;&#36857;&#35268;&#21010;&#10;PERCEPTION OBSTACLES &#30693;&#35273;&#38556;&#30861;&#10;GNSS &#20840;&#29699;&#23548;&#33322;&#21355;&#26143;&#31995;&#32479;&#10;chassis vehicle status &#24213;&#30424;&#36710;&#36742;&#29366;&#24577;&#65292;&#20363;&#22914;&#36895;&#24230;&#65292;&#21152;&#36895;&#24230;</span><br></pre></td></tr></table></figure>
<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Apollo中对于消息序列化均是基于Protobuf实现，所以认真了解一遍protobuf很有必要。</p>
<p>控制模块其中一个proto定义：<br><figure class="highlight protobuf"><figcaption><span>modules/control/proto/pad_msg.proto 驾驶操作与Pad信息的proto定义</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DrivingAction</span> </span>&#123;</span><br><span class="line"><span class="constant">  STOP</span> = <span class="number">0</span>;</span><br><span class="line"><span class="constant">  START</span> = <span class="number">1</span>;</span><br><span class="line"><span class="constant">  RESET</span> = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PadMessage</span> </span>&#123;</span><br><span class="line">  <span class="comment">// control mode, set mode according to low level defination</span></span><br><span class="line">  <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send driving mode to drive</span></span><br><span class="line">  <span class="keyword">optional</span> apollo.canbus.Chassis.DrivingMode driving_mode = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// action in the driving_mode</span></span><br><span class="line">  <span class="keyword">optional</span> DrivingAction action = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题：DrivingAction枚举值有0~2，PadMessage中的可选值为3？</p>
<p>Protobuf的实现有关,每个字段而言都有一个修饰符（required/repeated/optional）、字段类型（bool/string/bytes/int32等）和字段标签(Tag)组成。<br>三个修饰符从词义上可以很清楚的弄明白。</p>
<ul>
<li>对于required的字段而言，初值是必须要提供的，否则字段的便是未初始化的。在Debug模式的buffer库下编译的话，序列化话的时候可能会失败，而且在反序列化的时候对于该字段的解析会总是失败的。所以，对于修饰符为required的字段，请在序列化的时候务必给予初始化。</li>
<li>对于optional的字段而言，如果未进行初始化，那么一个默认值将赋予该字段，当然也可以指定默认值，如上述proto定义中的PhoneType字段类型。</li>
<li>对于repeated的字段而言，该字段可以重复多个，google提供的这个addressbook例子便有个很好的该修饰符的应用场景，即每个人可能有多个电话号码。在高级语言里面，我们可以通过数组来实现，而在proto定义文件中可以使用repeated来修饰，从而达到相同目的。当然，出现0次也是包含在内的。      </li>
</ul>
<p>其中字段标签标示了字段在二进制流中存放的位置，这个是必须的，而且序列化与反序列化的时候相同的字段的Tag值必须对应，否则反序列化会出现意想不到的问题。</p>
<p>通过查看生成的头文件，可以发现针对每个字段都会大致生成如下几种函数，以number字段为例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// required string number = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">has_number</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear_number</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>&amp; number() <span class="keyword">const</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_number</span><span class="params">(<span class="keyword">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>&amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_number</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* value)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>* mutable_number();</span><br></pre></td></tr></table></figure></p>
<p>可以看出，对于每个字段会生成一个has函数(has_number)、clear清除函数(clear_number)、set函数(set_number)、get函数(number和mutable_number)。这儿解释下get函数中的两个函数的区别，对于原型为const std::string &amp;number() const的get函数而言，返回的是常量字段，不能对其值进行修改。但是在有一些情况下，对字段进行修改是必要的，所以提供了一个mutable版的get函数，通过获取字段变量的指针，从而达到改变其值的目的。</p>
<h3 id="通过ROS服务的驾驶控制"><a href="#通过ROS服务的驾驶控制" class="headerlink" title="通过ROS服务的驾驶控制"></a>通过ROS服务的驾驶控制</h3><p>这个问题，总的描述了从接口入手了解下从指令发送到实际进入自动驾驶状态的过程分析。</p>
<p>该部分从hmi一下的两个接口入手，了解下指令发送到自动驾驶接管汽车的过程:</p>
<ul>
<li>ros_service_api/start_auto_driving 启动自动驾驶</li>
<li>ros_service_api/reset 停止自动驾驶模式，重置为手动驾驶</li>
</ul>
<p>启动自动驾驶代码主要逻辑：<br>通过发送gRPC请求运行ROS命令，返回操作的HTTP状态码</p>
<p>渠道 gRPC用来初始化的channel<br>开始自动驾驶的指令在hmi端上发出，将通过gRPC服务的方式发送给Ros_node_service，由其运行的GRPCServer，负责接受响应的request，并作出操作的结果响应。</p>
<p>这中间还涉及一下几方面的内容：</p>
<h4 id="RPC服务定义"><a href="#RPC服务定义" class="headerlink" title="RPC服务定义"></a>RPC服务定义</h4><figure class="highlight protobuf"><figcaption><span>modules/hmi/proto/ros_node.proto ROS节点服务</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> apollo.hmi;</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HMIRosNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ChangeDrivingMode(ChangeDrivingModeRequest) <span class="keyword">returns</span> (ChangeDrivingModeResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">message ChangeDrivingModeRequest &#123;</span><br><span class="line">  enum Action &#123;</span><br><span class="line">    RESET_TO_MANUAL = 1</span>;</span><br><span class="line"><span class="constant">    START_TO_AUTO</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">optional</span> Action action = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ChangeDrivingModeResponse</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line"><span class="constant">    UNKNOWN</span> = <span class="number">1</span>;</span><br><span class="line"><span class="constant">    SUCCESS</span> = <span class="number">2</span>;</span><br><span class="line"><span class="constant">    FAIL</span> = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">optional</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从HMI到gRPCServer的配置，将会是一个有Protobuf配置的IDL，其中的HMIRosNode通过<br><code>grpc.insecure_channel(gflags.FLAGS.hmi_ros_node_service)</code>初始化调用</p>
<h4 id="gRPCServer"><a href="#gRPCServer" class="headerlink" title="gRPCServer"></a>gRPCServer</h4><figure class="highlight cpp"><figcaption><span>modules/hmi/ros_node/ros_code_service.cc gRPCServer的初始化</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunGRPCServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Start GRPC service.</span></span><br><span class="line">  HMIRosNodeImpl service;</span><br><span class="line">  grpc::ServerBuilder builder;</span><br><span class="line">  builder.AddListeningPort(FLAGS_hmi_ros_node_service_address,</span><br><span class="line">                           grpc::InsecureServerCredentials());</span><br><span class="line">  builder.RegisterService(&amp;service);</span><br><span class="line">  <span class="built_in">std</span>::unique_ptr&lt;grpc::Server&gt; server(builder.BuildAndStart());</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Server listening on "</span> &lt;&lt; FLAGS_hmi_ros_node_service_address;</span><br><span class="line">  server-&gt;Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="确保进入驾驶模式"><a href="#确保进入驾驶模式" class="headerlink" title="确保进入驾驶模式"></a>确保进入驾驶模式</h4><p>阶段性重试、指定的sleep直到进入驾驶模式：<br><figure class="highlight cpp"><figcaption><span>modules/hmi/ros_node/ros_code_service.cc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxTries = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> kTryInterval = <span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">auto</span> result = ChangeDrivingModeResponse::FAIL;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kMaxTries; ++i) &#123;</span><br><span class="line">  <span class="comment">// Send driving action periodically until entering target driving mode.</span></span><br><span class="line">  SendPadMessage(<span class="keyword">driving_action_t</span>o_send);</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">this_t</span>hread::sleep_for(kTryInterval);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保护current_driving_mode_</span></span><br><span class="line">  <span class="comment">// current_driving_mode_mutex is automatically released when lock</span></span><br><span class="line">  <span class="comment">// goes out of scope</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(current_driving_mode_mutex_);</span><br><span class="line">  <span class="keyword">if</span> (current_driving_mode_ == <span class="keyword">driving_mode_t</span>o_wait) &#123;</span><br><span class="line">    result = ChangeDrivingModeResponse::SUCCESS;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="SendPadMessage方法"><a href="#SendPadMessage方法" class="headerlink" title="SendPadMessage方法"></a>SendPadMessage方法</h4><p>该方法是使汽车进入自动驾驶的关键方法，为了确保该请求的操作成功性，使用指定重试5次的做法。所以这个方法比较关键。<br>Protobuf生成的PadMessage对象，并调用生成的set_action方法将action属性赋值，DebugString方法打印地址信息，butable_header获取header字段的值，进行适配器管理器的两步操作：<br><figure class="highlight cpp"><figcaption><span>modules/hmi/ros_node/ros_code_service.cc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendPadMessage</span><span class="params">(DrivingAction action)</span> </span>&#123;</span><br><span class="line">  control::PadMessage pb;</span><br><span class="line">  pb.set_action(action);</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Sending PadMessage:\n"</span> &lt;&lt; pb.DebugString();</span><br><span class="line">  AdapterManager::FillPadHeader(kHMIRosNodeName, pb.mutable_header());</span><br><span class="line">  AdapterManager::PublishPad(pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下对应的Protobuf：<br><figure class="highlight protobuf"><figcaption><span>modules/control/proto/pad_msg.proto</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 驾驶模式中的动作</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DrivingAction</span> </span>&#123;</span><br><span class="line"><span class="constant">  STOP</span> = <span class="number">0</span>; <span class="comment">// 默认，手动驾驶状态</span></span><br><span class="line"><span class="constant">  START</span> = <span class="number">1</span>;<span class="comment">// 开始自动驾驶</span></span><br><span class="line"><span class="constant">  RESET</span> = <span class="number">2</span>;<span class="comment">// 重置为手动驾驶</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PadMessage</span> </span>&#123;</span><br><span class="line">  <span class="comment">// control mode, set mode according to low level defination 控制模式，根据低级别定义设定</span></span><br><span class="line">  <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send driving mode to drive 发送驾驶模式开始驾驶</span></span><br><span class="line">  <span class="keyword">optional</span> apollo.canbus.Chassis.DrivingMode driving_mode = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// action in the driving_mode 驾驶模式中的动作 </span></span><br><span class="line">  <span class="keyword">optional</span> DrivingAction action = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>驾驶模式的定义：<br><figure class="highlight protobuf"><figcaption><span>modules/canbus/proto/chassis.proto</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Chassis</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">DrivingMode</span> </span>&#123;</span><br><span class="line"><span class="constant">    COMPLETE_MANUAL</span> = <span class="number">0</span>;  <span class="comment">// human drive</span></span><br><span class="line"><span class="constant">    COMPLETE_AUTO_DRIVE</span> = <span class="number">1</span>;</span><br><span class="line"><span class="constant">    AUTO_STEER_ONLY</span> = <span class="number">2</span>;  <span class="comment">// only steer 自动引导</span></span><br><span class="line"><span class="constant">    AUTO_SPEED_ONLY</span> = <span class="number">3</span>;  <span class="comment">// include throttle and brake 包括油门和制动器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// security mode when manual intervention happens, only response status</span></span><br><span class="line"><span class="constant">    EMERGENCY_MODE</span> = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></p>
<p>但是还是没有找到对应的PublishPad方法，搜索代码库发现有一处AdapterManager::PublishPad(pb)的调用：<br><figure class="highlight cpp"><figcaption><span>modules/control/tools/terminal.cc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> cmd_type)</span> </span>&#123;</span><br><span class="line">  ::apollo::control::PadMessage pb;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">cmd_t</span>ype == RESET_COMMAND) &#123;</span><br><span class="line">    pb.set_action(apollo::control::DrivingAction::RESET);</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"sending reset action command."</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">cmd_t</span>ype == AUTO_DRIVE_COMMAND) &#123;</span><br><span class="line">    pb.set_action(apollo::control::DrivingAction::START);</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"sending start action command."</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AdapterManager::FillPadHeader(<span class="string">"terminal"</span>, pb.mutable_header());</span><br><span class="line">  AdapterManager::PublishPad(pb);</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"send pad_message OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是一个命令行的工具。没有其他地方的调用。</p>
<p>还是未果。</p>
<h4 id="AdapterManager"><a href="#AdapterManager" class="headerlink" title="AdapterManager"></a>AdapterManager</h4><p>适配器管理器，可以理解为对车载设备的初始化、功能开启/关闭,提供统一的管理。<br>FillPadHeader =&gt; 为Pad填充报头<br>PublishPad    =&gt; 发布Pad</p>
<p>其实是通过REGISTER_ADAPTER定义的宏，当增加一个新的IO时，通过该宏准备所有必要的适配器方法，举个例子，当你想在你的模块监听car_status消息时，你可以REGISTER_ADAPTER(CarStatus)，再写一个名为CarStatusAdapter的类，在AdapterManager中调用<code>EnableCarStatus(&#39;car_status_topic&#39;, true, &#39;callback&#39;(如果存在回调方法))</code>即可。<br><figure class="highlight cpp"><figcaption><span>adapter_manager.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Publish<span class="preprocessor">##name(const name##Adapter::DataType &amp;data) &#123;             \</span><br><span class="line">  instance()-&gt;InternalPublish##name(data);                                   \</span><br><span class="line">&#125;                                                                            \</span><br><span class="line">static void Fill##name##Header(const std::string &amp;module_name,               \</span><br><span class="line">                               apollo::common::Header *header) &#123;             \</span><br><span class="line">  instance()-&gt;name##_-&gt;FillHeader(module_name, header);                      \</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>ROS中AdapterManager即调度中心的角色，完成节点的发布与订阅关系。</p>
<p>以下列出来现有模块对应适配器的位置：<br><figure class="highlight cpp"><figcaption><span>message_adapter.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ChassisAdapter = Adapter&lt;::apollo::canbus::Chassis&gt;;</span><br><span class="line"><span class="keyword">using</span> ChassisDetailAdapter = Adapter&lt;::apollo::canbus::ChassisDetail&gt;;</span><br><span class="line"><span class="keyword">using</span> ControlCommandAdapter = Adapter&lt;::apollo::control::ControlCommand&gt;;</span><br><span class="line"><span class="keyword">using</span> DecisionAdapter = Adapter&lt;::apollo::decision::DecisionResult&gt;;</span><br><span class="line"><span class="keyword">using</span> GpsAdapter = Adapter&lt;apollo::localization::Gps&gt;;</span><br><span class="line"><span class="keyword">using</span> ImuAdapter = Adapter&lt;::apollo::localization::Imu&gt;;</span><br><span class="line"><span class="keyword">using</span> CameraAdapter = Adapter&lt;::apollo::localization::Camera&gt;;</span><br><span class="line"><span class="keyword">using</span> LocalizationAdapter = Adapter&lt;apollo::localization::LocalizationEstimate&gt;;</span><br><span class="line"><span class="keyword">using</span> MonitorAdapter = Adapter&lt;apollo::common::monitor::MonitorMessage&gt;;</span><br><span class="line"><span class="keyword">using</span> PadAdapter = Adapter&lt;::apollo::control::PadMessage&gt;;</span><br><span class="line"><span class="keyword">using</span> PerceptionObstaclesAdapter =</span><br><span class="line">    Adapter&lt;::apollo::perception::PerceptionObstacles&gt;;</span><br><span class="line"><span class="keyword">using</span> PlanningTrajectoryAdapter = Adapter&lt;::apollo::planning::ADCTrajectory&gt;;</span><br><span class="line"><span class="keyword">using</span> PredictionAdapter = Adapter&lt;::apollo::prediction::PredictionObstacles&gt;;</span><br><span class="line"><span class="keyword">using</span> TrafficLightDetectionAdapter =</span><br><span class="line">    Adapter&lt;::apollo::perception::TrafficLightDetection&gt;;</span><br></pre></td></tr></table></figure></p>
<p>适配器的部分有些拓展了，但实现自动驾驶指令的过程总结为ros通过接口调用gRPC，再做适配后返回操作结果。</p>
<h3 id="APOLLO-MAIN-MACRO"><a href="#APOLLO-MAIN-MACRO" class="headerlink" title="APOLLO_MAIN MACRO"></a>APOLLO_MAIN MACRO</h3><p><code>APOLLO_MAIN</code>宏帮助开发者在一行命令中启动glog、gflag、ROS。</p>
<figure class="highlight cpp"><figcaption><span>modules/common/appllo_app.h APOLLO_MAIN宏定义</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> APOLLO_MAIN(APP)                                       \</span><br><span class="line">  int main(int argc, char **argv) &#123;                            \</span><br><span class="line">    google::InitGoogleLogging(argv[0]);                        \</span><br><span class="line">    google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);         \</span><br><span class="line">    signal(SIGINT, apollo::common::apollo_app_sigint_handler); \</span><br><span class="line">    APP apollo_app_;                                           \</span><br><span class="line">    ros::init(argc, argv, apollo_app_.Name());                 \</span><br><span class="line">    apollo_app_.Spin();                                        \</span><br><span class="line">    return 0;                                                  \</span><br><span class="line">  &#125;</span></span><br></pre></td></tr></table></figure>
<p>一个定义main函数：</p>
<ul>
<li>初始化glag、glog组件；</li>
<li>注册信号变量，确保进程接收到SIGINT信号变量，或者ROS时，停止Apollo应用；</li>
<li>实例化对应模块，注册ROS等；</li>
</ul>
<p>调用，如在决策模块中调用该宏完成初始化：<br><figure class="highlight cpp"><figcaption><span>modules/decision/main.cc APOLLO_MAIN宏在决策模块的初始化</span></figcaption><table><tr><td class="code"><pre><span class="line">APOLLO_MAIN(apollo::decision::Decision);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><figcaption><span>modules/control/main.cc APOLLO_MAIN宏在控制模块的初始化</span></figcaption><table><tr><td class="code"><pre><span class="line">APOLLO_MAIN(apollo::control::Control);</span><br></pre></td></tr></table></figure>
<h4 id="决策模块"><a href="#决策模块" class="headerlink" title="决策模块"></a>决策模块</h4><p>以决策模块为例，将其中的APOLLO_MAIN宏替换为：<br><figure class="highlight cpp"><figcaption><span>modules/decision/main.cc APOLLO_MAIN宏在决策模块的替换结果</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">    google::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="keyword">true</span>);</span><br><span class="line">    signal(SIGINT, apollo::common::apollo_app_sigint_handler);</span><br><span class="line">    apollo::decision::Decision apollo_app_;</span><br><span class="line">    ros::init(argc, argv, apollo_app_.Name());</span><br><span class="line">    apollo_app_.Spin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成的事情还是一样的，只不过这样更清晰：</p>
<ul>
<li>初始化glag、glog组件；</li>
<li>注册信号变量，确保进程接收到SIGINT信号变量，或者ROS时，停止Apollo应用；</li>
<li>实例化决策模块，初始化ROS决策节点；</li>
<li>调用基础模块类的回旋方法，这是Apollo应用的入口，完成初始化、启动、关闭（当ros要求关闭时）应用</li>
</ul>
<blockquote>
<p>重要的一点：所有模块的类，均基于Apollo_App基础模块类</p>
</blockquote>
<p>着重看下回旋方法：<br><figure class="highlight cpp"><figcaption><span>modules/common/apollo_app.cc 基类回旋方法</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ApolloApp::Spin() &#123;</span><br><span class="line">  ros::<span class="function">AsyncSpinner <span class="title">spinner</span><span class="params">(1)</span></span>; <span class="comment">// 初始化1个线程</span></span><br><span class="line">  <span class="keyword">auto</span> status = Init(); </span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    AERROR &lt;&lt; Name() &lt;&lt; <span class="string">" Init failed: "</span> &lt;&lt; status;</span><br><span class="line">    ReportModuleStatus(apollo::hmi::ModuleStatus::UNINITIALIZED);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReportModuleStatus(apollo::hmi::ModuleStatus::INITIALIZED);</span><br><span class="line">  status = Start();</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    AERROR &lt;&lt; Name() &lt;&lt; <span class="string">" Start failed: "</span> &lt;&lt; status;</span><br><span class="line">    ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReportModuleStatus(apollo::hmi::ModuleStatus::STARTED);</span><br><span class="line">  spinner.start();</span><br><span class="line">  ros::waitForShutdown();</span><br><span class="line">  Stop();</span><br><span class="line">  ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);</span><br><span class="line">  AINFO &lt;&lt; Name() &lt;&lt; <span class="string">" exited."</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>ros::AsyncSpinner spinner(1);</code>是来自Ros中的线程管理，用以初始化1个线程，更多的解释参考：<br>一个更有用的线程spinner是AsyncSpinner，与阻塞的 <code>spin()</code>不同, 它有<code>start()</code>和<code>stop()</code>调用, 并且在销毁时自动停止</p>
<figure class="highlight cpp"><figcaption><span>ros::AsyncSpinner</span></figcaption><table><tr><td class="code"><pre><span class="line">ros::<span class="function">AsyncSpinner <span class="title">spinner</span><span class="params">(4)</span></span>; <span class="comment">// Use 4 threads</span></span><br><span class="line">spinner.start();</span><br><span class="line">ros::waitForShutdown();</span><br><span class="line">``` </span><br><span class="line">```cpp </span><br><span class="line"><span class="keyword">auto</span> status = Init();</span><br></pre></td></tr></table></figure>
<p>基类中没有实现Init()方法，所以此处的status结果其实是决策模块中的Init()方法运行的结果。</p>
<p>决策模块的Init()方法:直接放回了成功码<br><figure class="highlight cpp"><figcaption><span>modules/decision/decision.cc 决策模块的Init()方法</span></figcaption><table><tr><td class="code"><pre><span class="line">common::Status Decision::Init() &#123; <span class="keyword">return</span> common::Status::OK(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>决策模块的Start()方法：启动Ros 计时器，并返回启动成功错误码：<br><figure class="highlight cpp"><figcaption><span>modules/decision/decision.cc 决策模块的Start()方法</span></figcaption><table><tr><td class="code"><pre><span class="line">common::Status Decision::Start() &#123;</span><br><span class="line">  AdapterManager::Init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// start ROS timer, one-shot = false, auto-start = true</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> duration = <span class="number">1.0</span> / FLAGS_decision_publish_freq;</span><br><span class="line">  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),</span><br><span class="line">                                       &amp;Decision::OnTimer, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> common::Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下模块基类中Spin()方法的主要逻辑：是对决策模块的执行：</p>
<ul>
<li>初始化决策模块，并向HMI上报状态；</li>
<li>启动决策模块，并向HMI上报状态；</li>
<li>等待关闭，ros::waitForShutdown()；</li>
<li>关闭决策模块；</li>
</ul>
<p>由此，其他的模块，依照该逻辑在进程中，完成模块的初始化，启动，等待与ROS的交互。</p>
<p>依照之前APOLLO_MAIN宏，依次观察实例化的模块中实现的Init()、Start()、Stop()，以增加对该模块的充分了解。</p>
<h4 id="控制模块"><a href="#控制模块" class="headerlink" title="控制模块"></a>控制模块</h4><blockquote>
<p>control module, it processes localization, chasiss, and<br>pad data to compute throttle, brake and steer values.</p>
</blockquote>
<p>控制模块的主要功能，处理定位、车辆信息、平板数据，以计算节气门，制动和转向值。</p>
<h5 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a><strong>初始化方法</strong></h5><ul>
<li>加载，初始化默认控制配置文件</li>
<li>初始化控制器 :<figure class="highlight cpp"><figcaption><span>modules/control/control.cc 控制器的初始化</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// set controller</span></span><br><span class="line"><span class="keyword">if</span> (!controller_agent_.Init(&amp;control_conf_).ok()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg = <span class="string">"Control init controller failed! Stopping..."</span>;</span><br><span class="line">  buffer.ERROR(error_msg);</span><br><span class="line">  <span class="keyword">return</span> Status(ErrorCode::CONTROL_INIT_ERROR, error_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中提到Control模块的两个属性：</p>
<ul>
<li><code>controller_agent_</code> 实例化自 ControllerAgent 管理所有在控制模块配置文件中定义的控制器</li>
<li><code>control_conf_</code> 实例化自ControlConf 控制器配置对象</li>
</ul>
<p>下面看下ControllerAgent::Init()方法的主要内容：</p>
<ul>
<li><p>利用公共模块提供的工厂模型方法，注册经度、维度控制器：</p>
<figure class="highlight cpp"><figcaption><span>mudules/control/controler/controller_agent.cc </span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ControllerAgent::RegisterControllers() &#123;</span><br><span class="line">  controller_factory_.Register(</span><br><span class="line">      ControlConf::LAT_CONTROLLER,</span><br><span class="line">      []() -&gt; Controller * &#123; <span class="keyword">return</span> <span class="keyword">new</span> LatController(); &#125;);</span><br><span class="line">  controller_factory_.Register(</span><br><span class="line">      ControlConf::LON_CONTROLLER,</span><br><span class="line">      []() -&gt; Controller * &#123; <span class="keyword">return</span> <span class="keyword">new</span> LonController(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载默认控制配置文件中激活的控制器：LAT_CONTROLLER、LON_CONTROLLER，并创建单例的控制对象。</p>
</li>
</ul>
<p>mudules/control/conf/lincoln.pb.txt 默认控制配置文件一部分:</p>
<pre><code class="txt">control_period: 0.01
trajectory_period: 0.1
chassis_period: 0.01
localization_period: 0.01
max_status_interval_sec: 0.1
max_planning_interval_sec: 0.2
max_planning_delay_threshold: 4.0
action: STOP
soft_estop_brake: 50.0
active_controllers: LAT_CONTROLLER
active_controllers: LON_CONTROLLER
max_steering_percentage_allowed: 100
lat_controller_conf{
  ......
}
lon_controller_conf{
  ......
}
</code></pre>
<ul>
<li>遍历基于控制器类的经度、维度控制器，检查是否已被初始化。</li>
</ul>
<p>总结一下，控制器代理方法的的初始化内容主要是根据配置文件，初始化其中的两个控制器：经度、维度控制器。</p>
<p>之后是一些跟控制模块相关的检查：</p>
<ul>
<li>检查定位模块是否已经初始化</li>
<li>检查底盘信息是否被初始化</li>
<li>检查路径规划模块是否已初始化</li>
<li>检查平板是否已初始化</li>
<li>检查控制命令发布者是否已初始化</li>
</ul>
<p>最后返回初始化成功的状态码</p>
<h5 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a><strong>启动方法</strong></h5><ul>
<li>使用命令行设置车辆状态，因为<code>advertised channel</code>不能立即准备就绪的原因，需要sleep一定时间;</li>
<li>初始化默认的控制状态：stop</li>
<li>控制器初始化完毕</li>
<li>返回操作成功码</li>
</ul>
<h5 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a><strong>关闭方法</strong></h5><p>当然，控制模块中，还有其他内容，进程管理，路径分析(Trajectory Analyzer)，磁滞滤波器(hysteresis filter)等方法：</p>
<ul>
<li>digital_filter_coefficients 产生数字滤波器系数的函数； </li>
<li>MeanFilter 使一些列噪声数字更加平滑，例如传感器数据，我们希望更平滑的函数输出；</li>
<li>DigitalFilter 用于过滤低于特定频率的信号，并衰减频率高于截止频率的信号； </li>
<li>HysteresisFilter 磁滞滤波器</li>
<li>TrajectoryAnalyzer 处理点查询和转换相关的轨迹</li>
<li>Interpolation1D 插值</li>
<li>Interpolation2D 从键（double，double）到一个double的线性插值</li>
<li>PIDController 用于速度和转向的比例积分微分控制器</li>
</ul>
<h3 id="驾驶模块"><a href="#驾驶模块" class="headerlink" title="驾驶模块"></a>驾驶模块</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/royenhome/archive/2010/10/29/1864860.html" target="_blank" rel="external">Google Protocol Buffers浅析（一）</a></li>
<li>关于rpc配置的几种方式：<a href="https://doc.oschina.net/grpc?t=60136" target="_blank" rel="external">https://doc.oschina.net/grpc?t=60136</a></li>
<li>互斥锁 <a href="http://zh.cppreference.com/w/cpp/thread/lock_guard" target="_blank" rel="external">http://zh.cppreference.com/w/cpp/thread/lock_guard</a></li>
<li>[译] 设计模式：发布/订阅模式解析 <a href="https://segmentfault.com/a/1190000003963671" target="_blank" rel="external">https://segmentfault.com/a/1190000003963671</a></li>
<li><a href="http://www.cnblogs.com/feixiao5566/p/5288206.html" target="_blank" rel="external">ROS的单线程Spinning和多线程Spinning</a></li>
<li><a href="http://wiki.ros.org/roscpp/Overview/Initialization%20and%20Shutdown" target="_blank" rel="external">roscpp Initialization and Shutdown</a></li>
</ul>


<!--<a href="http://yoursite.com/apollo/question.html#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'mickeyouyou'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div><!-- hexo-inject:begin --><!-- hexo-inject:end -->






</body>
</html>