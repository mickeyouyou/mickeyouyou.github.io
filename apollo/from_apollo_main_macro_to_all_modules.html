<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>从ApolloApp类、APOLLO_MAIN宏到Apollo模块</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/rocket_128px_1215034_easyicon.net.ico?v=3"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>


<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 class="title">从ApolloApp类、APOLLO_MAIN宏到Apollo模块</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年8月14日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ApolloApp"><span class="toc-text"><a href="#ApolloApp" class="headerlink" title="ApolloApp"></a>ApolloApp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#APOLLO-MAIN宏"><span class="toc-text"><a href="#APOLLO-MAIN&#x5B8F;" class="headerlink" title="APOLLO_MAIN&#x5B8F;"></a>APOLLO_MAIN&#x5B8F;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#现有模块"><span class="toc-text"><a href="#&#x73B0;&#x6709;&#x6A21;&#x5757;" class="headerlink" title="&#x73B0;&#x6709;&#x6A21;&#x5757;"></a>&#x73B0;&#x6709;&#x6A21;&#x5757;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标准模块"><span class="toc-text"><a href="#&#x6807;&#x51C6;&#x6A21;&#x5757;" class="headerlink" title="&#x6807;&#x51C6;&#x6A21;&#x5757;"></a>&#x6807;&#x51C6;&#x6A21;&#x5757;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#决策模块-Decision"><span class="toc-text"><a href="#&#x51B3;&#x7B56;&#x6A21;&#x5757;-Decision" class="headerlink" title="&#x51B3;&#x7B56;&#x6A21;&#x5757;(Decision)"></a>&#x51B3;&#x7B56;&#x6A21;&#x5757;(Decision)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制模块-Control"><span class="toc-text"><a href="#&#x63A7;&#x5236;&#x6A21;&#x5757;-Control" class="headerlink" title="&#x63A7;&#x5236;&#x6A21;&#x5757;(Control)"></a>&#x63A7;&#x5236;&#x6A21;&#x5757;(Control)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化方法"><span class="toc-text"><a href="#&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;" class="headerlink" title="&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;"></a><strong>&#x521D;&#x59CB;&#x5316;&#x65B9;&#x6CD5;</strong></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动方法"><span class="toc-text"><a href="#&#x542F;&#x52A8;&#x65B9;&#x6CD5;" class="headerlink" title="&#x542F;&#x52A8;&#x65B9;&#x6CD5;"></a><strong>&#x542F;&#x52A8;&#x65B9;&#x6CD5;</strong></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭方法"><span class="toc-text"><a href="#&#x5173;&#x95ED;&#x65B9;&#x6CD5;" class="headerlink" title="&#x5173;&#x95ED;&#x65B9;&#x6CD5;"></a><strong>&#x5173;&#x95ED;&#x65B9;&#x6CD5;</strong></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#感知模块（Perception）"><span class="toc-text"><a href="#&#x611F;&#x77E5;&#x6A21;&#x5757;&#xFF08;Perception&#xFF09;" class="headerlink" title="&#x611F;&#x77E5;&#x6A21;&#x5757;&#xFF08;Perception&#xFF09;"></a>&#x611F;&#x77E5;&#x6A21;&#x5757;&#xFF08;Perception&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预测模块（Prediction）"><span class="toc-text"><a href="#&#x9884;&#x6D4B;&#x6A21;&#x5757;&#xFF08;Prediction&#xFF09;" class="headerlink" title="&#x9884;&#x6D4B;&#x6A21;&#x5757;&#xFF08;Prediction&#xFF09;"></a>&#x9884;&#x6D4B;&#x6A21;&#x5757;&#xFF08;Prediction&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#驱动模块（Drivers）"><span class="toc-text"><a href="#&#x9A71;&#x52A8;&#x6A21;&#x5757;&#xFF08;Drivers&#xFF09;" class="headerlink" title="&#x9A71;&#x52A8;&#x6A21;&#x5757;&#xFF08;Drivers&#xFF09;"></a>&#x9A71;&#x52A8;&#x6A21;&#x5757;&#xFF08;Drivers&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定位模块（Localization）"><span class="toc-text"><a href="#&#x5B9A;&#x4F4D;&#x6A21;&#x5757;&#xFF08;Localization&#xFF09;" class="headerlink" title="&#x5B9A;&#x4F4D;&#x6A21;&#x5757;&#xFF08;Localization&#xFF09;"></a>&#x5B9A;&#x4F4D;&#x6A21;&#x5757;&#xFF08;Localization&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监控模块（Monitor）"><span class="toc-text"><a href="#&#x76D1;&#x63A7;&#x6A21;&#x5757;&#xFF08;Monitor&#xFF09;" class="headerlink" title="&#x76D1;&#x63A7;&#x6A21;&#x5757;&#xFF08;Monitor&#xFF09;"></a>&#x76D1;&#x63A7;&#x6A21;&#x5757;&#xFF08;Monitor&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#规划模块（Planning）"><span class="toc-text"><a href="#&#x89C4;&#x5212;&#x6A21;&#x5757;&#xFF08;Planning&#xFF09;" class="headerlink" title="&#x89C4;&#x5212;&#x6A21;&#x5757;&#xFF08;Planning&#xFF09;"></a>&#x89C4;&#x5212;&#x6A21;&#x5757;&#xFF08;Planning&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CANBUS模块"><span class="toc-text"><a href="#CANBUS&#x6A21;&#x5757;" class="headerlink" title="CANBUS&#x6A21;&#x5757;"></a>CANBUS&#x6A21;&#x5757;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text"><a href="#&#x53C2;&#x8003;" class="headerlink" title="&#x53C2;&#x8003;"></a>&#x53C2;&#x8003;</span></a></li></ol>
<blockquote>
<p>本文针对的是Apollo1.0发布的基础上，主要从ApolloApp类、APOLLO_MAIN宏入手，探究全部Apollo模块的初始化，启动等过程。</p>
</blockquote>
<h3 id="ApolloApp"><a href="#ApolloApp" class="headerlink" title="ApolloApp"></a>ApolloApp</h3><p>在modules/common/apollo_app.h文件中，定义了名为ApolloApp的类，主要用于各个模块注册信息。供各个模块调用一次APOLLO_MAIN(APP)，每调用一次，即创建一个module模块进程，ApolloApp类规范了每个模块APP类的公有接口。</p>
<p>所以从这个类入手，作为Apollo的分析入口再合适不过。</p>
<p>ApolloApp中包含几个虚函数，模块需要重写其中的虚函数接口实例化本模块。对虚函数的重写也体现了该模块区别与其他模块的地方。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">modules/common/apollo_app.h ApplloApp中的虚函数</span><br><span class="line"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 模块名称，进程名。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Spin</span><span class="params">()</span></span>; <span class="comment">//初始化模块app的信息，并持续运行直到shutdown</span></span><br><span class="line"><span class="keyword">virtual</span> apollo::common::<span class="function">Status <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//执行初始化加载配置文件和传感器数据等任务。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> apollo::common::<span class="function">Status <span class="title">Start</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//开始执行模块任务。若由上层message到来触发，则执行与message相关的回调函数。若由时间time触发，则调用时间处理回调函数。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//模块停止运行。在ros::shutdown()执行完毕后的清理工作。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ReportModuleStatus</span><span class="params">()</span></span>; <span class="comment">//向HMI人机交互界面发送状态status码。</span></span><br></pre></td></tr></table></figure>
<h4 id="APOLLO-MAIN宏"><a href="#APOLLO-MAIN宏" class="headerlink" title="APOLLO_MAIN宏"></a>APOLLO_MAIN宏</h4><p>在modules/common/apollo_app.h文件中，还定义了一个在用以在各个模块中初始化的<code>APOLLO_MAIN</code>宏，在大部分的Apollo模块初始化的主函数中，均使用该宏完成初始化工作（启动glog、gflag、ROS初始化等）。</p>
<figure class="highlight cpp"><figcaption><span>modules/common/appllo_app.h APOLLO_MAIN宏定义</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APOLLO_MAIN(APP)                                       \</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;                            \</span><br><span class="line">    google::InitGoogleLogging(argv[<span class="number">0</span>]);                        \</span><br><span class="line">    google::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);         \</span><br><span class="line">    signal(SIGINT, apollo::common::apollo_app_sigint_handler); \</span><br><span class="line">    APP apollo_app_;                                           \</span><br><span class="line">    ros::init(argc, argv, apollo_app_.Name());                 \</span><br><span class="line">    apollo_app_.Spin();                                        \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                  \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>一个定义main函数：</p>
<ul>
<li>初始化glag、glog组件；</li>
<li>注册信号变量，确保进程接收到SIGINT信号变量，或者ROS时，停止Apollo应用；</li>
<li>实例化对应模块，注册ROS等；</li>
</ul>
<h4 id="现有模块"><a href="#现有模块" class="headerlink" title="现有模块"></a>现有模块</h4><p>Apollo 现以下模块，更多模块会在之后的版本发布中涵盖：</p>
<ul>
<li>canbus 汽车CAN总线控制模块</li>
<li>common 公有的源码模块</li>
<li>control 控制模块</li>
<li>decision 决策模块</li>
<li>dreamview 可视化模块</li>
<li>drivers 驱动模块</li>
<li>hmi 人机交互模块</li>
<li>localization 定位模块</li>
<li>monitor 监控模块</li>
<li>perception 感知模块</li>
<li>planning 运动规划模块</li>
<li>prediction 预测模块</li>
<li>tools 通用监控与可视化工具</li>
</ul>
<p>之后发布的模块：</p>
<ul>
<li>map</li>
</ul>
<h4 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h4><p>一个标准模块的至少包含以下内容：</p>
<ul>
<li>common</li>
<li>conf</li>
<li>proto</li>
<li>main.cc</li>
<li>module.cc</li>
<li>module.h</li>
</ul>
<p>模块主函数（main.cc）中调用APOLLO_MAIN宏，完成模块的初始化。如在决策模块中调用该宏完成初始化：<br><figure class="highlight cpp"><figcaption><span>modules/decision/main.cc APOLLO_MAIN宏在决策模块的初始化</span></figcaption><table><tr><td class="code"><pre><span class="line">APOLLO_MAIN(apollo::decision::Decision);</span><br></pre></td></tr></table></figure></p>
<p>由此，其他的模块，依照该逻辑在进程中，完成模块的初始化，启动，作为其中一个节点，等待与ROS的交互。</p>
<p>接下来，依照之前APOLLO_MAIN宏，依次观察实例化的所有模块中实现的Init()、Start()、Stop()，以增加对所有模块的充分了解。</p>
<h3 id="决策模块-Decision"><a href="#决策模块-Decision" class="headerlink" title="决策模块(Decision)"></a>决策模块(Decision)</h3><p>以决策模块为例，将其中的APOLLO_MAIN宏替换为：<br><figure class="highlight cpp"><figcaption><span>modules/decision/main.cc APOLLO_MAIN宏在决策模块的替换结果</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">    google::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">    signal(SIGINT, apollo::common::apollo_app_sigint_handler);</span><br><span class="line">    apollo::decision::Decision apollo_app_;</span><br><span class="line">    ros::init(argc, argv, apollo_app_.Name());</span><br><span class="line">    apollo_app_.Spin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成的事情还是一样的，只不过这样更清晰：</p>
<ul>
<li>初始化glag、glog组件；</li>
<li>注册信号变量，确保进程接收到SIGINT信号变量，或者ROS时，停止Apollo应用；</li>
<li>实例化决策模块，初始化ROS决策节点；</li>
<li>调用基础模块类的回旋方法，这是Apollo应用的入口，完成初始化、启动、关闭（当ros要求关闭时）应用</li>
</ul>
<blockquote>
<p>重要的一点：所有模块的类，均基于Apollo_App基础模块类</p>
</blockquote>
<p>着重看下回旋方法：<br><figure class="highlight cpp"><figcaption><span>modules/common/apollo_app.cc 基类回旋方法</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ApolloApp::Spin() &#123;</span><br><span class="line">  ros::<span class="function">AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 初始化1个线程</span></span><br><span class="line">  <span class="keyword">auto</span> status = Init(); </span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    AERROR &lt;&lt; Name() &lt;&lt; <span class="string">" Init failed: "</span> &lt;&lt; status;</span><br><span class="line">    ReportModuleStatus(apollo::hmi::ModuleStatus::UNINITIALIZED);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReportModuleStatus(apollo::hmi::ModuleStatus::INITIALIZED);</span><br><span class="line">  status = Start();</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    AERROR &lt;&lt; Name() &lt;&lt; <span class="string">" Start failed: "</span> &lt;&lt; status;</span><br><span class="line">    ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReportModuleStatus(apollo::hmi::ModuleStatus::STARTED);</span><br><span class="line">  spinner.start();</span><br><span class="line">  ros::waitForShutdown();</span><br><span class="line">  Stop();</span><br><span class="line">  ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);</span><br><span class="line">  AINFO &lt;&lt; Name() &lt;&lt; <span class="string">" exited."</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>ros::AsyncSpinner spinner(1);</code>是来自Ros中的线程管理，用以初始化1个线程，更多的解释参考：<br>一个更有用的线程spinner是AsyncSpinner，与阻塞的 <code>spin()</code>不同, 它有<code>start()</code>和<code>stop()</code>调用, 并且在销毁时自动停止</p>
<figure class="highlight cpp"><figcaption><span>ros::AsyncSpinner</span></figcaption><table><tr><td class="code"><pre><span class="line">ros::<span class="function">AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// Use 4 threads</span></span><br><span class="line">spinner.start();</span><br><span class="line">ros::waitForShutdown();</span><br><span class="line">``` </span><br><span class="line">```cpp </span><br><span class="line"><span class="keyword">auto</span> status = Init();</span><br></pre></td></tr></table></figure>
<p>基类中没有实现Init()方法，所以此处的status结果其实是决策模块中的Init()方法运行的结果。</p>
<p>决策模块的Init()方法:直接返回了成功码<br><figure class="highlight cpp"><figcaption><span>modules/decision/decision.cc 决策模块的Init()方法</span></figcaption><table><tr><td class="code"><pre><span class="line">common::Status Decision::Init() &#123; <span class="keyword">return</span> common::Status::OK(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>决策模块的Start()方法：启动Ros 计时器，并返回启动成功错误码：<br><figure class="highlight cpp"><figcaption><span>modules/decision/decision.cc 决策模块的Start()方法</span></figcaption><table><tr><td class="code"><pre><span class="line">common::Status Decision::Start() &#123;</span><br><span class="line">  AdapterManager::Init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// start ROS timer, one-shot = false, auto-start = true</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> duration = <span class="number">1.0</span> / FLAGS_decision_publish_freq;</span><br><span class="line">  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),</span><br><span class="line">                                       &amp;Decision::OnTimer, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> common::Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下模块基类中Spin()方法的主要逻辑：是对决策模块的执行：</p>
<ul>
<li>初始化决策模块，并向HMI上报状态；</li>
<li>启动决策模块，并向HMI上报状态；</li>
<li>等待关闭，ros::waitForShutdown()；</li>
<li>关闭决策模块；</li>
</ul>
<figure class="highlight plain"><figcaption><span>mudules/decision/proto/decision.proto 决策模块中对象定义</span></figcaption><table><tr><td class="code"><pre><span class="line">//标识物体长度的2D数据。</span><br><span class="line">message Range &#123;</span><br><span class="line">  optional double start = 1;</span><br><span class="line">  optional double end = 2;</span><br><span class="line">&#125;</span><br><span class="line">//理想化的车道线。车辆行驶起点+终点+行驶速度。 单位m</span><br><span class="line">message TargetLane &#123;</span><br><span class="line">  // lane id</span><br><span class="line">  optional string id = 1;</span><br><span class="line">  optional double start_s = 2;  // in meters</span><br><span class="line">  optional double end_s = 3;    // in meters</span><br><span class="line">  optional double speed_limit = 4;  // in m/s</span><br><span class="line">&#125;</span><br><span class="line">message ObjectIgnore &#123;</span><br><span class="line">&#125;</span><br><span class="line">//停车命令，停车理由状态码。</span><br><span class="line">enum StopReasonCode &#123;</span><br><span class="line">  STOP_REASON_HEAD_VEHICLE = 1; //有前车</span><br><span class="line">  STOP_REASON_DESTINATION = 2; //到达目的地</span><br><span class="line">  STOP_REASON_PEDESTRIAN = 3;  //有行人</span><br><span class="line">  STOP_REASON_OBSTACLE = 4;    //有障碍物体</span><br><span class="line">  STOP_REASON_PREPARKING = 5;  // 预停车</span><br><span class="line">  STOP_REASON_SIGNAL = 100;    //信号灯</span><br><span class="line">  STOP_REASON_STOP_SIGN = 101; //停车标识</span><br><span class="line">  STOP_REASON_YIELD_SIGN = 102;//让路标志</span><br><span class="line">  STOP_REASON_CLEAR_ZONE = 103; // 清除区</span><br><span class="line">  STOP_REASON_CROSSWALK = 104; //人行横道</span><br><span class="line">&#125;</span><br><span class="line">//停车目标。距离+停车码+停车点</span><br><span class="line">message ObjectStop &#123;</span><br><span class="line">  // stop at least distance_s before the object</span><br><span class="line">  optional double distance_s = 1;  // in meters</span><br><span class="line">  optional Range preferred_distance_s = 2;  // NOT SUPPORTED FIELD</span><br><span class="line">  optional StopReasonCode reason_code = 3;</span><br><span class="line">  optional apollo.common.PointENU stop_point = 4;  // stop point</span><br><span class="line">&#125;</span><br><span class="line">//距离缓慢移动物体的最小距离</span><br><span class="line">message ObjectNudge &#123;</span><br><span class="line">  // minimum lateral distance with the object</span><br><span class="line">  optional double distance_l = 1;  // in meters</span><br><span class="line">  enum Type &#123;</span><br><span class="line">    LEFT_NUDGE = 1;</span><br><span class="line">    RIGHT_NUDGE = 2;</span><br><span class="line">  &#125;;</span><br><span class="line">  optional Type type = 2;</span><br><span class="line">  optional Range preferred_distance_l = 3;  // NOT SUPPORTED FIELD</span><br><span class="line">&#125;</span><br><span class="line">//车辆 礼让 命令状态。如校车/公交车/救护车</span><br><span class="line">message ObjectYield &#123;</span><br><span class="line">  // minimum longitutional distance with the object</span><br><span class="line">  optional double distance_s = 1;  // in meters</span><br><span class="line">  optional Range preferred_distance_s = 2;  // NOT SUPPORTED FIELD</span><br><span class="line">  optional apollo.common.PointENU yield_point = 3;</span><br><span class="line">&#125;</span><br><span class="line">//车辆 跟随 目标</span><br><span class="line">message ObjectFollow &#123;</span><br><span class="line">  // minimum longitutional distance with the object</span><br><span class="line">  optional double distance_s = 1;  // in meters</span><br><span class="line">  optional Range preferred_distance_s = 2;  // NOT SUPPORTED FIELD</span><br><span class="line">  optional apollo.common.PointENU follow_point = 3;</span><br><span class="line">&#125;</span><br><span class="line">//超车命令状态</span><br><span class="line">message ObjectOvertake &#123;</span><br><span class="line">  // minimum longitutional distance with the object</span><br><span class="line">  optional double distance_s = 1;  // in meters</span><br><span class="line">  optional Range preferred_distance_s = 2;  // NOT SUPPORTED FIELD</span><br><span class="line">  optional apollo.common.PointENU overtake_point = 3;</span><br><span class="line">&#125;</span><br><span class="line">// 车辆侧面 物体/车辆 状态</span><br><span class="line">message ObjectSidePass &#123;</span><br><span class="line">  // Follow or lead the object from side lane keeping a longitutional distance</span><br><span class="line">  // to it.</span><br><span class="line">  // If you want to cut in the neighbored lane, you may need to sidepass a</span><br><span class="line">  // neighbored object first.</span><br><span class="line">  optional double distance_s = 1;           // in meters</span><br><span class="line">  optional Range preferred_distance_s = 2;  // in meters, relative to the object</span><br><span class="line">  enum Type &#123;</span><br><span class="line">    FOLLOW = 1;  // Follow the object from side lane</span><br><span class="line">    LEAD = 2;    // Lead the object from side lane</span><br><span class="line">  &#125;;</span><br><span class="line">  optional Type type = 3;</span><br><span class="line">&#125;</span><br><span class="line">message ObjectAvoid &#123;</span><br><span class="line">&#125;</span><br><span class="line">//因某物体而产生的决策类型</span><br><span class="line">message ObjectDecisionType &#123;</span><br><span class="line">  oneof object_tag &#123;</span><br><span class="line">    ObjectIgnore ignore = 1; //忽略此物体</span><br><span class="line">    ObjectStop stop = 2;     //停车</span><br><span class="line">    ObjectFollow follow = 3; //跟车</span><br><span class="line">    ObjectYield yield = 4;   //礼让行人/车辆</span><br><span class="line">    ObjectOvertake overtake = 5;//超车</span><br><span class="line">    ObjectNudge nudge = 6;     //缓慢移动</span><br><span class="line">    ObjectSidePass sidepass = 7; //侧方行驶</span><br><span class="line">    ObjectAvoid avoid = 8;  //避开 unified object decision while estop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">message ObjectDecision &#123;</span><br><span class="line">  enum ObjectType &#123;</span><br><span class="line">    PREDICTION = 1;</span><br><span class="line">    PERCEPTION = 2;</span><br><span class="line">    VIRTUAL = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  optional apollo.prediction.PredictionObstacle prediction = 1;</span><br><span class="line">  optional string id = 2;</span><br><span class="line">  optional ObjectType type = 3;</span><br><span class="line">  optional ObjectDecisionType decision = 4 [deprecated = true];</span><br><span class="line">  repeated ObjectDecisionType object_decision = 5;</span><br><span class="line">&#125;</span><br><span class="line">//由该物体而产生的决策命令</span><br><span class="line">message ObjectDecisions &#123;</span><br><span class="line">  repeated ObjectDecision decision = 1;</span><br><span class="line">&#125;</span><br><span class="line">//停车线</span><br><span class="line">// stop at distance_s on lane</span><br><span class="line">message StopLine &#123;</span><br><span class="line">  optional string lane_id = 1;</span><br><span class="line">  optional double distance_s = 2;</span><br><span class="line">&#125;</span><br><span class="line">//停车控制变量。</span><br><span class="line">message MainStop &#123;</span><br><span class="line">  // stop at or before distance_s relative to the lane_id</span><br><span class="line">  optional StopLine enforced_line = 1;</span><br><span class="line">  optional StopLine preferred_start = 2;  // NOT SUPPORTED FIELD</span><br><span class="line">  optional StopLine preferred_end = 3;    // NOT SUPPORTED FIELD</span><br><span class="line">  optional string reason = 4;</span><br><span class="line">  optional StopReasonCode reason_code = 5;</span><br><span class="line">  // When stopped, the front center of vehicle should be at this point.</span><br><span class="line">  optional apollo.common.PointENU stop_point = 6;</span><br><span class="line">  // When stopped, the heading of the vehicle should be stop_heading.</span><br><span class="line">  optional double stop_heading = 7;</span><br><span class="line">&#125;</span><br><span class="line">message EmergencyStopHardBrake &#123;</span><br><span class="line">&#125;</span><br><span class="line">message EmergencyStopCruiseToStop &#123;</span><br><span class="line">&#125;</span><br><span class="line">//紧急停车</span><br><span class="line">message MainEmergencyStop &#123;</span><br><span class="line">  // Unexpected event happened, human driver is required to take over the</span><br><span class="line">  // vehicle.</span><br><span class="line">  optional string reason = 1;</span><br><span class="line">  enum ReasonCode &#123;</span><br><span class="line">    ESTOP_REASON_INTERNAL_ERR = 1;</span><br><span class="line">    ESTOP_REASON_COLLISION = 2;</span><br><span class="line">    ESTOP_REASON_ST_FIND_PATH = 3;</span><br><span class="line">    ESTOP_REASON_ST_MAKE_DECISION = 4;</span><br><span class="line">    ESTOP_REASON_SENSOR_ERROR = 5;</span><br><span class="line">  &#125;</span><br><span class="line">  optional ReasonCode reason_code = 2;</span><br><span class="line">  oneof task &#123;</span><br><span class="line">    EmergencyStopHardBrake hard_brake = 3;  // hard brake</span><br><span class="line">    EmergencyStopCruiseToStop cruise_to_stop = 4;  // cruise to stop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 巡航</span><br><span class="line">message MainCruise &#123;</span><br><span class="line">  // cruise current lane</span><br><span class="line">&#125;</span><br><span class="line">message MainChangeLane &#123;</span><br><span class="line">  enum Type &#123;</span><br><span class="line">    LEFT = 1;</span><br><span class="line">    RIGHT = 2;</span><br><span class="line">  &#125;;</span><br><span class="line">  optional Type type = 1;</span><br><span class="line">  repeated TargetLane default_lane = 2;</span><br><span class="line">  optional MainStop default_lane_stop = 3;</span><br><span class="line">  optional MainStop target_lane_stop = 4;</span><br><span class="line">&#125;</span><br><span class="line">message MainMissionComplete &#123;</span><br><span class="line">  // arrived at routing destination</span><br><span class="line">&#125;</span><br><span class="line">message MainNotReady &#123;</span><br><span class="line">  // decision system is not ready.</span><br><span class="line">  // e.g. wait for routing data.</span><br><span class="line">  optional string reason = 1;</span><br><span class="line">&#125;</span><br><span class="line">//停车</span><br><span class="line">message MainParking &#123;</span><br><span class="line">  enum Type &#123;</span><br><span class="line">    FORWARD_PARKING = 1;</span><br><span class="line">    REVERSE_PARKING = 2;</span><br><span class="line">  &#125;;</span><br><span class="line">  optional Type type = 1;</span><br><span class="line">  // the heading of the final car position</span><br><span class="line">  optional double heading = 2;</span><br><span class="line">  // stop point</span><br><span class="line">  optional apollo.common.PointENU stop_point = 3;</span><br><span class="line">  // the polygon of the parking spot</span><br><span class="line">  repeated apollo.common.PointENU parking_polygon = 4;</span><br><span class="line">&#125;</span><br><span class="line">//决策命令内容</span><br><span class="line">message MainDecision &#123;</span><br><span class="line">  oneof task &#123;</span><br><span class="line">    MainCruise cruise = 1;</span><br><span class="line">    MainStop stop = 2;</span><br><span class="line">    MainEmergencyStop estop = 3;</span><br><span class="line">    MainChangeLane change_lane = 4;</span><br><span class="line">    MainMissionComplete mission_complete = 6;</span><br><span class="line">    MainNotReady not_ready = 7;</span><br><span class="line">    MainParking parking = 8;</span><br><span class="line">  &#125;</span><br><span class="line">  repeated TargetLane target_lane = 5;</span><br><span class="line">&#125;</span><br><span class="line">//控制车辆的方便debug信息</span><br><span class="line">message MasterVehicleDebug &#123;</span><br><span class="line">  optional apollo.common.PointENU position = 1;</span><br><span class="line">  optional string current_lane_id = 2;</span><br><span class="line">  optional double lane_s = 3;</span><br><span class="line">  optional double lane_l = 4;</span><br><span class="line">  optional double route_s = 5 [deprecated = true];</span><br><span class="line">  optional double route_l = 6 [deprecated = true];</span><br><span class="line">  optional double heading = 7;</span><br><span class="line">  optional double heading_speed = 8;</span><br><span class="line">  optional double heading_acceleration = 9;</span><br><span class="line">  optional Range route_s_range = 10;</span><br><span class="line">  optional Range route_l_range = 11;</span><br><span class="line">&#125;</span><br><span class="line">message ObjectDebug &#123;</span><br><span class="line">  optional string id = 1;</span><br><span class="line">  optional string path_id = 2;</span><br><span class="line">  optional Range route_s = 3;</span><br><span class="line">  optional Range route_l = 4;</span><br><span class="line">  optional bool on_route = 5;</span><br><span class="line">  optional string lane_id = 6;</span><br><span class="line">  optional double lane_s = 7;</span><br><span class="line">  optional bool on_lane = 8;</span><br><span class="line">  optional double path_speed = 9;</span><br><span class="line">  // x is time (t), y is s</span><br><span class="line">  repeated apollo.common.Point3D st_region =  10;</span><br><span class="line">&#125;</span><br><span class="line">//潜在因素</span><br><span class="line">message LatencyStats &#123;</span><br><span class="line">  optional double total_time_ms = 1;</span><br><span class="line">  optional double sensor_read_time_ms = 2;</span><br><span class="line">  optional double adc_prepare_time_ms = 3;</span><br><span class="line">  optional double obj_prepare_time_ms = 4;</span><br><span class="line">  optional double world_rule_time_ms = 5;</span><br><span class="line">  optional double st_graph_time_ms = 6;</span><br><span class="line">  // time diff between gateway_msg_receive_timestamp and gateway_msg_timestamp</span><br><span class="line">  optional double gateway_receive_delay_ms = 8;</span><br><span class="line">  // time diff between perception_msg_receive_timestamp and</span><br><span class="line">  // perception_msg_timestamp</span><br><span class="line">  optional double perception_receive_delay_ms = 9;</span><br><span class="line">  // time diff between prediction_msg_receive_timestamp and</span><br><span class="line">  // prediction_msg_timestamp</span><br><span class="line">  optional double prediction_receive_delay_ms = 10;</span><br><span class="line">  // time diff between signal_msg_receive_timestamp and signal_msg_timestamp</span><br><span class="line">  optional double signal_receive_delay_ms = 11;</span><br><span class="line">  // time interval in ms between perception last and its previous msg</span><br><span class="line">  optional double perception_interval_ms = 12;</span><br><span class="line">  // time interval in ms between prediction last and its previous msg</span><br><span class="line">  optional double prediction_interval_ms = 13;</span><br><span class="line">&#125;</span><br><span class="line">message Stats &#123;</span><br><span class="line">  optional LatencyStats latency_stats = 1;</span><br><span class="line">&#125;</span><br><span class="line">message ModuleDebug &#123;</span><br><span class="line">  optional uint32 gateway_sequence_num = 1;</span><br><span class="line">  optional uint32 perception_sequence_num = 2;</span><br><span class="line">  optional uint32 prediction_sequence_num = 3;</span><br><span class="line">  optional uint32 signal_sequence_num = 4;</span><br><span class="line">&#125;</span><br><span class="line">// next id: 8</span><br><span class="line">message Debug &#123;</span><br><span class="line">  optional MasterVehicleDebug master_vehicle = 1;</span><br><span class="line">  // Stores current frame&apos;s original decision when current decision has be</span><br><span class="line">  // modified.</span><br><span class="line">  // E.g., when current decision is the first encountered estop, we may use</span><br><span class="line">  // A valid history decision to replace current decision, but the estop</span><br><span class="line">  // decision will be stored in original_decision.</span><br><span class="line">  optional MainDecision original_decision = 2;</span><br><span class="line">  repeated ObjectDebug object = 3;</span><br><span class="line">  // some meta data will be dumped into debug per sample frequency:</span><br><span class="line">  // e.g. every 500 decision, meta data will be dumped once.</span><br><span class="line">  optional bytes map_version = 5;</span><br><span class="line">  optional bytes decision_version = 7;</span><br><span class="line">  // record per module debug info</span><br><span class="line">  optional ModuleDebug module_debug = 6;</span><br><span class="line">&#125;</span><br><span class="line">//车载计算机控制的车灯信号</span><br><span class="line">// The light signal of the adc</span><br><span class="line">// naming reference https://en.wikipedia.org/wiki/Automotive_lighting</span><br><span class="line">message LightSignal &#123;</span><br><span class="line">  optional bool emergency = 1; // hazard signal</span><br><span class="line">  enum TurnSignal &#123;</span><br><span class="line">    NO_TURN = 1;</span><br><span class="line">    LEFT_TURN = 2;</span><br><span class="line">    RIGHT_TURN = 3;</span><br><span class="line">  &#125;;</span><br><span class="line">  optional TurnSignal turn_signal = 2 [default = NO_TURN];</span><br><span class="line">&#125;</span><br><span class="line">//决策结果</span><br><span class="line">message DecisionResult &#123;</span><br><span class="line">  optional apollo.common.Header header = 1;</span><br><span class="line">  optional ObjectDecisions object_decision = 2;//由物体而产生的决策命令</span><br><span class="line">  optional MainDecision main_decision = 3;     //决策命令</span><br><span class="line">  optional Debug debug = 4;</span><br><span class="line">  optional Stats stats = 6;</span><br><span class="line">  optional apollo.canbus.Signal signal = 7;    //向底盘发送的信号内容</span><br><span class="line">  optional LightSignal light_signal = 5 [deprecated = true];//车灯信号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制模块-Control"><a href="#控制模块-Control" class="headerlink" title="控制模块(Control)"></a>控制模块(Control)</h3><p>控制模块的主要功能，处理定位、车辆信息、平板数据，以计算节气门，制动和转向值。</p>
<h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a><strong>初始化方法</strong></h4><ul>
<li>加载，初始化默认控制配置文件</li>
<li>初始化控制器 :<figure class="highlight cpp"><figcaption><span>modules/control/control.cc 控制器的初始化</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// set controller</span></span><br><span class="line"><span class="keyword">if</span> (!controller_agent_.Init(&amp;control_conf_).ok()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg = <span class="string">"Control init controller failed! Stopping..."</span>;</span><br><span class="line">  buffer.ERROR(error_msg);</span><br><span class="line">  <span class="keyword">return</span> Status(ErrorCode::CONTROL_INIT_ERROR, error_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中提到Control模块的两个属性：</p>
<ul>
<li><code>controller_agent_</code> 实例化自 ControllerAgent 管理所有在控制模块配置文件中定义的控制器</li>
<li><code>control_conf_</code> 实例化自ControlConf 控制器配置对象</li>
</ul>
<p>下面看下ControllerAgent::Init()方法的主要内容：</p>
<ul>
<li><p>利用公共模块提供的工厂模型方法，注册经度、维度控制器：</p>
<figure class="highlight cpp"><figcaption><span>mudules/control/controler/controller_agent.cc </span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ControllerAgent::RegisterControllers() &#123;</span><br><span class="line">  controller_factory_.Register(</span><br><span class="line">      ControlConf::LAT_CONTROLLER,</span><br><span class="line">      []() -&gt; Controller * &#123; <span class="keyword">return</span> <span class="keyword">new</span> LatController(); &#125;);</span><br><span class="line">  controller_factory_.Register(</span><br><span class="line">      ControlConf::LON_CONTROLLER,</span><br><span class="line">      []() -&gt; Controller * &#123; <span class="keyword">return</span> <span class="keyword">new</span> LonController(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载默认控制配置文件中激活的控制器：LAT_CONTROLLER、LON_CONTROLLER，并创建单例的控制对象。</p>
</li>
</ul>
<p>mudules/control/conf/lincoln.pb.txt 默认控制配置文件一部分:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">control_period: 0.01</span><br><span class="line">trajectory_period: 0.1</span><br><span class="line">chassis_period: 0.01</span><br><span class="line">localization_period: 0.01</span><br><span class="line">max_status_interval_sec: 0.1</span><br><span class="line">max_planning_interval_sec: 0.2</span><br><span class="line">max_planning_delay_threshold: 4.0</span><br><span class="line">action: STOP</span><br><span class="line">soft_estop_brake: 50.0</span><br><span class="line">active_controllers: LAT_CONTROLLER</span><br><span class="line">active_controllers: LON_CONTROLLER</span><br><span class="line">max_steering_percentage_allowed: 100</span><br><span class="line">lat_controller_conf&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line">lon_controller_conf&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历基于控制器类的经度、维度控制器，检查是否已被初始化。</p>
<p>控制命令<br><figure class="highlight protobuf"><figcaption><span>apollo/modules/control/proto/control_cmd.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">message ControlCommand &#123;</span><br><span class="line">  optional apollo.common.Header header = 1;</span><br><span class="line">  // target throttle in percentage [0, 100] 风门百分比</span><br><span class="line">  optional double throttle = 3;</span><br><span class="line"></span><br><span class="line">  // target brake in percentage [0, 100] 制动目标百分比</span><br><span class="line">  optional double brake = 4;</span><br><span class="line"></span><br><span class="line">  // target non-directional steering rate, in percentage of full scale per second [0, 100]</span><br><span class="line">  optional double steering_rate = 6;</span><br><span class="line"></span><br><span class="line">  // target steering angle, in percentage of full scale [-100, 100]目标转向角，以满量程的百分比表示</span><br><span class="line">  optional double steering_target = 7;</span><br><span class="line"></span><br><span class="line">  // parking brake engage. true: engaged 停车制动</span><br><span class="line">  optional bool parking_brake = 8;</span><br><span class="line"></span><br><span class="line">  // target speed, in km/h 速度</span><br><span class="line">  optional double speed = 9;</span><br><span class="line"></span><br><span class="line">  // target acceleration in m`s^-2加速度</span><br><span class="line">  optional double acceleration = 10;</span><br><span class="line"></span><br><span class="line">  // model reset</span><br><span class="line">  optional bool reset_model = 16 [deprecated = true];</span><br><span class="line">  // engine on/off, true: engine on引擎开启与关闭</span><br><span class="line">  optional bool engine_on_off = 17;</span><br><span class="line">  // completion percentage of trajectory planned in last cycle完成上一周期规划路径百分比</span><br><span class="line">  optional double trajectory_fraction = 18;</span><br><span class="line">  optional apollo.canbus.Chassis.DrivingMode driving_mode = 19 [deprecated = true];</span><br><span class="line">  optional apollo.canbus.Chassis.GearPosition gear_location = 20;</span><br><span class="line"></span><br><span class="line">  optional Debug debug = 22;</span><br><span class="line">  optional apollo.common.VehicleSignal signal = 23;</span><br><span class="line">  optional LatencyStats latency_stats = 24;</span><br><span class="line">  optional PadMessage pad_msg = 25;</span><br><span class="line"></span><br><span class="line">  // deprecated fields</span><br><span class="line">  optional bool left_turn = 13 [deprecated = true];</span><br><span class="line">  optional bool right_turn = 14 [deprecated = true];</span><br><span class="line">  optional bool high_beam = 11 [deprecated = true];</span><br><span class="line">  optional bool low_beam = 12 [deprecated = true];</span><br><span class="line">  optional bool horn = 15 [deprecated = true];</span><br><span class="line">  optional TurnSignal turnsignal = 21 [deprecated = true];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下，控制器代理方法的的初始化内容主要是根据配置文件，初始化其中的两个控制器：经度、维度控制器。</p>
<p>之后是一些跟控制模块相关的检查：</p>
<ul>
<li>检查定位模块是否已经初始化</li>
<li>检查底盘信息是否被初始化</li>
<li>检查路径规划模块是否已初始化</li>
<li>检查平板是否已初始化</li>
<li>检查控制命令发布者是否已初始化</li>
</ul>
<p>最后返回初始化成功的状态码</p>
<h4 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a><strong>启动方法</strong></h4><ul>
<li>使用命令行设置车辆状态，因为<code>advertised channel</code>不能立即准备就绪的原因，需要sleep一定时间;</li>
<li>初始化默认的控制状态：stop</li>
<li>控制器初始化完毕</li>
<li>返回操作成功码</li>
</ul>
<h4 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a><strong>关闭方法</strong></h4><p>当然，控制模块中，还有其他内容，进程管理，路径分析(Trajectory Analyzer)，磁滞滤波器(hysteresis filter)等方法：</p>
<ul>
<li>digital_filter_coefficients 产生数字滤波器系数的函数； </li>
<li>MeanFilter 使一些列噪声数字更加平滑，例如传感器数据，我们希望更平滑的函数输出；</li>
<li>DigitalFilter 用于过滤低于特定频率的信号，并衰减频率高于截止频率的信号； </li>
<li>HysteresisFilter 磁滞滤波器</li>
<li>TrajectoryAnalyzer 处理点查询和转换相关的轨迹</li>
<li>Interpolation1D 插值</li>
<li>Interpolation2D 从键（double，double）到一个double的线性插值</li>
<li>PIDController 用于速度和转向的比例积分微分控制器</li>
</ul>
<h3 id="感知模块（Perception）"><a href="#感知模块（Perception）" class="headerlink" title="感知模块（Perception）"></a>感知模块（Perception）</h3><p>逻辑主要集中在模块启动中：</p>
<ul>
<li>创建单线程监听模块状态；</li>
<li>进入while循环：<ul>
<li>感知障碍（PerceptionObstacles），过滤与发布</li>
<li>信号灯检测（TrafficLightDetection），过滤与发布</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>modules/perception/perception.cc 感知模块启动方法</span></figcaption><table><tr><td class="code"><pre><span class="line">Status Perception::Start() &#123;</span><br><span class="line">  ros::<span class="function">AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  spinner.start();</span><br><span class="line">  ros::waitForShutdown();</span><br><span class="line">  spinner.stop();</span><br><span class="line">  ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(FLAGS_perception_loop_rate)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::ok()) &#123;</span><br><span class="line">    AdapterManager::Observe();</span><br><span class="line">    PerceptionObstacles perceptionObstacles;</span><br><span class="line">    AdapterManager::FillPerceptionObstaclesHeader(</span><br><span class="line">        Name(), perceptionObstacles.mutable_header());</span><br><span class="line">    AdapterManager::PublishPerceptionObstacles(perceptionObstacles);</span><br><span class="line"></span><br><span class="line">    TrafficLightDetection trafficLightDetection;</span><br><span class="line">    AdapterManager::FillTrafficLightDetectionHeader(</span><br><span class="line">        Name(), trafficLightDetection.mutable_header());</span><br><span class="line">    AdapterManager::PublishTrafficLightDetection(trafficLightDetection);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的PerceptionObstacles对象是通过proto定义的消息对象：<br><figure class="highlight plain"><figcaption><span>modules/perception/proto/perception_obstacle.proto 感知障碍对象定义</span></figcaption><table><tr><td class="code"><pre><span class="line">message PerceptionObstacle &#123;</span><br><span class="line">  optional int32 id = 1;  // obstacle ID.障碍物ID</span><br><span class="line">  optional Point position = 2;  // obstacle position in the world coordinate system.障碍物点坐标</span><br><span class="line">  optional double theta = 3;  // heading in the world coordinate system.坐标朝向</span><br><span class="line">  optional Point velocity = 4;  // obstacle velocity.障碍物速度</span><br><span class="line"></span><br><span class="line">  // Size of obstacle bounding box.</span><br><span class="line">  optional double length = 5;  // obstacle length.</span><br><span class="line">  optional double width = 6;  // obstacle width.</span><br><span class="line">  optional double height = 7;  // obstacle height.</span><br><span class="line"></span><br><span class="line">  repeated Point polygon_point = 8;  // obstacle corner points.</span><br><span class="line">  // duration of an obstacle since detection in s.</span><br><span class="line">  optional double tracking_time = 9;</span><br><span class="line"></span><br><span class="line">  enum Type &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    UNKNOWN_MOVABLE = 1;</span><br><span class="line">    UNKNOWN_UNMOVABLE = 2;</span><br><span class="line">    PEDESTRIAN = 3;  // 行人 Pedestrian, usually determined by moving behaviour.</span><br><span class="line">    BICYCLE = 4;  // bike, motor bike</span><br><span class="line">    VEHICLE = 5;  // 客车、卡车Passenger car or truck.</span><br><span class="line">  &#125;;</span><br><span class="line">  optional Type type = 10;  // obstacle type</span><br><span class="line">  optional double timestamp = 11;  // GPS time in seconds.</span><br><span class="line"></span><br><span class="line">  // Just for offline debuging, onboard will not fill this field.</span><br><span class="line">  // Format like : [x0, y0, z0, x1, y1, z1...]</span><br><span class="line">  repeated double point_cloud = 12 [packed = true];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>感知障碍模型在Apollo的形式，最后转换成为一个具体的立体对象，就像我们看到的这样：<br><img src="https://console.bce.baidu.com/apollo/img/overviewInfo0.gif"></p>
<p>信号灯检测（TrafficLightDetection）</p>
<figure class="highlight plain"><figcaption><span>modules/perception/proto/traffic_light_detection.proto 信号灯模型、信号灯检测模型定义</span></figcaption><table><tr><td class="code"><pre><span class="line">message TrafficLight &#123;</span><br><span class="line">  enum Color &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    RED = 1;</span><br><span class="line">    YELLOW = 2;</span><br><span class="line">    GREEN = 3;</span><br><span class="line">  &#125;;</span><br><span class="line">  optional Color color = 1;</span><br><span class="line"></span><br><span class="line">  // Traffic light string-ID in the map data.</span><br><span class="line">  optional string id = 2;</span><br><span class="line"></span><br><span class="line">  // How confidence about the detected results, between 0 and 1.</span><br><span class="line">  optional double confidence = 3 [default = 1.0];</span><br><span class="line"></span><br><span class="line">  // Duration of the traffic light since detected.</span><br><span class="line">  optional double tracking_time = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message TrafficLightDetection &#123;</span><br><span class="line">  optional apollo.common.Header header = 2;</span><br><span class="line"></span><br><span class="line">  repeated TrafficLight traffic_light = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://console.bce.baidu.com/apollo/img/overviewInfo1.gif"></p>
<h3 id="预测模块（Prediction）"><a href="#预测模块（Prediction）" class="headerlink" title="预测模块（Prediction）"></a>预测模块（Prediction）</h3><p>初始化：</p>
<ul>
<li>单例初始化（实例已在其他模块，如控制模块初始化）</li>
<li>设置障碍物感知回调，回调方法完成</li>
</ul>
<h3 id="驱动模块（Drivers）"><a href="#驱动模块（Drivers）" class="headerlink" title="驱动模块（Drivers）"></a>驱动模块（Drivers）</h3><h3 id="定位模块（Localization）"><a href="#定位模块（Localization）" class="headerlink" title="定位模块（Localization）"></a>定位模块（Localization）</h3><p>启动方法：<br><figure class="highlight cpp"><figcaption><span>mudules/localization/localization.cc 定位模块的启动方法</span></figcaption><table><tr><td class="code"><pre><span class="line">Status Localization::Init() &#123;</span><br><span class="line">  <span class="comment">// 注册RTK、CAMERA对象实例</span></span><br><span class="line">  RegisterLocalizationMethods();</span><br><span class="line">  <span class="keyword">if</span> (!apollo::common::util::GetProtoFromFile(FLAGS_localization_config_file,</span><br><span class="line">                                              &amp;config_)) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"failed to load localization config file "</span></span><br><span class="line">           &lt;&lt; FLAGS_localization_config_file;</span><br><span class="line">    <span class="keyword">return</span> Status(ErrorCode::LOCALIZATION_ERROR,</span><br><span class="line">                  <span class="string">"failed to load localization config file: "</span> +</span><br><span class="line">                      FLAGS_localization_config_file);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码上的含义：拿配置文件获取对应的对象，FLAGS_localization_config_file配置文件，其中指定了定位类型使用RTK方式：<br><figure class="highlight plain"><figcaption><span>modules/localization/conf/localization_config.pb.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">localization_type: RTK</span><br></pre></td></tr></table></figure></p>
<p>目前Apollo 1.0采用的是 <a href="https://en.wikipedia.org/wiki/Real_Time_Kinematic" target="_blank" rel="noopener">RTK-GPS定位法</a>，他的定位原理大致如下：<br>RTK-GPS 至少有一个基准站接收机，一个流动站接收机。<br>基准站的接收机有两个任务：</p>
<ul>
<li>接收卫星信号</li>
<li>把自己的观测量通过发送给流动站</li>
</ul>
<p>流动站有三个任务：</p>
<ul>
<li>接收卫星信号</li>
<li>接收基准站所发送的基准站观测量</li>
<li>对卫星信号与基准站观测量进行对比处理，从而对自己的观测量进行修正<figure class="highlight plain"><figcaption><span>modules/localization/conf/rtk_adapter.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">config &#123;</span><br><span class="line">  type: GPS</span><br><span class="line">  mode: RECEIVE_ONLY</span><br><span class="line">  message_history_limit: 50</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">  type: IMU</span><br><span class="line">  mode: RECEIVE_ONLY</span><br><span class="line">  message_history_limit: 50</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">  type: LOCALIZATION</span><br><span class="line">  mode: PUBLISH_ONLY</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">  type: MONITOR</span><br><span class="line">  mode: PUBLISH_ONLY</span><br><span class="line">&#125;</span><br><span class="line">is_ros: true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实例化得到的应该是一个localization_type对象为RTK的LocalizationConfig对象。<br>API对象:</p>
<ul>
<li>LocalizationConfig对象:<figure class="highlight plain"><figcaption><span>mudules/localization/proto/localization_type.proto</span></figcaption><table><tr><td class="code"><pre><span class="line">message LocalizationConfig &#123;</span><br><span class="line">  enum LocalizationType &#123;</span><br><span class="line">    RTK = 0;</span><br><span class="line">    CAMERA = 1;</span><br><span class="line">  &#125;;</span><br><span class="line">  optional LocalizationType localization_type = 1 [default = RTK];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Pose对象<br><figure class="highlight cpp"><figcaption><span>modules/localization/proto/pose.proto</span></figcaption><table><tr><td class="code"><pre><span class="line">message Pose &#123;</span><br><span class="line">  <span class="comment">// Position of the vehicle reference point (VRP) in the map reference frame.</span></span><br><span class="line">  <span class="comment">// The VRP is the center of rear axle.</span></span><br><span class="line">  optional apollo.common.PointENU position = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A quaternion that represents the rotation from the map coordinate</span></span><br><span class="line">  <span class="comment">// (East/North/Up) to the</span></span><br><span class="line">  <span class="comment">// vehicle coordinate (Right/Forward/Up).</span></span><br><span class="line">  optional apollo.common.Quaternion orientation = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linear velocity of the VRP in the map reference frame.</span></span><br><span class="line">  <span class="comment">// East/north/up in meters per second.</span></span><br><span class="line">  optional apollo.common.Point3D linear_velocity = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linear acceleration of the VRP in the map reference frame.</span></span><br><span class="line">  <span class="comment">// East/north/up in meters per second.</span></span><br><span class="line">  optional apollo.common.Point3D linear_acceleration = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Angular velocity of the vehicle in the map reference frame.</span></span><br><span class="line">  <span class="comment">// Around east/north/up axes in radians per second.</span></span><br><span class="line">  optional apollo.common.Point3D angular_velocity = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// heading</span></span><br><span class="line">  optional <span class="keyword">double</span> heading = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linear acceleration of the VRP in the vehicle reference frame.</span></span><br><span class="line">  <span class="comment">// Right/forward/up in meters per square second.</span></span><br><span class="line">  optional apollo.common.Point3D linear_acceleration_vrf = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Angular velocity of the vehicle in the vehicle reference frame.</span></span><br><span class="line">  <span class="comment">// Around right/forward/up axes in radians per second.</span></span><br><span class="line">  <span class="comment">// 车辆在车辆参考系中的角速度,左右/向前/向上轴以弧度/秒为单位。</span></span><br><span class="line">  optional apollo.common.Point3D angular_velocity_vrf = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看基于LocalizationBase的RTKLocalization类，虽然是重新定义的类，但包含的方法基本是Start、Stop等跟节点模块相同的方法，CameraLocalization也继承自这个类。主要看提供了哪些逻辑方法：<br><figure class="highlight cpp"><figcaption><span>mudules/localization/rtk/rtk_localization.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RTKLocalization</span> :</span> <span class="keyword">public</span> LocalizationBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  RTKLocalization();</span><br><span class="line">  <span class="keyword">virtual</span> ~RTKLocalization() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief module start function</span></span><br><span class="line"><span class="comment">   * @return start status</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  apollo::common::<span class="function">Status <span class="title">Start</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief module stop function</span></span><br><span class="line"><span class="comment">   * @return stop status</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  apollo::common::<span class="function">Status <span class="title">Stop</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnTimer</span><span class="params">(<span class="keyword">const</span> ros::TimerEvent &amp;event)</span></span>; <span class="comment">//数据到达，进行一次定位算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PublishLocalization</span><span class="params">()</span></span>; <span class="comment">// 发布 定位结果</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RunWatchDog</span><span class="params">()</span></span>;  <span class="comment">//检查时间合理性，是否延迟过大。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算定位结果</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrepareLocalizationMsg</span><span class="params">(LocalizationEstimate *localization)</span></span>;</span><br><span class="line">  <span class="comment">// 融合GPS、IMU两者的结果</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ComposeLocalizationMsg</span><span class="params">(<span class="keyword">const</span> ::apollo::localization::Gps &amp;gps,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> ::apollo::localization::Imu &amp;imu,</span></span></span><br><span class="line"><span class="function"><span class="params">                              LocalizationEstimate *localization)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FindMatchingIMU</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> gps_timestamp_sec, Imu *imu_msg)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InterpolateIMU</span><span class="params">(<span class="keyword">const</span> Imu &amp;imu1, <span class="keyword">const</span> Imu &amp;imu2,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">double</span> timestamp_sec, Imu *msgbuf)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">T</span> <span class="title">InterpolateXYZ</span>(<span class="title">const</span> <span class="title">T</span> &amp;<span class="title">p1</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">p2</span>, <span class="title">const</span> <span class="title">double</span> &amp;<span class="title">frac1</span>);</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ros::Timer timer_; </span><br><span class="line">  apollo::common::monitor::Monitor monitor_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; map_offset_; <span class="comment">// 地图上的偏移量</span></span><br><span class="line">  <span class="keyword">double</span> last_received_timestamp_sec_ = <span class="number">0.0</span>; <span class="comment">// 接受data的时间</span></span><br><span class="line">  <span class="keyword">double</span> last_reported_timestamp_sec_ = <span class="number">0.0</span>; <span class="comment">// 发布定位的时间</span></span><br><span class="line">  <span class="keyword">bool</span> service_started_ = <span class="literal">false</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定位估算对象<br><figure class="highlight plain"><figcaption><span>modules/localization/proto/localization.proto 定位估算对象定义</span></figcaption><table><tr><td class="code"><pre><span class="line">message LocalizationEstimate &#123;</span><br><span class="line">  optional apollo.common.Header header = 1;</span><br><span class="line">  optional apollo.localization.Pose pose = 2;</span><br><span class="line">  optional Uncertainty uncertainty = 3;</span><br><span class="line"></span><br><span class="line">  // The time of pose measurement, seconds since the GPS epoch (Jan 6, 1980).</span><br><span class="line">  optional double measurement_time = 4;  // In seconds.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>localization模块主要定义了使用RTK-GPS和camera相结合的定位方法，并且融合了IMU传感器。基于图像的定位方法尚未发布。目前Apollo主要采用RKT-GPS并辅助IMU用于车辆定位。</p>
<h3 id="监控模块（Monitor）"><a href="#监控模块（Monitor）" class="headerlink" title="监控模块（Monitor）"></a>监控模块（Monitor）</h3><h3 id="规划模块（Planning）"><a href="#规划模块（Planning）" class="headerlink" title="规划模块（Planning）"></a>规划模块（Planning）</h3><h3 id="CANBUS模块"><a href="#CANBUS模块" class="headerlink" title="CANBUS模块"></a>CANBUS模块</h3><p>Canbus接收并执行控制命令，接受底盘状态作为控制反馈。</p>
<p>输入：控制命令<br>输出：</p>
<ul>
<li>底盘状态</li>
<li>底盘详细信息</li>
</ul>
<p>实现：主要的组件模块有：</p>
<ul>
<li>CAN 端</li>
<li>车辆包含的车辆控制与信息管理</li>
</ul>
<p>初始化方法：</p>
<ul>
<li>读取车辆配置文件</li>
<li>初始化Can端</li>
<li>利用工厂方法创建车辆</li>
<li>消息管理器</li>
<li>初始化CAN发送端</li>
<li>初始化车辆控制器</li>
</ul>
<p>Start方法：</p>
<ol>
<li>初始化并开启can card硬件</li>
<li>开始接受第一个命令</li>
<li>开始发送器</li>
<li>开启车辆控制器</li>
<li>设置监听发布信息</li>
<li>发布监控消息（该模块一开始正常工作）</li>
</ol>
<p>onControlCommand控制消息回调方法</p>
<ul>
<li>通过车辆控制器，更新控制命令，由相应的线控组件做出响应的动作<figure class="highlight cpp"><figcaption><span>apollo/modules/canbus/vehile/vehicle_controller.cc 控制指令的更新</span></figcaption><table><tr><td class="code"><pre><span class="line">ErrorCode VehicleController::Update(<span class="keyword">const</span> ControlCommand &amp;command) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!is_initialized_) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Controller not initialized."</span>;</span><br><span class="line">    <span class="keyword">return</span> ErrorCode::CANBUS_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ControlCommand control_command;</span><br><span class="line">  control_command.CopyFrom(command);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// execute action to tranform driving mode</span></span><br><span class="line">  <span class="keyword">if</span> (control_command.has_pad_msg() &amp;&amp; control_command.pad_msg().has_action()) &#123;</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Canbus received pad msg:"</span></span><br><span class="line">          &lt;&lt; control_command.pad_msg().ShortDebugString();</span><br><span class="line">    Chassis::DrivingMode mode = Chassis::COMPLETE_MANUAL;</span><br><span class="line">    <span class="keyword">switch</span> (control_command.pad_msg().action()) &#123;</span><br><span class="line">      <span class="keyword">case</span> control::DrivingAction::START: &#123;</span><br><span class="line">        mode = params_.driving_mode();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> control::DrivingAction::STOP:</span><br><span class="line">      <span class="keyword">case</span> control::DrivingAction::RESET: &#123;</span><br><span class="line">        mode = Chassis::COMPLETE_MANUAL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        AERROR &lt;&lt; <span class="string">"No response for this action."</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SetDrivingMode(mode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (driving_mode_ == Chassis::COMPLETE_AUTO_DRIVE ||</span><br><span class="line">      driving_mode_ == Chassis::AUTO_SPEED_ONLY) &#123;</span><br><span class="line">    Gear(control_command.gear_location());</span><br><span class="line">    Throttle(control_command.throttle());</span><br><span class="line">    Brake(control_command.brake());</span><br><span class="line">    SetEpbBreak(control_command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (driving_mode_ == Chassis::COMPLETE_AUTO_DRIVE ||</span><br><span class="line">      driving_mode_ == Chassis::AUTO_STEER_ONLY) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> steering_rate_threshold = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (control_command.steering_rate() &gt; steering_rate_threshold) &#123;</span><br><span class="line">      Steer(control_command.steering_target(), control_command.steering_rate());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Steer(control_command.steering_target());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((driving_mode_ == Chassis::COMPLETE_AUTO_DRIVE ||</span><br><span class="line">       driving_mode_ == Chassis::AUTO_SPEED_ONLY ||</span><br><span class="line">       driving_mode_ == Chassis::AUTO_STEER_ONLY) &amp;&amp;</span><br><span class="line">      control_command.has_signal()) &#123;</span><br><span class="line">    SetHorn(control_command);</span><br><span class="line">    SetTurningSignal(control_command);</span><br><span class="line">    SetBeam(control_command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ErrorCode::OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Real_Time_Kinematic" target="_blank" rel="noopener">Real_Time_Kinematic</a> </li>
<li><a href="https://baike.baidu.com/item/RTK" target="_blank" rel="noopener">RTK（Real - time kinematic）载波相位差分技术</a> </li>
</ul>


<!--<a href="http://yoursite.com/apollo/from_apollo_main_macro_to_all_modules.html#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'mickeyouyou'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</body>
</html>