<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title></title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>


<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 class="title"></h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年12月19日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HASHTABLE相关概念"><span class="toc-text"><a href="#HASHTABLE&#x76F8;&#x5173;&#x6982;&#x5FF5;" class="headerlink" title="HASHTABLE&#x76F8;&#x5173;&#x6982;&#x5FF5;"></a>HASHTABLE&#x76F8;&#x5173;&#x6982;&#x5FF5;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hash-function"><span class="toc-text"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链接法"><span class="toc-text"><a href="#&#x94FE;&#x63A5;&#x6CD5;" class="headerlink" title="&#x94FE;&#x63A5;&#x6CD5;"></a>&#x94FE;&#x63A5;&#x6CD5;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开放寻址法"><span class="toc-text"><a href="#&#x5F00;&#x653E;&#x5BFB;&#x5740;&#x6CD5;" class="headerlink" title="&#x5F00;&#x653E;&#x5BFB;&#x5740;&#x6CD5;"></a>&#x5F00;&#x653E;&#x5BFB;&#x5740;&#x6CD5;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HASHTABLE的简单实现"><span class="toc-text"><a href="#HASHTABLE&#x7684;&#x7B80;&#x5355;&#x5B9E;&#x73B0;" class="headerlink" title="HASHTABLE&#x7684;&#x7B80;&#x5355;&#x5B9E;&#x73B0;"></a>HASHTABLE&#x7684;&#x7B80;&#x5355;&#x5B9E;&#x73B0;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-text"><a href="#&#x6570;&#x636E;&#x7ED3;&#x6784;" class="headerlink" title="&#x6570;&#x636E;&#x7ED3;&#x6784;"></a>&#x6570;&#x636E;&#x7ED3;&#x6784;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希函数实现"><span class="toc-text"><a href="#&#x54C8;&#x5E0C;&#x51FD;&#x6570;&#x5B9E;&#x73B0;" class="headerlink" title="&#x54C8;&#x5E0C;&#x51FD;&#x6570;&#x5B9E;&#x73B0;"></a>&#x54C8;&#x5E0C;&#x51FD;&#x6570;&#x5B9E;&#x73B0;</span></a></li></ol></li></ol>
<p>文档的引用</p>
<ul>
<li><p><a href="https://github.com/reeze/tipi/blob/master/book/chapt03/03-01-01-hashtable.markdown" target="_blank" rel="noopener">https://github.com/reeze/tipi/blob/master/book/chapt03/03-01-01-hashtable.markdown</a></p>
<h1 id="HASHTABLE相关概念"><a href="#HASHTABLE相关概念" class="headerlink" title="HASHTABLE相关概念"></a>HASHTABLE相关概念</h1><ul>
<li>键(key)：用于操作数据的标示，例如PHP数组中的索引，或者字符串键等。</li>
<li>槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li>
<li>哈希函数(hash function)：将key映射(map)到数据应该存放的slot所在位置的函数。</li>
<li>哈希冲突(hash collision)：哈希函数将两个不同的key映射到同一个索引的情况。</li>
</ul>
</li>
</ul>
<h1 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h1><p>HASH_INDEX(ht, key) (hash_str((key)) % (ht)-&gt;size)</p>
<p>解决哈希冲突的两种方法</p>
<h1 id="链接法"><a href="#链接法" class="headerlink" title="链接法"></a>链接法</h1><p>链接法通过使用一个链表来保存slot值的方式来解决冲突，也就是当不同的key映射到一个槽中的时候使用链表来保存这些值。 所以使用链接法是在最坏的情况下，也就是所有的key都映射到同一个槽中了，这样哈希表就退化成了一个链表， 这样的话操作链表的时间复杂度则成了O(n)，这样哈希表的性能优势就没有了， 所以选择一个合适的哈希函数是最为关键的。</p>
<p>由于目前大部分的编程语言的哈希表实现都是开源的，大部分语言的哈希算法都是公开的算法， 虽然目前的哈希算法都能良好的将key进行比较均匀的分布，而这个假使的前提是key是随机的，正是由于算法的确定性， 这就导致了别有用心的黑客能利用已知算法的可确定性来构造一些特殊的key，让这些key都映射到 同一个槽位导致哈希表退化成单链表，导致程序的性能急剧下降，从而造成一些应用的吞吐能力急剧下降， 尤其是对于高并发的应用影响很大，通过大量类似的请求可以让服务器遭受DoS(服务拒绝攻击)， 这个问题一直就存在着，只是最近才被各个语言重视起来。</p>
<p>哈希冲突攻击利用的哈希表最根本的弱点是：开源算法和哈希实现的确定性以及可预测性， 这样攻击者才可以利用特殊构造的key来进行攻击。要解决这个问题的方法则是让攻击者无法轻易构造 能够进行攻击的key序列。</p>
<p>NOTE 在笔者编写这节内容的时候PHP语言也采取了相应的措施来防止这类的攻击，PHP采用的是一种 治标不治本的做法: 限制用户提交数据字段数量 这样可以避免大部分的攻击，不过应用程序通常会有很多的数据输入方式，比如，SOAP，REST等等， 比如很多应用都会接受用户传入的JSON字符串，在执行json_decode()的时候也可能会遭受攻击。 所以最根本的解决方法是让哈希表的碰撞key序列无法轻易的构造，目前PHP中还没有引入不增加额外的复杂性情况下的完美解决方案。<br>目前PHP中HashTable的哈希冲突解决方法就是链接法。</p>
<h1 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h1><p>通常还有另外一种解决冲突的方法：开放寻址法。使用开放寻址法是槽本身直接存放数据， 在插入数据时如果key所映射到的索引已经有数据了，这说明发生了冲突，这是会寻找下一个槽， 如果该槽也被占用了则继续寻找下一个槽，直到寻找到没有被占用的槽，在查找时也使用同样的策略来进行。</p>
<p>由于开放寻址法处理冲突的时候占用的是其他槽位的空间,这可能会导致后续的key在插入的时候更加容易出现 哈希冲突，所以采用开放寻址法的哈希表的装载因子不能太高，否则容易出现性能下降。</p>
<p>NOTE 装载因子是哈希表保存的元素数量和哈希表容量的比，通常采用链接法解决冲突的哈希表的装载 因子最好不要大于1，而采用开放寻址法的哈希表最好不要大于0.5。</p>
<h1 id="HASHTABLE的简单实现"><a href="#HASHTABLE的简单实现" class="headerlink" title="HASHTABLE的简单实现"></a>HASHTABLE的简单实现</h1><p>在了解到哈希表的原理之后要实现一个哈希表也很容易，主要需要完成的工作只有三点：</p>
<ul>
<li>实现哈希函数</li>
<li>冲突的解决</li>
<li>操作接口的实现</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先我们需要一个容器来保存我们的哈希表，哈希表需要保存的内容主要是保存进来的的数据， 同时为了方便的得知哈希表中存储的元素个数，需要保存一个大小字段， 第二个需要的就是保存数据的容器了。作为实例，下面将实现一个简易的哈希表。基本的数据结构主要有两个， 一个用于保存哈希表本身，另外一个就是用于实际保存数据的单链表了，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> elem_num;</span><br><span class="line">    Bucket** buckets;</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<p>上面的定义和PHP中的实现类似，为了便于理解裁剪了大部分无关的细节，在本节中为了简化， key的数据类型为字符串，而存储的数据类型可以为任意类型。</p>
<p>Bucket结构体是一个单链表，这是为了解决多个key哈希冲突的问题，也就是前面所提到的的链接法。 当多个key映射到同一个index的时候将冲突的元素链接起来。</p>
<h2 id="哈希函数实现"><a href="#哈希函数实现" class="headerlink" title="哈希函数实现"></a>哈希函数实现</h2><p>哈希函数需要尽可能的将不同的key映射到不同的槽(slot或者bucket)中，首先我们采用一种最为简单的哈希算法实现： 将key字符串的所有字符加起来，然后以结果对哈希表的大小取模，这样索引就能落在数组索引的范围之内了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash_str</span><span class="params">(<span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *cur = key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*cur != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        hash += *cur;</span><br><span class="line">        ++cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个宏来求得key在哈希表中的索引</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_INDEX(ht, key) (hash_str((key)) % (ht)-&gt;size)</span></span><br></pre></td></tr></table></figure>
<p>这个哈希算法比较简单，它的效果并不好，在实际场景下不会使用这种哈希算法， 例如PHP中使用的是称为DJBX33A算法， 这里列举了Mysql，OpenSSL等开源软件使用的哈希算法， 有兴趣的读者可以前往参考。</p>
<p>有兴趣的读者可以运行本小节实现的哈希表实现,在输出日志中将看到很多的哈希冲突, 这是本例中使用的哈希算法过于简单造成的.</p>
<p>hashtable.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HASH_TABLE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HASH_TABLE_H_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_TABLE_INIT_SIZE 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_INDEX(ht, key) (hash_str((key)) % (ht)-&gt;size)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> LOG_MSG printf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> LOG_MSG(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAILED -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;       <span class="comment">// 哈希表的大小</span></span><br><span class="line">    <span class="keyword">int</span> elem_num;   <span class="comment">// 已经保存元素的个数</span></span><br><span class="line">    Bucket **buckets;</span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_init</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_lookup</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *key, <span class="keyword">void</span> **result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_insert</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *key, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_remove</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_destroy</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>hashtable.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hashtable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resize_hash_table_if_needed</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash_str</span><span class="params">(<span class="keyword">char</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_init</span><span class="params">(HashTable *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ht-&gt;size        = HASH_TABLE_INIT_SIZE;</span><br><span class="line">    ht-&gt;elem_num    = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;buckets     = (Bucket **)<span class="built_in">calloc</span>(ht-&gt;size, <span class="keyword">sizeof</span>(Bucket *));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ht-&gt;buckets == <span class="literal">NULL</span>) <span class="keyword">return</span> FAILED;</span><br><span class="line"></span><br><span class="line">    LOG_MSG(<span class="string">"[init]\tsize: %i\n"</span>, ht-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_lookup</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *key, <span class="keyword">void</span> **result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = HASH_INDEX(ht, key);</span><br><span class="line">    Bucket *bucket = ht-&gt;buckets[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bucket == <span class="literal">NULL</span>) <span class="keyword">goto</span> failed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(bucket-&gt;key, key) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_MSG(<span class="string">"[lookup]\t found %s\tindex:%i value: %p\n"</span>,</span><br><span class="line">                key, index, bucket-&gt;value);</span><br><span class="line">            *result = bucket-&gt;value;    </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bucket = bucket-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">    LOG_MSG(<span class="string">"[lookup]\t key:%s\tfailed\t\n"</span>, key);</span><br><span class="line">    <span class="keyword">return</span> FAILED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_insert</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check if we need to resize the hashtable</span></span><br><span class="line">    resize_hash_table_if_needed(ht);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = HASH_INDEX(ht, key);</span><br><span class="line"></span><br><span class="line">    Bucket *org_bucket = ht-&gt;buckets[index];</span><br><span class="line">    Bucket *tmp_bucket = org_bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if the key exits already</span></span><br><span class="line">    <span class="keyword">while</span>(tmp_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(key, tmp_bucket-&gt;key) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_MSG(<span class="string">"[update]\tkey: %s\n"</span>, key);</span><br><span class="line">            tmp_bucket-&gt;value = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp_bucket = tmp_bucket-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bucket *bucket = (Bucket *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Bucket));</span><br><span class="line"></span><br><span class="line">    bucket-&gt;key   = key;</span><br><span class="line">    bucket-&gt;value = value;</span><br><span class="line">    bucket-&gt;next  = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ht-&gt;elem_num += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(org_bucket != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_MSG(<span class="string">"[collision]\tindex:%d key:%s\n"</span>, index, key);</span><br><span class="line">        bucket-&gt;next = org_bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ht-&gt;buckets[index]= bucket;</span><br><span class="line"></span><br><span class="line">    LOG_MSG(<span class="string">"[insert]\tindex:%d key:%s\tht(num:%d)\n"</span>,</span><br><span class="line">        index, key, ht-&gt;elem_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_remove</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = HASH_INDEX(ht, key);</span><br><span class="line">    Bucket *bucket  = ht-&gt;buckets[index];</span><br><span class="line">    Bucket *prev    = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bucket == <span class="literal">NULL</span>) <span class="keyword">return</span> FAILED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the right bucket from the link list </span></span><br><span class="line">    <span class="keyword">while</span>(bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(bucket-&gt;key, key) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_MSG(<span class="string">"[remove]\tkey:(%s) index: %d\n"</span>, key, index);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(prev == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ht-&gt;buckets[index] = bucket-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = bucket-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(bucket);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev   = bucket;</span><br><span class="line">        bucket = bucket-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_MSG(<span class="string">"[remove]\t key:%s not found remove \tfailed\t\n"</span>, key);</span><br><span class="line">    <span class="keyword">return</span> FAILED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_destroy</span><span class="params">(HashTable *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Bucket *cur = <span class="literal">NULL</span>;</span><br><span class="line">    Bucket *tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; ht-&gt;size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = ht-&gt;buckets[i];</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(ht-&gt;buckets);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> </span><br><span class="line">hash_str(<span class="keyword">char</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *cur = key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*cur != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hash += *cur;</span><br><span class="line">        ++cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash_resize</span><span class="params">(HashTable *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// double the size</span></span><br><span class="line">    <span class="keyword">int</span> org_size = ht-&gt;size;</span><br><span class="line">    ht-&gt;size = ht-&gt;size * <span class="number">2</span>;</span><br><span class="line">    ht-&gt;elem_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LOG_MSG(<span class="string">"[resize]\torg size: %i\tnew size: %i\n"</span>, org_size, ht-&gt;size);</span><br><span class="line"></span><br><span class="line">    Bucket **buckets = (Bucket **)<span class="built_in">calloc</span>(ht-&gt;size, <span class="keyword">sizeof</span>(Bucket **));</span><br><span class="line"></span><br><span class="line">    Bucket **org_buckets = ht-&gt;buckets;</span><br><span class="line">    ht-&gt;buckets = buckets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; org_size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Bucket *cur = org_buckets[i];</span><br><span class="line">        Bucket *tmp;</span><br><span class="line">        <span class="keyword">while</span>(cur) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// rehash: insert again</span></span><br><span class="line">            hash_insert(ht, cur-&gt;key, cur-&gt;value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// free the org bucket, but not the element</span></span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(org_buckets);</span><br><span class="line"></span><br><span class="line">    LOG_MSG(<span class="string">"[resize] done\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the elem_num is almost as large as the capacity of the hashtable</span></span><br><span class="line"><span class="comment">// we need to resize the hashtable to contain enough elements</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resize_hash_table_if_needed</span><span class="params">(HashTable *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ht-&gt;size - ht-&gt;elem_num &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hash_resize(ht);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hashtable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(tcase) printf(<span class="meta-string">"&gt;&gt;&gt; [START CASE] "</span> tcase <span class="meta-string">"&lt;&lt;&lt;\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASS(tcase) printf(<span class="meta-string">"&gt;&gt;&gt; [PASSED] "</span> tcase <span class="meta-string">" &lt;&lt;&lt;\n"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashTable *ht = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    <span class="keyword">int</span> result = hash_init(ht);</span><br><span class="line"></span><br><span class="line">    assert(result == SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Data */</span></span><br><span class="line">    <span class="keyword">int</span>  int1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>  int2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">"Hello TIPI"</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">"Value"</span>;</span><br><span class="line">    <span class="comment">/* to find data container */</span></span><br><span class="line">    <span class="keyword">int</span> *j = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *find_str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test Key insert */</span></span><br><span class="line">    TEST(<span class="string">"Key insert"</span>);</span><br><span class="line">    hash_insert(ht, <span class="string">"KeyInt"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"asdfKeyStrass"</span>, str1);</span><br><span class="line">    hash_insert(ht, <span class="string">"K13eyStras"</span>, str1);</span><br><span class="line">    hash_insert(ht, <span class="string">"KeyStr5"</span>, str1);</span><br><span class="line">    hash_insert(ht, <span class="string">"KeyStr"</span>, str1);</span><br><span class="line">    PASS(<span class="string">"Key insert"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test key lookup */</span></span><br><span class="line">    TEST(<span class="string">"Key lookup"</span>);</span><br><span class="line">    hash_lookup(ht, <span class="string">"KeyInt"</span>, (<span class="keyword">void</span> **)&amp;j);</span><br><span class="line">    hash_lookup(ht, <span class="string">"KeyStr"</span>, (<span class="keyword">void</span> **)&amp;find_str);</span><br><span class="line"></span><br><span class="line">    assert(<span class="built_in">strcmp</span>(find_str, str1) == <span class="number">0</span>);</span><br><span class="line">    assert(*j = int1);</span><br><span class="line">    PASS(<span class="string">"Key lookup"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test Key update */</span></span><br><span class="line">    TEST(<span class="string">"Test key update"</span>);</span><br><span class="line">    hash_insert(ht, <span class="string">"KeyInt"</span>, &amp;int2);</span><br><span class="line">    hash_lookup(ht, <span class="string">"KeyInt"</span>, (<span class="keyword">void</span> **)&amp;j);</span><br><span class="line">    assert(*j = int2);</span><br><span class="line">    PASS(<span class="string">"Test key update"</span>);</span><br><span class="line"></span><br><span class="line">    TEST(<span class="string">"&gt;&gt;&gt;    Test key not found     &lt;&lt;&lt; "</span>);</span><br><span class="line">    result = hash_lookup(ht, <span class="string">"non-exits-key"</span>, (<span class="keyword">void</span> **)&amp;j);</span><br><span class="line">    assert(result == FAILED);</span><br><span class="line">    PASS(<span class="string">"non-exist-key lookup"</span>);</span><br><span class="line"></span><br><span class="line">    TEST(<span class="string">"Test key not found after remove"</span>);</span><br><span class="line">    <span class="keyword">char</span> strMyKey[] = <span class="string">"My-Key-Value"</span>;</span><br><span class="line">    find_str = <span class="literal">NULL</span>;</span><br><span class="line">    hash_insert(ht, <span class="string">"My-Key"</span>, &amp;strMyKey);</span><br><span class="line">    result = hash_remove(ht, <span class="string">"My-Key"</span>);</span><br><span class="line">    assert(result == SUCCESS);</span><br><span class="line"></span><br><span class="line">    result = hash_lookup(ht, <span class="string">"My-Key"</span>, (<span class="keyword">void</span> **)&amp;find_str);</span><br><span class="line">    assert(find_str == <span class="literal">NULL</span>);</span><br><span class="line">    assert(result == FAILED);</span><br><span class="line">    PASS(<span class="string">"Test key not found after remove"</span>);</span><br><span class="line"></span><br><span class="line">    PASS(<span class="string">"&gt;&gt;&gt;    Test key not found     &lt;&lt;&lt; "</span>);</span><br><span class="line"></span><br><span class="line">    TEST(<span class="string">"Add many elements and make hashtable rehash"</span>);</span><br><span class="line">    hash_insert(ht, <span class="string">"a1"</span>, &amp;int2);</span><br><span class="line">    hash_insert(ht, <span class="string">"a2"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a3"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a4"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a5"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a6"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a7"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a8"</span>, str2);</span><br><span class="line">    hash_insert(ht, <span class="string">"a9"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a10"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a11"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a12"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a13"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a14"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a15"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a16"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a17"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a18"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a19"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a20"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a21"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a22"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a23"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a24"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a24"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a24"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a25"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a26"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a27"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a28"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a29"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a30"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a31"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a32"</span>, &amp;int1);</span><br><span class="line">    hash_insert(ht, <span class="string">"a33"</span>, &amp;int1);</span><br><span class="line"></span><br><span class="line">    hash_lookup(ht, <span class="string">"a23"</span>, (<span class="keyword">void</span> **)&amp;j);</span><br><span class="line">    assert(*j = int1);</span><br><span class="line">    hash_lookup(ht, <span class="string">"a30"</span>, (<span class="keyword">void</span> **)&amp;j);</span><br><span class="line">    assert(*j = int1);</span><br><span class="line">    PASS(<span class="string">"Add many elements and make hashtable rehash"</span>);</span><br><span class="line"></span><br><span class="line">    hash_destroy(ht);</span><br><span class="line">    <span class="built_in">free</span>(ht);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Woohoo, It looks like HashTable works properly\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>


<!--<a href="http://yoursite.com/flow/工作日常笔记.html#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'mickeyouyou'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div>




<img src="https://dn-coding-net-production-static.qbox.me/static/3c014d76335271b74510d8857e2f7892.png" width="50px"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>