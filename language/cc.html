<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>cpp in action</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=4.2" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	   <link rel="shortcut icon" type="image/x-icon" href="/rocket_128px_1215034_easyicon.net.ico?v=4.2"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>


<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 class="title">cpp in action</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年8月15日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#cout"><span class="toc-text"><a href="#cout" class="headerlink" title="cout"></a>cout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#endl"><span class="toc-text"><a href="#endl" class="headerlink" title="endl"></a>endl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么main-不能使用其他名称"><span class="toc-text"><a href="#&#x4E3A;&#x4EC0;&#x4E48;main-&#x4E0D;&#x80FD;&#x4F7F;&#x7528;&#x5176;&#x4ED6;&#x540D;&#x79F0;" class="headerlink" title="&#x4E3A;&#x4EC0;&#x4E48;main()&#x4E0D;&#x80FD;&#x4F7F;&#x7528;&#x5176;&#x4ED6;&#x540D;&#x79F0;"></a>&#x4E3A;&#x4EC0;&#x4E48;main()&#x4E0D;&#x80FD;&#x4F7F;&#x7528;&#x5176;&#x4ED6;&#x540D;&#x79F0;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-预处理器和iostream文件"><span class="toc-text"><a href="#C-&#x9884;&#x5904;&#x7406;&#x5668;&#x548C;iostream&#x6587;&#x4EF6;" class="headerlink" title="C++&#x9884;&#x5904;&#x7406;&#x5668;&#x548C;iostream&#x6587;&#x4EF6;"></a>C++&#x9884;&#x5904;&#x7406;&#x5668;&#x548C;iostream&#x6587;&#x4EF6;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#头文件"><span class="toc-text"><a href="#&#x5934;&#x6587;&#x4EF6;" class="headerlink" title="&#x5934;&#x6587;&#x4EF6;"></a>&#x5934;&#x6587;&#x4EF6;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名空间"><span class="toc-text"><a href="#&#x547D;&#x540D;&#x7A7A;&#x95F4;" class="headerlink" title="&#x547D;&#x540D;&#x7A7A;&#x95F4;"></a>&#x547D;&#x540D;&#x7A7A;&#x95F4;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量声明"><span class="toc-text"><a href="#&#x53D8;&#x91CF;&#x58F0;&#x660E;" class="headerlink" title="&#x53D8;&#x91CF;&#x58F0;&#x660E;"></a>&#x53D8;&#x91CF;&#x58F0;&#x660E;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象编程（OOP）的本质"><span class="toc-text"><a href="#&#x9762;&#x5411;&#x5BF9;&#x8C61;&#x7F16;&#x7A0B;&#xFF08;OOP&#xFF09;&#x7684;&#x672C;&#x8D28;" class="headerlink" title="&#x9762;&#x5411;&#x5BF9;&#x8C61;&#x7F16;&#x7A0B;&#xFF08;OOP&#xFF09;&#x7684;&#x672C;&#x8D28;"></a>&#x9762;&#x5411;&#x5BF9;&#x8C61;&#x7F16;&#x7A0B;&#xFF08;OOP&#xFF09;&#x7684;&#x672C;&#x8D28;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整型"><span class="toc-text"><a href="#&#x6574;&#x578B;" class="headerlink" title="&#x6574;&#x578B;"></a>&#x6574;&#x578B;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#位（bit）与字节-byte"><span class="toc-text"><a href="#&#x4F4D;&#xFF08;bit&#xFF09;&#x4E0E;&#x5B57;&#x8282;-byte" class="headerlink" title="&#x4F4D;&#xFF08;bit&#xFF09;&#x4E0E;&#x5B57;&#x8282;(byte)"></a>&#x4F4D;&#xFF08;bit&#xFF09;&#x4E0E;&#x5B57;&#x8282;(byte)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运算符sizeof和limits"><span class="toc-text"><a href="#&#x8FD0;&#x7B97;&#x7B26;sizeof&#x548C;limits" class="headerlink" title="&#x8FD0;&#x7B97;&#x7B26;sizeof&#x548C;limits"></a>&#x8FD0;&#x7B97;&#x7B26;sizeof&#x548C;limits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量初始化"><span class="toc-text"><a href="#&#x53D8;&#x91CF;&#x521D;&#x59CB;&#x5316;" class="headerlink" title="&#x53D8;&#x91CF;&#x521D;&#x59CB;&#x5316;"></a>&#x53D8;&#x91CF;&#x521D;&#x59CB;&#x5316;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择整型类型"><span class="toc-text"><a href="#&#x9009;&#x62E9;&#x6574;&#x578B;&#x7C7B;&#x578B;" class="headerlink" title="&#x9009;&#x62E9;&#x6574;&#x578B;&#x7C7B;&#x578B;"></a>&#x9009;&#x62E9;&#x6574;&#x578B;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整型字面值"><span class="toc-text"><a href="#&#x6574;&#x578B;&#x5B57;&#x9762;&#x503C;" class="headerlink" title="&#x6574;&#x578B;&#x5B57;&#x9762;&#x503C;"></a>&#x6574;&#x578B;&#x5B57;&#x9762;&#x503C;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整型溢出"><span class="toc-text"><a href="#&#x6574;&#x578B;&#x6EA2;&#x51FA;" class="headerlink" title="&#x6574;&#x578B;&#x6EA2;&#x51FA;"></a>&#x6574;&#x578B;&#x6EA2;&#x51FA;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型别名"><span class="toc-text"><a href="#&#x7C7B;&#x578B;&#x522B;&#x540D;" class="headerlink" title="&#x7C7B;&#x578B;&#x522B;&#x540D;"></a>&#x7C7B;&#x578B;&#x522B;&#x540D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef"><span class="toc-text"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-text"><a href="#auto" class="headerlink" title="auto"></a>auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-中既然已经有命名空间，为何还有include？"><span class="toc-text"><a href="#C-&#x4E2D;&#x65E2;&#x7136;&#x5DF2;&#x7ECF;&#x6709;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#xFF0C;&#x4E3A;&#x4F55;&#x8FD8;&#x6709;include&#xFF1F;" class="headerlink" title="C++&#x4E2D;&#x65E2;&#x7136;&#x5DF2;&#x7ECF;&#x6709;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#xFF0C;&#x4E3A;&#x4F55;&#x8FD8;&#x6709;include&#xFF1F;"></a>C++&#x4E2D;&#x65E2;&#x7136;&#x5DF2;&#x7ECF;&#x6709;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#xFF0C;&#x4E3A;&#x4F55;&#x8FD8;&#x6709;include&#xFF1F;</span></a></li></ol>
<blockquote>
<p>基于C++ 11，《C++ Primer Plus》</p>
</blockquote>
<p><img src="https://www.gitbook.com/cover/book/shenjun/c-primer-plus.jpg?build=1485161771202" width="50%"></p>
<h4 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h4><p>预定义对象，显示字符串、数字、单个字符等通过插入运算符”&lt;&lt;“插入到输出流中。<br>相似的，wcount, cin, wcin是相似之意。</p>
<h4 id="endl"><a href="#endl" class="headerlink" title="endl"></a>endl</h4><p>特殊的C++符号，标识一个重要的概念，重启一行</p>
<h4 id="为什么main-不能使用其他名称"><a href="#为什么main-不能使用其他名称" class="headerlink" title="为什么main()不能使用其他名称"></a>为什么main()不能使用其他名称</h4><p>CPP程序必须包含一个名为main()的函数，在编译运行时，从main()开始执行，如果没有main()编译器将指出未定义main()函数。</p>
<h4 id="C-预处理器和iostream文件"><a href="#C-预处理器和iostream文件" class="headerlink" title="C++预处理器和iostream文件"></a>C++预处理器和iostream文件</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  // 预处理器指向</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p>程序在进行主编译之前，对源文件处理，即处理名称以”#“开头的编译指令。不必执行任何特殊的操作来调用该预处理器，它会在编译程序时自动运行。</p>
<figure class="highlight cpp"><figcaption><span>预处理器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostram&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该编译指令导致预处理器将iostream文件的内容添加到程序中，这是一种典型的预处理操作：在源代码被编译之前，替换或添加文本。要使用iostream中提供的cin, cout等对象，就需要对iosteam做预处理。</p>
<p>实际上，iostream文件的内容将取代程序中的预处理代码行<code>#include &lt;iostream&gt;</code>。原始文件没有被修改，而是将源代码文件和iostream组合成一个复合文件，编译的下一个阶段将使用该文件。</p>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>C++去掉了扩展名<code>*.h</code>，没有扩展名。</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>解决多个代码包的使用问题，使用using关键字区分。</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>为什么变量必须声明？<br>使用一个变量前必须声明它，这意味着它将导致编译器为变量分配内存空间。在C或者Pascal中，所有的变量声明通常位于函数或者过程的开始位置，C++中并没有这种限制，通常的做法是，在首次使用变量前声明它即可。</p>
<p><strong>函数原型与函数定义</strong></p>
<p>原型只是描述函数接口，他描述的是发送给函数的信息和返回的信息。而定义中包含了函数的实现代码。<br>应在首次使用函数之前提供其原型。</p>
<figure class="highlight cpp"><figcaption><span>函数原型与函数定义</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simon</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 使用前指定函数原型，分号结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    simon(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    simon(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">simon(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Simon says your toes "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="面向对象编程（OOP）的本质"><a href="#面向对象编程（OOP）的本质" class="headerlink" title="面向对象编程（OOP）的本质"></a>面向对象编程（OOP）的本质</h4><p>面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>没有小数点的数字，不同C++整数使用不同内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。术语<code>宽度（width）</code>用于描述存储整数时使用的内存量。使用的内存越多，则越宽。C++的基本整型（按宽度递增排序）：<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code> 和C++ 11 新增的<code>long long</code>，每个类型都有符号版本，和无符号版本。因此共有十种整型可供选择。由于char类型有一些特殊属性，（他最常用来表示字符，而不是数字），因此先介绍其他类型。</p>
<ul>
<li><code>short</code> 至少16位</li>
<li><code>int</code> 至少与short一样长</li>
<li><code>long</code> 至少32位，且至少与int一样长</li>
<li><code>long long</code> 至少64位，且至少与long一样长</li>
</ul>
<h4 id="位（bit）与字节-byte"><a href="#位（bit）与字节-byte" class="headerlink" title="位（bit）与字节(byte)"></a>位（bit）与字节(byte)</h4><p>计算机内存的基本单元是位（bit）。可以将位看作电子开关，关表示0，开表示1。8位的内存块可以设置出256种不同的组合，因为每一位都有两种设置，所以8位的总组合数为<code>2*2*2*2*2*2*2*2</code>，即256。因此，8位单元可以表示0-255或者-128~127。</p>
<p>字节（byte）通常指的是8位的内存单位。从这个意义上说，字节指的是描述计算机内存量的度量单位，1KB=1024字节，1MB等于1024KB。然而，C++对字节的定义与此不同。C++字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说，可能取值的数目必须等于或超过字符数目。</p>
<p>如何检查系统中整型的最大长度？使用C++工具，<code>sizeof</code>运算符返回类型或变量长度，单位为字节（运算符是内置的语言元素，对一个或多个数据进行运算，并生产一个值）。前面说过，”字节“的含义依赖与实现，因此在一个系统中，两字节的int可能是16位，而在另一个系统中可能是32位。其次，头文件climits（在老式实现中为limits.h）中包含了关于整型限制的信息。具体的说，它定义了各种限制的符号名称。如INT_MAX为int的最大取值，CHAR_BIT为字节的位数。</p>
<figure class="highlight cpp"><figcaption><span>检查系统中整型的长度范围</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">limits()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n_int = INT_MAX;</span><br><span class="line">    <span class="keyword">short</span> n_short = SHRT_MAX;</span><br><span class="line">    <span class="keyword">long</span> n_long = LONG_MAX;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n_llong = LONG_LONG_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size of oprator yield size of type or of variable</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"short int is "</span> &lt;&lt; <span class="keyword">sizeof</span>(n_short)  &lt;&lt; <span class="string">"bytes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int is "</span> &lt;&lt; <span class="keyword">sizeof</span>(n_int)  &lt;&lt; <span class="string">"bytes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long int is "</span> &lt;&lt; <span class="keyword">sizeof</span>(n_long)  &lt;&lt; <span class="string">"bytes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"longlong int is "</span> &lt;&lt; <span class="keyword">sizeof</span>(n_llong)  &lt;&lt; <span class="string">"bytes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"maximum values :"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"short :"</span> &lt;&lt; n_short &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int :"</span> &lt;&lt; n_int &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long : "</span>  &lt;&lt; n_long &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long long :"</span> &lt;&lt; n_llong &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"minimum int values :"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"short :"</span> &lt;&lt; SHRT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int :"</span> &lt;&lt; INT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long : "</span>  &lt;&lt; LONG_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long long :"</span> &lt;&lt; LONG_LONG_MIN &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">short int is 2bytes</span><br><span class="line">int is 4bytes</span><br><span class="line">long int is 8bytes</span><br><span class="line">longlong int is 8bytes</span><br><span class="line"></span><br><span class="line">maximum values :</span><br><span class="line">int :2147483647</span><br><span class="line">short :32767</span><br><span class="line">long : 9223372036854775807</span><br><span class="line">long long :9223372036854775807</span><br><span class="line"></span><br><span class="line">minimum int values :</span><br><span class="line">int :-2147483648</span><br><span class="line">short :-32768</span><br><span class="line">long : -9223372036854775808</span><br><span class="line">long long :-9223372036854775808</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>
<h4 id="运算符sizeof和limits"><a href="#运算符sizeof和limits" class="headerlink" title="运算符sizeof和limits"></a>运算符sizeof和limits</h4><p>sizeof 运算符指出，在使用8位字节的系统中，int的长度为4字节。括号可选。</p>
<p>头文件climits定义了符号常量：<br><figure class="highlight cpp"><figcaption><span>limits.h 各整形长度</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_BIT    8       <span class="comment">/* number of bits in a char */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_LEN_MAX  6       <span class="comment">/* Allow 31 bit UTF2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHAR_MAX   127     <span class="comment">/* min value for a signed char */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHAR_MIN   (-128)      <span class="comment">/* max value for a signed char */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCHAR_MAX   255     <span class="comment">/* max value for an unsigned char */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_MAX    127     <span class="comment">/* max value for a char */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_MIN    (-128)      <span class="comment">/* min value for a char */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USHRT_MAX   65535       <span class="comment">/* max value for an unsigned short */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHRT_MAX    32767       <span class="comment">/* max value for a short */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHRT_MIN    (-32768)    <span class="comment">/* min value for a short */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT_MAX    0xffffffff  <span class="comment">/* max value for an unsigned int */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX     2147483647  <span class="comment">/* max value for an int */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN     (-2147483647-1) <span class="comment">/* min value for an int */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULONG_MAX   0xffffffffffffffffUL    <span class="comment">/* max unsigned long */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LONG_MAX    0x7fffffffffffffffL <span class="comment">/* max signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LONG_MIN    (-0x7fffffffffffffffL-1) <span class="comment">/* min signed long */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ULLONG_MAX  0xffffffffffffffffULL   <span class="comment">/* max unsigned long long */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLONG_MAX   0x7fffffffffffffffLL    <span class="comment">/* max signed long long */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLONG_MIN   (-0x7fffffffffffffffLL-1) <span class="comment">/* min signed long long */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LONG_BIT    64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LONG_BIT    32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SSIZE_MAX   LONG_MAX    <span class="comment">/* max value for a ssize_t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_BIT    32</span></span><br></pre></td></tr></table></figure></p>
<h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>变量初始化的三种方式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> owls = <span class="number">101</span>; <span class="comment">// 来自C语言</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wrens</span><span class="params">(<span class="number">432</span>)</span></span>; <span class="comment">// C++方式</span></span><br><span class="line"><span class="keyword">int</span> hamburgers = &#123;<span class="number">24</span>&#125;; <span class="comment">//C++11初始化方式，用于数组或结构，也可用于单值变量</span></span><br></pre></td></tr></table></figure></p>
<p>C++11初始化方式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">2</span>&#125;;<span class="comment">//a=2</span></span><br><span class="line"><span class="keyword">int</span> b = &#123;<span class="number">3</span>&#125;;<span class="comment">//b=3</span></span><br><span class="line"><span class="keyword">int</span> c&#123;&#125;;<span class="comment">//c=0</span></span><br><span class="line"><span class="keyword">int</span> d = &#123;&#125;;<span class="comment">//d=0</span></span><br></pre></td></tr></table></figure></p>
<p>C++11使大括号初始化器用于任何类型（可以使用等号，也可以不使用），这是一种通用的初始化语法。</p>
<h4 id="选择整型类型"><a href="#选择整型类型" class="headerlink" title="选择整型类型"></a>选择整型类型</h4><ul>
<li>int被设置为目标计算机的自然长度（natural size，指的是计算机处理起来效率最高的长度）</li>
<li>如果没有非常有说服力的理由，则选择int</li>
<li>如果变量表示的值不可能为负，则使用无符号类型</li>
<li>如果知道可能表示的整数值大于16位证书的额最大可能值，则使用long</li>
<li>如果存储的值超过20亿，则使用long long</li>
<li>当有大型整型数组或节省内存很重要时才使用short</li>
</ul>
<h4 id="整型字面值"><a href="#整型字面值" class="headerlink" title="整型字面值"></a>整型字面值</h4><ul>
<li>十进制：第一位是1~9</li>
<li>八进制：第一位是0</li>
<li>十六进制：前两位是0x或0X</li>
<li>虽然有不同的表示方式，但是都将以相同的方式（二进制数） 存储在计算机中</li>
<li>控制符oct或hex，实际上是一条消息，告诉cout采取何种行为</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//输出八进制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;oct</span><br><span class="line"> &lt;&lt;a;</span><br><span class="line"><span class="comment">//输出十六进制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;hex</span><br><span class="line"> &lt;&lt;a;</span><br></pre></td></tr></table></figure>
<h4 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> sam = SHRT_MAX;</span><br></pre></td></tr></table></figure>
<p>对sam + 1,其值超过最大值32767,变成-32768,这些整型变量的行为就像里程表，如果超越了限制，其值将为范围的另一端的取值。C++确保了无符号类型的这种行为；但C++并不保证符号整型超越限制（上溢和下溢）时不出错，而这正是当前实现中最为常见的行为。<br><img src="http://img.blog.csdn.net/20150809182722960"></p>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名，C++为类型建立别名的方式有两种，一种是使用预处理器：<br><figure class="highlight cpp"><figcaption><span>预处理器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTE char</span></span><br></pre></td></tr></table></figure></p>
<p>这样预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名。</p>
<h4 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h4><p>第二种方法是使用C++的关键字<code>typedef</code> 来创建别名。例如，要将byte作为char的别名，可以这样做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> byte;</span><br><span class="line"><span class="comment">// 下面是通用格式：</span></span><br><span class="line"><span class="keyword">typedef</span> typeName aliasName</span><br></pre></td></tr></table></figure>
<p>换句话说，如果要将aliasName作为某种类型的别名，可以声明aliasName，如同将aliasName声明为这种类型的变量那样，然后在声明的前面加上关键字typedef。例如，要让byte_poiter成为char指针的别名,可将byte_poiter声明为char指针，然后在前面加上typedef:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type <span class="keyword">char</span> * byte_poiter; <span class="comment">// 指向char的指针</span></span><br></pre></td></tr></table></figure>
<p>尽管预处理器也能做同样的事情，但是在声明一系列变量时，并不适用。如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAT_POITER float *;</span></span><br><span class="line">FLOAT_POITER pa, pb;</span><br></pre></td></tr></table></figure></p>
<p>预处理器置换将该声明转换为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> * pa, pb;<span class="comment">// pa 指向浮点数的指针，而pb只是一个浮点数。</span></span><br></pre></td></tr></table></figure></p>
<p>typedef就不会有这样的问题。相比#define，适用typedef是一种更佳的选择，有时候也是唯一的选择。</p>
<p>注意：typedef不会创建新类型，而只是为已有的类型建立一个新名称。如果将word作为int的别名，则cout将把word类型的值视为int型。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>auto关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>
<p>auto可以在声明变量时根据变量初始值的类型自动为此变量选择匹配的类型。C++语言类似的关键字还有decltype。<br>举例：对于值x=1；即可以声明：int x = 1或long x = 1，也可以直接声明auto x = 1。<br>其它语言的类似功能包括C#的var关键字。</p>
<p>根据初始化表达式自动推断被声明的变量的类型，如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="keyword">auto</span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">'r'</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure></p>
<p>但是，这么简单的变量声明类型，不建议用auto关键字，而是应更清晰地直接写出其类型。<br>auto关键字更适用于类型冗长复杂、变量使用范围专一时，使程序更清晰易读：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect; </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> it = vect.begin(); it != vect.end(); ++it)</span><br><span class="line"> &#123;  <span class="comment">//it的类型是std::vector&lt;int&gt;::iterator</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; *it;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>或者保存lambda表达式类型的变量声明：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = [](<span class="keyword">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;;<span class="comment">//类型为std::function&lt;double(double)&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>函数对象<br>在模板函数定义时，如果变量的类型依赖于模板参数，使用auto关键字使得在编译期确定这些类型，如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">U</span>&gt;<span class="title">void</span> <span class="title">Multiply</span>(<span class="title">T</span> <span class="title">t</span>, <span class="title">U</span> <span class="title">u</span>)</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">      <span class="keyword">auto</span> v = t * u;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;v;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>模板函数的返回类型如果也是依赖于从模板参数推导，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"> auto multiply(_Tx v1, _Ty v2) -&gt; decltype( _Tx * _Ty )</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">return</span> v1*v2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">auto</span> result = multiply(<span class="number">101</span>, <span class="number">1.414</span>); <span class="comment">// 结果类型是double</span></span><br></pre></td></tr></table></figure></p>
<p>参考 <a href="https://zh.wikipedia.org/wiki/Auto_(C%2B%2B" target="_blank" rel="noopener">Auto (C++)</a>)</p>
<h4 id="C-中既然已经有命名空间，为何还有include？"><a href="#C-中既然已经有命名空间，为何还有include？" class="headerlink" title="C++中既然已经有命名空间，为何还有include？"></a>C++中既然已经有命名空间，为何还有include？</h4><p>代码库中会有很多这样的include，但其实Apollo的代码都是以命名空间的当时包起来的，为什么还会有这样的包含呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"modules/canbus/can_client/fake/fake_can_client.h"</span></span></span><br></pre></td></tr></table></figure>
<p>其实你发现主要是头文件的包含，cc文件是没有被包含进来的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CivetServer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gflags/gflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"google/protobuf/util/json_util.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"modules/common/log.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"modules/common/time/time.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"modules/dreamview/backend/simulation_world_service.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"modules/dreamview/backend/websocket.h"</span></span></span><br></pre></td></tr></table></figure>
<p>但问题的还没被解释清楚，头文件中依然有命名空间定义。</p>
<p>TODO<br>类的继承，公开访问属性的定义，类内部方法的调用，继承方法的重写</p>
<p>“emplace_back” 和 “push_back” 的区别<br>emplace_back和push_back都是向容器内添加数据.<br>对于在容器中添加类的对象时, 相比于push_back,emplace_back可以避免额外类的复制和移动操作.<br><a href="http://blog.csdn.net/caroline_wendy/article/details/12967193" target="_blank" rel="noopener">C++ - “emplace_back” 和 “push_back” 的区别</a></p>


  
    <div class="comments" id="comments">
      
        <div onclick="showGitment()" id="gitment-display-button">如果你有不同看法？</div>
        <div id="gitment-container" style="display:none"></div>
      
    </div>
  

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div>




    
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    



      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname, 
            owner: 'mickeyouyou',
            repo: 'blog_comment',
            
            lang: "en" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '27804beebc0d0aa2ae7271191fd5adac6d1b8cb7',
            
                client_id: '57e78fbfba943c338437'
            }});
        gitment.render('gitment-container');
      }

      
          function showGitment(){
            document.getElementById("gitment-display-button").style.display = "none";
            document.getElementById("gitment-container").style.display = "block";
            renderGitment();
          }
      
      </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    




</body>
</html>