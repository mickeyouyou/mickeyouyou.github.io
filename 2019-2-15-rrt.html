<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>RRT路径规划算法</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/rocket_128px_1215034_easyicon.net.ico?v=3"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>


<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 class="title">RRT路径规划算法</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2019年2月15日




 </div>
--->
</div>


<blockquote>
<p>本文主要引用了博客园（id:XXX已失联）的以RRT（快速查找随机树）文章，参考<a href="https://www.cnblogs.com/21207-iHome/p/7210543.html" target="_blank" rel="noopener">链接</a></p>
</blockquote>
<p>传统的路径规划算法有人工势场法、模糊规则法、遗传算法、神经网络、模拟退火算法、蚁群优化算法等。但这些方法都需要在一个确定的空间内对障碍物进行建模，计算复杂度与机器人自由度呈指数关系，不适合解决多自由度机器人在复杂环境中的规划。基于快速扩展随机树（RRT / rapidly exploring random tree）的路径规划算法，通过对状态空间中的采样点进行碰撞检测，避免了对空间的建模，能够有效地解决高维空间和复杂约束的路径规划问题。该方法的特点是能够快速有效地搜索高维空间，通过状态空间的随机采样点，把搜索导向空白区域，从而寻找到一条从起始点到目标点的规划路径，适合解决多自由度机器人在复杂环境下和动态环境中的路径规划。与PRM类似，该方法是概率完备且不最优的。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/4b1ff580ly1g075efn2gag20br09yx6p.gif"></p>
<p>RRT是一种多维空间中有效率的规划方法。它以一个初始点作为根节点，通过随机采样增加叶子节点的方式，生成一个随机扩展树，当随机树中的叶子节点包含了目标点或进入了目标区域，便可以在随机树中找到一条由从初始点到目标点的路径。基本RRT算法如下面伪代码所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">BuildRRT</span><span class="params">(qinit, K, Δq)</span></span></span><br><span class="line">    T.init(qinit)</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span> to K</span><br><span class="line">        qrand = Sample()  -- chooses a random configuration</span><br><span class="line">        qnearest = Nearest(T, qrand) -- selects the node in the RRT tree that is closest to qrand</span><br><span class="line">        <span class="keyword">if</span>  Distance(qnearest, qgoal) &lt; Threshold then</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        qnew = Extend(qnearest, qrand, Δq)  -- moving from qnearest an incremental distance in the direction of qrand</span><br><span class="line">        <span class="keyword">if</span> qnew ≠ <span class="literal">NULL</span> then</span><br><span class="line">            T.AddNode(qnew)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Sample() -- Alternatively,one could replace Sample with SampleFree(by <span class="keyword">using</span> a collision detection algorithm to reject samples in C_obstacle</span><br><span class="line">    p = Random(<span class="number">0</span>, <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt; p &lt; Prob then</span><br><span class="line">        <span class="keyword">return</span> qgoal</span><br><span class="line">    elseif Prob &lt; p &lt; <span class="number">1.0</span> then</span><br><span class="line">        <span class="keyword">return</span> RandomNode()</span><br></pre></td></tr></table></figure></p>
<p>初始化时随机树T只包含一个节点：根节点qinit。首先Sample函数从状态空间中随机选择一个采样点qrand（4行）；然后Nearest函数从随机树中选择一个距离qrand最近的节点qnearest（5行）；最后Extend函数通过从qnearest向qrand扩展一段距离，得到一个新的节点qnew（8行）。如果qnew与障碍物发生碰撞，则Extend函数返回空，放弃这次生长，否则将qnew加入到随机树中。重复上述步骤直到qnearest和目标点qgaol距离小于一个阈值，则代表随机树到达了目标点，算法返回成功（6~7行）。为了使算法可控，可以设定运行时间上限或搜索次数上限（3行）。如果在限制次数内无法到达目标点，则算法返回失败。</p>
<p>为了加快随机树到达目标点的速度，简单的改进方法是：在随机树每次的生长过程中，根据随机概率来决定qrand是目标点还是随机点。在Sample函数中设定参数Prob，每次得到一个0到1.0的随机值p，当0&lt;p&lt;Prob的时候，随机树朝目标点生长行；当Prob&lt;p&lt;1.0时，随机树朝一个随机方向生长。</p>
<p>上述算法的效果是随机采样点会“拉着”树向外生长，这样能更快、更有效地探索空间（The effect is that the nearly uniformly distributed samples “pull” the tree toward them, causing the tree to rapidly explore C-Space）。随机探索也讲究策略，如果我们从树中随机取一个点，然后向着随机的方向生长，那么结果是什么样的呢？见下图（Left: A tree generated by applying a uniformly-distributed random motion from a randomly chosen tree node does not explore very far. Right: A tree generated by the RRT algorithm using samples drawn randomly from a uniform distribution. Both trees have 2000 nodes ）。可以看到，同样是随机树，但是这棵树并没很好地探索空间。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/4b1ff580ly1g074hpy7w9j20d506o405.jpg"></p>
<p>根据上面的伪代码，可以用MATLAB实现一个简单的RRT路径规划（参考这里）。输入一幅像素尺寸为500×500的地图，使用RRT算法搜索出一条无碰撞路径：<br><figure class="highlight m"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% RRT parameters</span></span><br><span class="line">map<span class="built_in">=</span>im2bw(imread(<span class="string">'map1.bmp'</span>)); <span class="comment">% input map read from a bmp file. for new maps write the file name here</span></span><br><span class="line">source<span class="built_in">=</span>[<span class="number">10</span> <span class="number">10</span>]; <span class="comment">% source position in Y, X format</span></span><br><span class="line">goal<span class="built_in">=</span>[<span class="number">490</span> <span class="number">490</span>]; <span class="comment">% goal position in Y, X format</span></span><br><span class="line">stepsize <span class="built_in">=</span> <span class="number">20</span>;  <span class="comment">% size of each step of the RRT</span></span><br><span class="line">threshold <span class="built_in">=</span> <span class="number">20</span>; <span class="comment">% nodes closer than this threshold are taken as almost the same</span></span><br><span class="line">maxFailedAttempts <span class="built_in">=</span> <span class="number">10000</span>;</span><br><span class="line">display <span class="built_in">=</span> <span class="built_in">true</span>; <span class="comment">% display of RRT</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">if</span> ~feasiblePoint(source,map), error(<span class="string">'source lies on an obstacle or outside map'</span>); end</span><br><span class="line"><span class="built_in">if</span> ~feasiblePoint(goal,map), error(<span class="string">'goal lies on an obstacle or outside map'</span>); end</span><br><span class="line"><span class="built_in">if</span> display,imshow(map);rectangle(<span class="string">'position'</span>,[<span class="number">1</span> <span class="number">1</span> size(map)-<span class="number">1</span>],<span class="string">'edgecolor'</span>,<span class="string">'k'</span>); end</span><br><span class="line"></span><br><span class="line">tic;  <span class="comment">% tic-toc: Functions for Elapsed Time</span></span><br><span class="line"></span><br><span class="line">RRTree <span class="built_in">=</span> double([source -<span class="number">1</span>]); <span class="comment">% RRT rooted at the source, representation node and parent index</span></span><br><span class="line">failedAttempts <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">counter <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">pathFound <span class="built_in">=</span> <span class="built_in">false</span>;</span><br><span class="line"></span><br><span class="line">while failedAttempts <span class="built_in">&lt;=</span> maxFailedAttempts  <span class="comment">% loop to grow RRTs</span></span><br><span class="line">　　<span class="comment">%% chooses a random configuration</span></span><br><span class="line">    <span class="built_in">if</span> rand &lt; <span class="number">0.5</span></span><br><span class="line">        sample <span class="built_in">=</span> rand(<span class="number">1</span>,<span class="number">2</span>) .* size(map);   <span class="comment">% random sample</span></span><br><span class="line">    <span class="built_in">else</span></span><br><span class="line">        sample <span class="built_in">=</span> goal; <span class="comment">% sample taken as goal to bias tree generation to goal</span></span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">　　<span class="comment">%% selects the node in the RRT tree that is closest to qrand</span></span><br><span class="line">    [A, I] <span class="built_in">=</span> min( distanceCost(RRTree(:,<span class="number">1</span>:<span class="number">2</span>),sample) ,[],<span class="number">1</span>); <span class="comment">% find the minimum value of each column</span></span><br><span class="line">    closestNode <span class="built_in">=</span> RRTree(I(<span class="number">1</span>),<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">　　<span class="comment">%% moving from qnearest an incremental distance in the direction of qrand</span></span><br><span class="line">    theta <span class="built_in">=</span> atan2(sample(<span class="number">1</span>)-closestNode(<span class="number">1</span>),sample(<span class="number">2</span>)-closestNode(<span class="number">2</span>));  <span class="comment">% direction to extend sample to produce new node</span></span><br><span class="line">    newPoint <span class="built_in">=</span> double(int32(closestNode(<span class="number">1</span>:<span class="number">2</span>) + stepsize * [sin(theta)  cos(theta)]));</span><br><span class="line">    <span class="built_in">if</span> ~checkPath(closestNode(<span class="number">1</span>:<span class="number">2</span>), newPoint, map) <span class="comment">% if extension of closest node in tree to the new point is feasible</span></span><br><span class="line">        failedAttempts <span class="built_in">=</span> failedAttempts + <span class="number">1</span>;</span><br><span class="line">        continue;</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">if</span> distanceCost(newPoint,goal) &lt; threshold, pathFound <span class="built_in">=</span> <span class="built_in">true</span>; break; end <span class="comment">% goal reached</span></span><br><span class="line">    </span><br><span class="line">    [A, I2] <span class="built_in">=</span> min( distanceCost(RRTree(:,<span class="number">1</span>:<span class="number">2</span>),newPoint) ,[],<span class="number">1</span>); <span class="comment">% check if new node is not already pre-existing in the tree</span></span><br><span class="line">    <span class="built_in">if</span> distanceCost(newPoint,RRTree(I2(<span class="number">1</span>),<span class="number">1</span>:<span class="number">2</span>)) &lt; threshold, failedAttempts <span class="built_in">=</span> failedAttempts + <span class="number">1</span>; continue; end </span><br><span class="line">    </span><br><span class="line">    RRTree <span class="built_in">=</span> [RRTree; newPoint I(<span class="number">1</span>)]; <span class="comment">% add node</span></span><br><span class="line">    failedAttempts <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">if</span> display, line([closestNode(<span class="number">2</span>);newPoint(<span class="number">2</span>)],[closestNode(<span class="number">1</span>);newPoint(<span class="number">1</span>)]);counter <span class="built_in">=</span> counter + <span class="number">1</span>; M(counter) <span class="built_in">=</span> getframe; end <span class="comment">% Capture movie frame </span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">% getframe returns a movie frame, which is a structure having two fields</span></span><br><span class="line"><span class="built_in">if</span> display &amp;&amp; pathFound, line([closestNode(<span class="number">2</span>);goal(<span class="number">2</span>)],[closestNode(<span class="number">1</span>);goal(<span class="number">1</span>)]); counter <span class="built_in">=</span> counter+<span class="number">1</span>;M(counter) <span class="built_in">=</span> getframe; end</span><br><span class="line"></span><br><span class="line"><span class="built_in">if</span> display, disp(<span class="string">'click/press any key'</span>); waitforbuttonpress; end</span><br><span class="line"><span class="built_in">if</span> ~pathFound, error(<span class="string">'no path found. maximum attempts reached'</span>); end</span><br><span class="line"></span><br><span class="line"><span class="comment">%% retrieve path from parent information</span></span><br><span class="line">path <span class="built_in">=</span> [goal];</span><br><span class="line">prev <span class="built_in">=</span> I(<span class="number">1</span>);</span><br><span class="line">while prev &gt; <span class="number">0</span></span><br><span class="line">    path <span class="built_in">=</span> [RRTree(prev,<span class="number">1</span>:<span class="number">2</span>); path];</span><br><span class="line">    prev <span class="built_in">=</span> RRTree(prev,<span class="number">3</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">pathLength <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">for i<span class="built_in">=</span><span class="number">1</span>:length(path)-<span class="number">1</span>, pathLength <span class="built_in">=</span> pathLength + distanceCost(path(i,<span class="number">1</span>:<span class="number">2</span>),path(i+<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>)); end <span class="comment">% calculate path length</span></span><br><span class="line">fprintf(<span class="string">'processing time=%d \nPath Length=%d \n\n'</span>, toc, pathLength); </span><br><span class="line">imshow(map);rectangle(<span class="string">'position'</span>,[<span class="number">1</span> <span class="number">1</span> size(map)-<span class="number">1</span>],<span class="string">'edgecolor'</span>,<span class="string">'k'</span>);</span><br><span class="line">line(path(:,<span class="number">2</span>),path(:,<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<p>其他m文件：<br><figure class="highlight m"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">%% distanceCost.m</span></span><br><span class="line">function h<span class="built_in">=</span>distanceCost(a,b)</span><br><span class="line">    h <span class="built_in">=</span> sqrt(sum((a-b).^<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">%% checkPath.m  </span></span><br><span class="line">function feasible<span class="built_in">=</span>checkPath(n,newPos,map)</span><br><span class="line">feasible<span class="built_in">=</span><span class="built_in">true</span>;</span><br><span class="line">dir<span class="built_in">=</span>atan2(newPos(<span class="number">1</span>)-n(<span class="number">1</span>),newPos(<span class="number">2</span>)-n(<span class="number">2</span>));</span><br><span class="line">for r<span class="built_in">=</span><span class="number">0</span>:<span class="number">0.5</span>:sqrt(sum((n-newPos).^<span class="number">2</span>))</span><br><span class="line">    posCheck<span class="built_in">=</span>n+r.*[sin(dir) cos(dir)];</span><br><span class="line">    <span class="built_in">if</span> ~(feasiblePoint(ceil(posCheck),map) &amp;&amp; feasiblePoint(floor(posCheck),map) &amp;&amp; ... </span><br><span class="line">            feasiblePoint([ceil(posCheck(<span class="number">1</span>)) floor(posCheck(<span class="number">2</span>))],map) &amp;&amp; feasiblePoint([floor(posCheck(<span class="number">1</span>)) ceil(posCheck(<span class="number">2</span>))],map))</span><br><span class="line">        feasible<span class="built_in">=</span><span class="built_in">false</span>;break;</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">if</span> ~feasiblePoint(newPos,map), feasible<span class="built_in">=</span><span class="built_in">false</span>; end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% feasiblePoint.m</span></span><br><span class="line">function feasible<span class="built_in">=</span>feasiblePoint(point,map)</span><br><span class="line">feasible<span class="built_in">=</span><span class="built_in">true</span>;</span><br><span class="line"><span class="comment">% check if collission-free spot and inside maps</span></span><br><span class="line"><span class="built_in">if</span> ~(point(<span class="number">1</span>)&gt;<span class="built_in">=</span><span class="number">1</span> &amp;&amp; point(<span class="number">1</span>)<span class="built_in">&lt;=</span>size(map,<span class="number">1</span>) &amp;&amp; point(<span class="number">2</span>)&gt;<span class="built_in">=</span><span class="number">1</span> &amp;&amp; point(<span class="number">2</span>)<span class="built_in">&lt;=</span>size(map,<span class="number">2</span>) &amp;&amp; map(point(<span class="number">1</span>),point(<span class="number">2</span>))<span class="built_in">=</span><span class="built_in">=</span><span class="number">1</span>)</span><br><span class="line">    feasible<span class="built_in">=</span><span class="built_in">false</span>;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p><img src="https://wx2.sinaimg.cn/mw690/4b1ff580ly1g0753cz6gtg20ea0eamzq.gif"><br>RRT算法也有一些缺点，它是一种纯粹的随机搜索算法对环境类型不敏感，当C-空间中包含大量障碍物或狭窄通道约束时，算法的收敛速度慢，效率会大幅下降：<br><img src="https://wx4.sinaimg.cn/mw690/4b1ff580ly1g07559x31bg20dw0dwk09.gif"></p>
<p>RRT 的一个弱点是难以在有狭窄通道的环境找到路径。因为狭窄通道面积小，被碰到的概率低。下图展示的例子是 RRT 应对一个人为制作的很短的狭窄通道，有时RRT很快就找到了出路，有时则一直被困在障碍物里面：<br><img src="https://wx1.sinaimg.cn/mw690/4b1ff580ly1g0756fo03kg20ci0ci74g.gif"><br><img src="https://wx2.sinaimg.cn/mw690/4b1ff580ly1g0756ishf1g20ci0ciwft.gif"></p>
<p>上述基础RRT算法中有几处可以改进的地方：</p>
<p>how to sample from C-Space (line 4). 如何进行随机采样<br>how to define the “nearest” node in T (line 5). 如何定义“最近”点<br>how to plan the motion to make progress toward sample (line 8). 如何进行树的扩展<br>　　Even a small change to the sampling method, for example, can yield a dramatic change in the running time of the planner. A wide variety of planners have been proposed in the literature based on these choices and other variations. 根据以上几个方向，多种RRT改进算法被提出。</p>
<p>Defining the Nearest Node<br>　　查找最近点的基础是计算C-Space中两点间的距离。计算距离最直观的方法是使用欧氏距离，但对很多C-Space来说这样做的直观意义并不明显。Finding the “nearest” node depends on a definition of distance. A natural choice for the distance between two points is simply the Euclidean distance. For other spaces, the choice is less obvious. 举个例子，如下图所示，对于一个car-like robot来说其C-space为R2×S1.  虚线框分别代表三种不同的机器人构型：第一个构型绕其旋转了20°，第二个在它后方2米处，最后一个在侧方位1米处。那么哪一种距离灰色的目标“最近”呢？汽车型机器人的运动约束导致其不能直接进行横向运动和原地转动。因此，对于这种机器人来说从第二种构型移动到目标位置“最近”。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/4b1ff580ly1g0758kcl79j20j606w74i.jpg"><br>从上面的例子可以看出来，定义一个距离需要考虑以下两点：</p>
<ul>
<li>combining components of different units (e.g., degrees, meters, degrees/s,meters/s) into a single distance measure;</li>
<li><p>taking into account the motion constraints of the robot 结合不同单位的一个简单办法是使用加权平均计算距离，不同分量的重要程度用权值大小表示（The weights express the relative importance of the different components）。寻找最近点在计算机科学和机器人学等领域中是一个非常普遍的问题，已经有各种用于加速计算的方法，比如K-d树、hash算法等。</p>
</li>
<li><p>The Sampler<br>　　The reason that the tree ends up covering the entire search space (in most cases) is because of the combination of the sampling strategy, and always looking to connect from the nearest point in the tree. The choice of where to place the next vertex that you will attempt to connect to is the sampling problem. In simple cases, where search is low dimensional, uniform random placement (or uniform random placement biased toward the goal) works adequately. In high dimensional problems, or when motions are very complex (when joints have positions, velocities and accelerations), or configuration is difficult to control, sampling strategies for RRTs are still an open research area.</p>
</li>
<li><p>The Local Planner<br>　　The job of the local planner is to find a motion from qnearest to some point qnew which is closer to qrand. The planner should be simple and it should run quickly. </p>
</li>
</ul>
<p>A straight-line planner. The plan is a straight line to qnew, which may be chosen at qrand or at a fixed distance d from qnearest on the straight line to qrand. This is suitable for kinematic systems with no motion constraints. </p>
<p>Bidirectional RRT / RRT Connect<br>　　基本的RRT每次搜索都只有从初始状态点生长的快速扩展随机树来搜索整个状态空间，如果从初始状态点和目标状态点同时生长两棵快速扩展随机树来搜索状态空间，效率会更高。为此，基于双向扩展平衡的连结型双树RRT算法，即RRT_Connect算法被提出。</p>
<p><img src="https://wx3.sinaimg.cn/mw690/4b1ff580ly1g0758nu86pj20i30k5js3.jpg"></p>
<p>该算法与原始RRT相比，在目标点区域建立第二棵树进行扩展。每一次迭代中，开始步骤与原始的RRT算法一样，都是采样随机点然后进行扩展。然后扩展完第一棵树的新节点𝑞𝑛𝑒𝑤后，以这个新的目标点作为第二棵树扩展的方向。同时第二棵树扩展的方式略有不同（15~22行），首先它会扩展第一步得到𝑞′𝑛𝑒𝑤，如果没有碰撞，继续往相同的方向扩展第二步，直到扩展失败或者𝑞′𝑛𝑒𝑤=𝑞𝑛𝑒𝑤表示与第一棵树相连了，即connect了，整个算法结束。当然每次迭代中必须考虑两棵树的平衡性，即两棵树的节点数的多少（也可以考虑两棵树总共花费的路径长度），交换次序选择“小”的那棵树进行扩展。这种双向的RRT技术具有良好的搜索特性，比原始RRT算法的搜索速度、搜索效率有了显著提高，被广泛应用。首先，Connect算法较之前的算法在扩展的步长上更长，使得树的生长更快；其次，两棵树不断朝向对方交替扩展，而不是采用随机扩展的方式，特别当起始位姿和目标位姿处于约束区域时，两棵树可以通过朝向对方快速扩展而逃离各自的约束区域。这种带有启发性的扩展使得树的扩展更加贪婪和明确，使得双树RRT算法较之单树RRT算法更加有效。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/4b1ff580ly1g0758qs0yhj20pf0atmys.jpg"></p>
<p>参考这里可以用MATLAB实现一个简单的RRT Connect路径规划：</p>
<p><img src="https://wx3.sinaimg.cn/mw690/4b1ff580ly1g0758ez18jg20e50e4wfx.gif"></p>
<p><strong>Reference</strong></p>
<ul>
<li><a href="http://msl.cs.uiuc.edu/rrt/" target="_blank" rel="noopener">Rapidly-exploring Random Trees (RRTs)</a></li>
<li><a href="https://www.cnblogs.com/21207-iHome/p/7210543.html" target="_blank" rel="noopener">RRT路径规划算法</a></li>
</ul>


<!--<a href="http://yoursite.com/2019-2-15-rrt.html#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'mickeyouyou'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</body>
</html>