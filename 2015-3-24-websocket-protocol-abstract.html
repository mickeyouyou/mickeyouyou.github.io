<html>
<head>
	
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>Websocket Protocol摘要</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=4.3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	   <link rel="shortcut icon" type="image/x-icon" href="/rocket_128px_1215034_easyicon.net.ico?v=4.3"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>


<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 class="title">Websocket Protocol摘要</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2015年3月24日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-text"><a href="#&#x4ECB;&#x7ECD;" class="headerlink" title="&#x4ECB;&#x7ECD;"></a>&#x4ECB;&#x7ECD;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#背景"><span class="toc-text"><a href="#&#x80CC;&#x666F;" class="headerlink" title="&#x80CC;&#x666F;"></a>&#x80CC;&#x666F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协议概览"><span class="toc-text"><a href="#&#x534F;&#x8BAE;&#x6982;&#x89C8;" class="headerlink" title="&#x534F;&#x8BAE;&#x6982;&#x89C8;"></a>&#x534F;&#x8BAE;&#x6982;&#x89C8;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打开握手"><span class="toc-text"><a href="#&#x6253;&#x5F00;&#x63E1;&#x624B;" class="headerlink" title="&#x6253;&#x5F00;&#x63E1;&#x624B;"></a>&#x6253;&#x5F00;&#x63E1;&#x624B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭握手"><span class="toc-text"><a href="#&#x5173;&#x95ED;&#x63E1;&#x624B;" class="headerlink" title="&#x5173;&#x95ED;&#x63E1;&#x624B;"></a>&#x5173;&#x95ED;&#x63E1;&#x624B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计哲学"><span class="toc-text"><a href="#&#x8BBE;&#x8BA1;&#x54F2;&#x5B66;" class="headerlink" title="&#x8BBE;&#x8BA1;&#x54F2;&#x5B66;"></a>&#x8BBE;&#x8BA1;&#x54F2;&#x5B66;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全模型"><span class="toc-text"><a href="#&#x5B89;&#x5168;&#x6A21;&#x578B;" class="headerlink" title="&#x5B89;&#x5168;&#x6A21;&#x578B;"></a>&#x5B89;&#x5168;&#x6A21;&#x578B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与TCP和HTTP的关系"><span class="toc-text"><a href="#&#x4E0E;TCP&#x548C;HTTP&#x7684;&#x5173;&#x7CFB;" class="headerlink" title="&#x4E0E;TCP&#x548C;HTTP&#x7684;&#x5173;&#x7CFB;"></a>&#x4E0E;TCP&#x548C;HTTP&#x7684;&#x5173;&#x7CFB;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建立连接"><span class="toc-text"><a href="#&#x5EFA;&#x7ACB;&#x8FDE;&#x63A5;" class="headerlink" title="&#x5EFA;&#x7ACB;&#x8FDE;&#x63A5;"></a>&#x5EFA;&#x7ACB;&#x8FDE;&#x63A5;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用WebSocket协议的子协议"><span class="toc-text"><a href="#&#x4F7F;&#x7528;WebSocket&#x534F;&#x8BAE;&#x7684;&#x5B50;&#x534F;&#x8BAE;" class="headerlink" title="&#x4F7F;&#x7528;WebSocket&#x534F;&#x8BAE;&#x7684;&#x5B50;&#x534F;&#x8BAE;"></a>&#x4F7F;&#x7528;WebSocket&#x534F;&#x8BAE;&#x7684;&#x5B50;&#x534F;&#x8BAE;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一致性要求"><span class="toc-text"><a href="#&#x4E00;&#x81F4;&#x6027;&#x8981;&#x6C42;" class="headerlink" title="&#x4E00;&#x81F4;&#x6027;&#x8981;&#x6C42;"></a>&#x4E00;&#x81F4;&#x6027;&#x8981;&#x6C42;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#术语和其他公约"><span class="toc-text"><a href="#&#x672F;&#x8BED;&#x548C;&#x5176;&#x4ED6;&#x516C;&#x7EA6;" class="headerlink" title="&#x672F;&#x8BED;&#x548C;&#x5176;&#x4ED6;&#x516C;&#x7EA6;"></a>&#x672F;&#x8BED;&#x548C;&#x5176;&#x4ED6;&#x516C;&#x7EA6;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket-URI"><span class="toc-text"><a href="#WebSocket-URI" class="headerlink" title="WebSocket URI"></a>WebSocket URI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打开握手-1"><span class="toc-text"><a href="#&#x6253;&#x5F00;&#x63E1;&#x624B;-1" class="headerlink" title="&#x6253;&#x5F00;&#x63E1;&#x624B;"></a>&#x6253;&#x5F00;&#x63E1;&#x624B;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端要求"><span class="toc-text"><a href="#&#x5BA2;&#x6237;&#x7AEF;&#x8981;&#x6C42;" class="headerlink" title="&#x5BA2;&#x6237;&#x7AEF;&#x8981;&#x6C42;"></a>&#x5BA2;&#x6237;&#x7AEF;&#x8981;&#x6C42;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器端要求"><span class="toc-text"><a href="#&#x670D;&#x52A1;&#x5668;&#x7AEF;&#x8981;&#x6C42;" class="headerlink" title="&#x670D;&#x52A1;&#x5668;&#x7AEF;&#x8981;&#x6C42;"></a>&#x670D;&#x52A1;&#x5668;&#x7AEF;&#x8981;&#x6C42;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取客户端打开握手"><span class="toc-text"><a href="#&#x8BFB;&#x53D6;&#x5BA2;&#x6237;&#x7AEF;&#x6253;&#x5F00;&#x63E1;&#x624B;" class="headerlink" title="&#x8BFB;&#x53D6;&#x5BA2;&#x6237;&#x7AEF;&#x6253;&#x5F00;&#x63E1;&#x624B;"></a>&#x8BFB;&#x53D6;&#x5BA2;&#x6237;&#x7AEF;&#x6253;&#x5F00;&#x63E1;&#x624B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送服务器打开握手"><span class="toc-text"><a href="#&#x53D1;&#x9001;&#x670D;&#x52A1;&#x5668;&#x6253;&#x5F00;&#x63E1;&#x624B;" class="headerlink" title="&#x53D1;&#x9001;&#x670D;&#x52A1;&#x5668;&#x6253;&#x5F00;&#x63E1;&#x624B;"></a>&#x53D1;&#x9001;&#x670D;&#x52A1;&#x5668;&#x6253;&#x5F00;&#x63E1;&#x624B;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据成帧"><span class="toc-text"><a href="#&#x6570;&#x636E;&#x6210;&#x5E27;" class="headerlink" title="&#x6570;&#x636E;&#x6210;&#x5E27;"></a>&#x6570;&#x636E;&#x6210;&#x5E27;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-text"><a href="#&#x6982;&#x8FF0;" class="headerlink" title="&#x6982;&#x8FF0;"></a>&#x6982;&#x8FF0;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本的帧协议"><span class="toc-text"><a href="#&#x57FA;&#x672C;&#x7684;&#x5E27;&#x534F;&#x8BAE;" class="headerlink" title="&#x57FA;&#x672C;&#x7684;&#x5E27;&#x534F;&#x8BAE;"></a>&#x57FA;&#x672C;&#x7684;&#x5E27;&#x534F;&#x8BAE;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端到服务器标记"><span class="toc-text"><a href="#&#x5BA2;&#x6237;&#x7AEF;&#x5230;&#x670D;&#x52A1;&#x5668;&#x6807;&#x8BB0;" class="headerlink" title="&#x5BA2;&#x6237;&#x7AEF;&#x5230;&#x670D;&#x52A1;&#x5668;&#x6807;&#x8BB0;"></a>&#x5BA2;&#x6237;&#x7AEF;&#x5230;&#x670D;&#x52A1;&#x5668;&#x6807;&#x8BB0;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分帧"><span class="toc-text"><a href="#&#x5206;&#x5E27;" class="headerlink" title="&#x5206;&#x5E27;"></a>&#x5206;&#x5E27;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制帧"><span class="toc-text"><a href="#&#x63A7;&#x5236;&#x5E27;" class="headerlink" title="&#x63A7;&#x5236;&#x5E27;"></a>&#x63A7;&#x5236;&#x5E27;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭"><span class="toc-text"><a href="#&#x5173;&#x95ED;" class="headerlink" title="&#x5173;&#x95ED;"></a>&#x5173;&#x95ED;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ping"><span class="toc-text"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pong"><span class="toc-text"><a href="#Pong" class="headerlink" title="Pong"></a>Pong</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据帧"><span class="toc-text"><a href="#&#x6570;&#x636E;&#x5E27;" class="headerlink" title="&#x6570;&#x636E;&#x5E27;"></a>&#x6570;&#x636E;&#x5E27;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举例"><span class="toc-text"><a href="#&#x4E3E;&#x4F8B;" class="headerlink" title="&#x4E3E;&#x4F8B;"></a>&#x4E3E;&#x4F8B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展"><span class="toc-text"><a href="#&#x6269;&#x5C55;" class="headerlink" title="&#x6269;&#x5C55;"></a>&#x6269;&#x5C55;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送和接收数据"><span class="toc-text"><a href="#&#x53D1;&#x9001;&#x548C;&#x63A5;&#x6536;&#x6570;&#x636E;" class="headerlink" title="&#x53D1;&#x9001;&#x548C;&#x63A5;&#x6536;&#x6570;&#x636E;"></a>&#x53D1;&#x9001;&#x548C;&#x63A5;&#x6536;&#x6570;&#x636E;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送数据"><span class="toc-text"><a href="#&#x53D1;&#x9001;&#x6570;&#x636E;" class="headerlink" title="&#x53D1;&#x9001;&#x6570;&#x636E;"></a>&#x53D1;&#x9001;&#x6570;&#x636E;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收数据"><span class="toc-text"><a href="#&#x63A5;&#x6536;&#x6570;&#x636E;" class="headerlink" title="&#x63A5;&#x6536;&#x6570;&#x636E;"></a>&#x63A5;&#x6536;&#x6570;&#x636E;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text"><a href="#&#x53C2;&#x8003;" class="headerlink" title="&#x53C2;&#x8003;"></a>&#x53C2;&#x8003;</span></a></li></ol></li></ol>
<p><code>WebSocket</code>协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。用于这个的安全模型是以origin为基础的安全模型，一般被浏览器使用。协议包含打开握手，其次是基本消息框架，在TCP之上。这项技术的目的是为基于浏览器的、需要与服务器双向通信的应用程序提供一种不依赖于打开多个HTTP连接的机制（例如，使用XMLHttpRequest或<code>&lt;iframe&gt;</code> 和长轮询）。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>历史上，创建需要在客户端和服务器间双向通信的网络应用程序（如即时消息和游戏程序）要求滥用HTTP来轮询服务器来获得更新，通过不同HTTP请求来发送上行通知。</p>
<p>这导致各种问题：</p>
<ul>
<li>服务器被迫为每个客户端使用一些不同的底层TCP连接：一个用来向客户端发送消息，为每个到来的消息使用一个新的。</li>
<li>通信（wire）协议具有很高的开销，因为每个客户端到服务器的消息有HTTP头。</li>
<li>客户端侧的脚本被迫维护输出连接到输入连接的映射来追踪响应。</li>
</ul>
<p>一个简单的解决方法是为双向传输使用单一的TCP连接。这是WebSocket协议提供的。结合WebSocket API（WSAPI），它为web页面到远程服务器的双向通信提供了HTTP轮询的替代方案。</p>
<p>同样的技术也可用于各种web应用程序：游戏，股票行情，多用户协同编辑的应用程序，用户界面实时展示服务器侧服务等。</p>
<p>WebSocket协议设计用来取代使用HTTP作为传输层的双向通信技术，并从现有的基础设施（代理、过滤、认证）受益。这些技术作为效率与可靠性的平衡而实现，因为HTTP最初并不是用于双向通信的（见RFC6202有多更讨论）。WebSocket尝试解决在现有HTTP基础设施的环境下现有HTTP双向通信技术的目标；像这样，它设计来工作于HTTP 80、443端口上，并支持HTTP代理和中间设施，即使这意味着增加现有环境的一些复杂性。然后，设计并没有将WebSocket局限于HTTP，未来的实现可以在特定的端口上使用更简单的握手，而不需要重新发明整个协议。最后一点是重要的，因为交互式消息的传输模式并不紧密符合标准的HTTP传输，会在一些部件上引起异常的负载。</p>
<h3 id="协议概览"><a href="#协议概览" class="headerlink" title="协议概览"></a>协议概览</h3><p>WebSocket 协议有两部分：握手和数据传输。</p>
<p>来自客户端的握手开起来像下面：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET wss://echo.websocket.org/?encoding=text HTTP/1.1</span><br><span class="line">Host: echo.websocket.org</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: https://www.websocket.org</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Cookie: __utmt=1; __utma=9925811.238446259.1427177542.1427177542.1427184777.2; __utmb=9925811.5.10.1427184777; __utmc=9925811; __utmz=9925811.1427184777.2.2.utmcsr=google|utmccn=(organic)|utmcmd=organic|utmctr=(not%20provided)</span><br><span class="line">Sec-WebSocket-Key: 0opeI4nGBsKvpLlmFMx7yw==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure></p>
<p>来自服务器的握手开起来像下面：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials:true</span><br><span class="line">Access-Control-Allow-Headers:x-websocket-protocol</span><br><span class="line">Access-Control-Allow-Headers:x-websocket-version</span><br><span class="line">Access-Control-Allow-Headers:x-websocket-extensions</span><br><span class="line">Access-Control-Allow-Headers:authorization</span><br><span class="line">Access-Control-Allow-Headers:content-type</span><br><span class="line">Access-Control-Allow-Origin:https://www.websocket.org</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Date:Tue, 24 Mar 2015 08:14:39 GMT</span><br><span class="line">Sec-WebSocket-Accept:PEACKXhRrAEQS+RTsLbO4IJ1siw=</span><br><span class="line">Server:Kaazing Gateway</span><br><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>测试数据来自：<a href="https://www.websocket.org/echo.html" target="_blank" rel="noopener">https://www.websocket.org/echo.html</a></p>
</blockquote>
<p>来自客户端的引导行遵从Request-Line格式，来自服务器的引导行遵从Status-Line格式。Request-Line和Status-Line 在[RFC2616]定义。</p>
<p>在两种情况下，引导行后面跟着一组未排序的头域。这些头域的意义在本文档的第4章指定。额外的头域也可能出现，如cookie [RFC6265]。头的格式和解析在[RFC2616]定义。</p>
<p>一旦客户端和服务器都发送了他们的握手，如果握手成功，传输数据部分开始。这是一个双向传输通道，每个端都能独立、随意发送数据。</p>
<p>在成功握手后，客户端和服务器来回传输数据是以消息message为概念单位的。在传输介质上（on the wire），一个消息由一个或多个帧frame组成。WebSocket消息不需要对应到特定网络层的帧，因为分帧后的消息可能被中间设施合并或拆分。</p>
<p>一帧都有一个关联的类型。属于同一个消息的帧拥有相同的数据类型，广义地说，有文本数据（解释为UTF-8[RFC3629]文本）、二进制数据（它的解释留给了应用程序）和控制帧（不打算携带应用数据，携带的是协议层的信号，如连接关闭信号）类型。这个版本的协议定义了6种帧类型，并保留了10种为以后使用。</p>
<h3 id="打开握手"><a href="#打开握手" class="headerlink" title="打开握手"></a>打开握手</h3><p>打开握手为了兼容基于HTTP的服务器端软件和中间设施，使同一个端口能够接受HTTP客户端和WebSocket客户端，为了这个目的，WebSocket客户端的握手是HTTP请求的升级。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p>
<p>为了兼容[RFC2616]，客户端握手里的头域可能以任意的顺序发送，因此不同头域接收到的顺序是不重要的。</p>
<p>GET方法[RFC2616]的Request-URI用于识别WebSocket连接的终端，允许一个IP地址服务多个域domain，和允许单个服务器提供多个WebSocket终端。</p>
<p>客户端在握手的Host头域里包含主机名，这样，客户端和服务器能够验证他们同意使用哪个主机。额外的头域用于选择WebSocket协议的选项。此版本中典型的可用选项有子协议选择器Sec-WebSocket-Protocol，Sec-WebSocket-Protocol列出客户端支持的扩展，Origin头域等等。Sec-WebSocket-Protocol请求头域可用来表明客户端可接受的子协议（WebSocket协议之上的应用程序层协议）。服务器选择一个或零个可接受的协议，输出到它的握手，来指明它选择了那个协议。<br>Sec-WebSocket-Protocol: chat</p>
<p>Origin 头域（RFC6454）用于保护WebSocket服务器不被未授权的运行在浏览器的脚本跨源使用WebSocket API。如果服务器不想接受来自这个源的连接，它可以拒绝连接，并发送一个合适的HTTP错误码。这个头域有浏览器客户端发送；对于非浏览器客户端，这个头域可能发送，如果它在客户端上下文环境中有意义。</p>
<p>最后，服务器得向客户端证明它接收到了客户端的WebSocket握手，为使服务器不接受非WebSocket连接。这防止攻击者通过XMLHttpRequest发送或表单提交精心构造的包来欺骗WebSocket服务器。</p>
<p>为了证明握手被接收，服务器把两块信息合并来形成响应。第一块信息来自客户端握手头域Sec-WebSocket-Key，如<br>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==<br>对于这个头域，服务器取头的值（由于出现在头域，例如，base64编码[RFC4648]后的版本，消除任何前面后面的空白符），以字符串的形式拼接全局唯一的（GUID，[RFC4122]）标识：258EAFA5-E914-47DA-95CA-C5AB0DC85B11，此值不大可能被不明白WebSocket协议的网络终端使用。然后进行SHA-1 hash（160位）编码，再进行base64编码，将结果作为服务器的握手返回。</p>
<p>具体如下：<br>请求头：Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==<br>取值，字符串拼接后得到：”dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11”;<br>SHA-1后得到： 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb20xbe 0xc4 0xea<br>Base64后得到： s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<br>最后的结果值作为响应头Sec-WebSocket-Accept 的值。</p>
<p>来自服务器的握手比客户端的简单很多。首先是HTTP 状态行，状态码是101：<br>HTTP/1.1 101 Switching Protocols<br>任何非101的状态码表示WebSocket握手还没有完成，HTTP语义仍然生效。</p>
<p>Connection和Upgrade头域完成HTTP升级。Sec-WebSocket-Accept头表明服务器是否愿意接受连接。如果有，值必须是前面提到的算法得到的值，否则不能解释为服务器接受连接。<br>HTTP/1.1 101 Switching Protocols<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</p>
<p>这些字段由WebSocket客户端为脚本页面检测，如果Sec-WebSocket-Accept的值不符合预期的值，如果头缺失， 或HTTP状态码不是101，连接不会建立，WebSocket帧不会发送。</p>
<p>还可以包含一些可选字段。在协议的这个版本里，主要的可选字段是Sec-WebSocket-Protocol，表示服务器选择的子协议。WebSocket客户端验证服务器选择了一个客户端握手中指定的值。支持多个子协议的服务器必须确保它选择了一个基于客户端握手并在它自己的握手里指定了它。</p>
<p>服务器也可以设置cookie有关的可选头。</p>
<h3 id="关闭握手"><a href="#关闭握手" class="headerlink" title="关闭握手"></a>关闭握手</h3><p>关闭握手远比打开握手简单。</p>
<p>任何一端都可以发送带有指定控制序号的数据的帧来开始关闭握手（详细在5.5.1节）。当接收到这样的帧时，如果还没有发送，另一端发送一个关闭帧（B）作为响应。当接收到那个（B）帧时，第一个端关闭连接，因为知道没有更多的数据需要传输。</p>
<p>发送表明关闭连接的控制帧后，端不应该再发数据；接收到表示应该关闭连接的控制帧后，端丢弃后面接收的所有数据。</p>
<p>两端都可以安全地同时开始关闭握手。</p>
<p>这个关闭握手想补充TCP的关闭握手（FIN/ACK），依据是，TCP关闭握手不总是端到端可靠的，特别是出现拦截代理和其他的中间设施。</p>
<p>通过发送一个关闭帧并等待返回关闭帧响应，可以避免一些数据丢失的特殊情况。例如，在一些平台上，如果一个套接字关闭时有数据在接收队列，RST包发送后，将导致recv()失败，<br>因为接收到RST，即使仍有数据等待读取。</p>
<h3 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h3><p>WebSocket协议的设计原则就是最小化框架（唯一的框架就是协议是基于帧的，而不是基于流的，并且支持区分Unicode文本和二进制帧的）。它希望元数据放在WebSocket上面的应用程序层。</p>
<p>概念上，WebSocket确实只是TCP上面的一层，做下面的工作：</p>
<ul>
<li>为浏览器添加web 的origin-based的安全模型。</li>
<li>添加定位和协议命名机制来支持在同一个端口上提供多个服务和同一个IP上有多个主机名。</li>
<li>在TCP上实现帧机制，来回到IP包机制，而没有长度限制。</li>
<li>在带内包含额外的关闭握手，是为了能在有代理和其他中间设施的地方工作。</li>
</ul>
<p>除了这些，WebSocket没有再添加任何东西。基本上，它想尽可能暴露原始的TCP给脚本，又给web约束。它还设计以这样的方式，它的服务器能和HTTP服务器共享同一个端口，通过使它的请求是一个合法的HTTP升级请求。在概念上可以使用其他的协议来建立客户端-服务器消息机制，但WebSocket的目的是提供一个相当简单的协议，能够与HTTP和已部署的HTTP基础设施共存（如代理），尽可能接近TCP，通过给定安全模型在现有基础设施上安全使用，伴随简化使用和使简单事情保持简单的额外目标。</p>
<p>协议考虑到可扩展，未来的版本很可能引入额外的概念，如multiplexing。</p>
<h3 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h3><p>WebSocket协议使用起源模型（origin model），浏览器用来限制哪些网页能够接触WebSocket服务器。当专用的客户端直接使用WebSocket协议时，起源模型没用了，因为客户端能够提供任意的origin字符串。</p>
<p>这个协议目的是不和现有协议（如SMTP、HTTP）的服务器建立连接，如果要求，允许HTTP服务器可选地支持此协议。这个通过一个严格的、精心制作的握手和在握手完成前限制数据进入连接来做到的。</p>
<p>类似地，当其他协议的数据发送到WebSocket时，使连接失败。这主要是通过要求服务器证明它读取了握手，在只有当握手含有适当的部分时，这些部分只能由WebSocket客户端发送。特别是，在写这个规范时，以Sec- 开头的头不能被来自浏览器的攻击者使用HTML和JavaScriptAPI如XMLHttpRequest发送。</p>
<h3 id="与TCP和HTTP的关系"><a href="#与TCP和HTTP的关系" class="headerlink" title="与TCP和HTTP的关系"></a>与TCP和HTTP的关系</h3><p>WebSocket协议是独立的、基于TCP的协议。与HTTP的唯一关系是它的握手可以被HTTP服务器解释为一个升级请求。</p>
<p>默认地，WebSocket协议为常规连接使用80端口，为基于传输层安全（TLS）的连接使用443端口。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>当一个连接连接到被HTTP服务器共享的端口（对于端口80和443是很可能发生的场景），连接将展示给HTTP服务器的将是一个伴有Upgrade的、常规的GET请求。在只有一个IP地址和单个服务器对应所有传输到单个主机的相对简单的设置，这将允许特殊的方法来部署基于系统的WebSocket协议。在更复杂的设置下，一组用于WebSocket连接的主机从HTTP服务器分离是更容易管理的。在写这篇规范的时候，应当指出，在端口80和443上连接有显著的成功率。</p>
<h3 id="使用WebSocket协议的子协议"><a href="#使用WebSocket协议的子协议" class="headerlink" title="使用WebSocket协议的子协议"></a>使用WebSocket协议的子协议</h3><p>客户端可以通过在它的握手包含Sec-WebSocket-Protocol头来要求服务器使用指定的子协议。如果指定了，为建立连接，服务器需要包含一个同样的头和一个选择了的子协议在它的响应。</p>
<p>这些子协议的命名要按照11.5节注册。为了避免潜在的冲突，推荐使用带有子协议发起人的域名的ASCII版本号的名字。例如，Excaple集团准备创建一个聊天子协议，由web上的一些服务器来实现，它可以命名为“chat.example.com”。如果Example组织命名他们的竞争子协议为“chat.example.org”，那么两种子协议都能背服务器同时实现，由服务器根据客户端发送的数据动态选择使用子协议。</p>
<p>子协议的版本可以是向后不兼容的，通过改变子协议的名字，如从“bookings.example.net”到“v2.bookings.examples.net”。这些子协议可以认为完全独立于WebSocket客户端的。向后兼容的版本可通过复用同样的协议字符串来实现，但小心设计协议来支持扩展。</p>
<h2 id="一致性要求"><a href="#一致性要求" class="headerlink" title="一致性要求"></a>一致性要求</h2><h3 id="术语和其他公约"><a href="#术语和其他公约" class="headerlink" title="术语和其他公约"></a>术语和其他公约</h3><h2 id="WebSocket-URI"><a href="#WebSocket-URI" class="headerlink" title="WebSocket URI"></a>WebSocket URI</h2><p>本规范定义了两种URI方案，使用在RFC5234定义的ABNF语法、术语和在RFC3986定义的URI规范的ABNF成果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws-URI = &quot;ws:&quot; &quot;//&quot;host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</span><br><span class="line">wss-URI = &quot;wss:&quot; &quot;//&quot;host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</span><br><span class="line">host = &lt;host, defined in [RFC3986],Section 3.2.2&gt;</span><br><span class="line">port = &lt;port, defined in [RFC3986],Section 3.2.3&gt;</span><br><span class="line">path = &lt;path-abempty, defined in [RFC3986],Section 3.3&gt;</span><br><span class="line">query = &lt;query, defined in [RFC3986],Section 3.4&gt;</span><br></pre></td></tr></table></figure></p>
<p>port部分是可选的；ws默认的端口是80，wss默认是443。</p>
<p>如果scheme部分匹配大小写不敏感的“wss”，那么URI就被称作是“安全的”。</p>
<p>“resource-name”可以由下面部分的拼接组成：</p>
<ul>
<li>“/“ 如果path部分是空的</li>
<li>path部分</li>
<li>? 如果query部分不为空</li>
<li>空的query部分</li>
</ul>
<p>片段（fragment）标识符在WebSocket URI环境是没意义的，不允许在这些URI中使用。<br>与任何的URI方案一样，当字符“#”不表示片段的开始时，必须转义为%23。</p>
<h2 id="打开握手-1"><a href="#打开握手-1" class="headerlink" title="打开握手"></a>打开握手</h2><h3 id="客户端要求"><a href="#客户端要求" class="headerlink" title="客户端要求"></a>客户端要求</h3><p>为建立WebSocket连接，客户端打开一个（TCP）连接并发送一个在这个章节里定义的握手。一个连接最初定义为CONNECTING状态。客户端需要提供WebSocket URI的部件：host、port、resource name、和secure标志，这些都是第3章里讨论的WebSocket URI的组件，伴随使用一些协议和扩展。另外，如果客户端是个web浏览器，它提供origin。<br>客户端运行在受限环境，如连接到特定关卡的移动手持设备上的浏览器，可能把连接的管理卸载给另一个网络代理。在这种情况下，用于本规范目的的客户端包括手持设备软件和任意的这类代理。</p>
<p>当客户端准备用建立WebSocket连接，给定的一组（host，port，resource name，secure标记），连同使用一序列协议和扩展，和在浏览器情况下有个origin，它必须打开一个（TCP）连接，发送一个打开握手，从响应里读取服务器的握手。（TCP）连接应该如何打开的准确要求，在打开握手应该发送什么，服务器响应应该如何解释，将在下面的章节里。在下面的文本里，我们将使用使用第3章里的名字，如“/host/”和“/secure/ flag”。</p>
<p>1、传递给这个算法（/host/, /port/, /resource name., and /secure/ flag）的WebSocket URI组件必须是合法的，依照第3章说明的WebSocket URI规范。如果有任何的组件是非法的，客户端必须使WebSocket 连接失败，并中止这些步骤。</p>
<p>2、如果客户端已经有WebSocket 连接到用 /host/ 和 /port/ 对 鉴定的远程主机，即使远程主机有另外的名字，客户端必须等待，直到那个连接已经建立或失败。必须保证不能有超过1个的连接处于CONNECTING状态。如果有多个到同一个IP地址的连接同时尝试，客户端必须串行化他们，使在没有超过1个的连接在同时执行下面的步骤。<br>如果客户端不能确定远程主机的IP地址（例如，所有的通信都是通过一个代理服务器来完成的，代理服务器自己执行DNS查询），为了此步骤的目的，那么客户端必须假设每个主机名指向不同的远程主机，而且，客户端应该限制同时pending的连接数量到一个合理的低的数量（例如，客户端可能允许同时pending的连接到a.example.com和 b.example.com，但如果有30个连接同时要求连接到单个主机，可能是不允许的）。例如，在一个web浏览器环境里，客户端需要考虑用户打开的网页选项卡的数量，来设置同时pending连接的限制数量。<br>注意：这使脚本仅仅通过打开大量到远程主机的WebSocket的连接来实施DNS估计更难了。当服务器受到攻击时，能通过在关闭之前挂起连接来减少负载，因为那将减少客户端重连的速率。<br>注意：客户端到单个远程主机的已建立WebSocket连接的数量是没有限制的。当承受高的负载时，服务器可以拒绝接收来自已经有过多数量连接的hosts/IP地址的连接，或断开耗资源的连接。</p>
<p>3、使用代理：如果客户端配置为使用代理，当使用WebSocket协议连接到/host/和/port/的主机，客户端应当连接到那个代理，告诉它打开一个TCP连接到给定的/host/和/port/的主机。<br>举例：例如，如果客户端对所有传输使用HTTP代理，如果它尝试连接到example.com服务器的端口80，它可能发送下面的行到代理服务器：<br>CONNECT example.com:80 HTTP/1.1<br>Host: example.com<br>如果有密码，连接看起来是这样的：<br>CONNECT example.com:80 HTTP/1.1<br>Host: example.com<br>Proxy-authorization: BasicZWRuYW1vZGU6bm9jYXBlcyE=<br>如果客户端没有配置使用代理，一个直接TCP连接应该打开到/host/ 和/port/指定的主机。<br>注意：Implementationsthat do not expose explicit UI for selecting a proxy for WebSocket connectionsseparate from other proxies are encouraged to use a SOCKS5 [RFC1928] proxy for<br>WebSocket connections, if available, orfailing that, to prefer the proxy configured for HTTPS connections over theproxy configured for HTTP connections.<br>For the purpose of proxy autoconfigurationscripts, the URI to pass the function MUST be constructed from /host/, /port/,/resource name/, and the /secure/ flag using the definition of a WebSocket URIas given in Section 3.<br>注意：The WebSocketProtocol can be identified in proxy autoconfiguration scripts from the scheme(“ws” for unencrypted connections and “wss” for encryptedconnections).</p>
<p>4、如果（TCP）连接不能打开，因为直接连接失败还是使用的任何代理返回错误，客户端必须使用WebSocket连接失败，并中止连接尝试。</p>
<p>5、如果/secure/是true，客户端必须在（TCP）连接上执行TLS握手，在打开连接后，发送握手数据【RFC2818】之前。如果这个失败了，客户端必须使WebSocket连接失败并中止连接。否则，所有在这条通道上的后续的通信必须使用加密通道【RFC5246】。<br>Clients MUST use the Server Name Indicationextension in the TLS handshake [RFC6066].</p>
<p>一旦到服务器的（TCP）连接建立（包括通过代理或TLS加密的通道），客户端必须发送一个打开握手到服务器。握手包含一个HTTPUpgrade请求，连同一些必须的和可选的头域。打开握手的要求如下：</p>
<ol>
<li><p>握手必须是一个合法的【RFC2616】规定的HTTP请求。</p>
</li>
<li><p>请求的方法必须是GET，HTTP版本必须至少是1.1。<br>例如，如果WebSocketURI是”ws://example.com/chat”，发送的第一行应该是”GET/chat HTTP/1.1”。</p>
</li>
<li><p>请求的Request-URI部分必须符合第3章定义的/resourcename/，或者是绝对的http/httpsURI，当解析后，有个/resourcename/，/host/,/port/，符合对应的ws/wssURI。</p>
</li>
<li><p>请求必须含有Host头域，它的值包含/host/加上可选的”:”后跟/port/（当没使用默认的端口时）。</p>
</li>
<li><p>请求必须包含Upgrade头域，其值必须含有”websocket”关键字。</p>
</li>
<li><p>请求必须含有Connection头域，其值必须含有”Upgrade”记号。</p>
</li>
<li><p>请求必须包含名为Sec-WebSocket-Key的头域，其值必须是nonce组成的随机选择的16字节的被base64编码后的值。必须为每个连接随机选择nonce。<br>注意：例如，如果随机选取的一序列字节值是0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09<br>0x0a0x0b 0x0c 0x0d 0x0e0x0f 0x10，头域的值应该是”AQIDBAUGBwgJCgsMDQ4PEC==”。</p>
</li>
<li><p>如果请求来自浏览器客户端，必须包含名为Origin的头域。如果连接来自非浏览器客户端，请求可能包括这个头域，如果那个客户端的语义符合此处浏览器客户端描述的用例。这个头域的值是建立连接的代码运行环境的origin的ASCII序列。在【RFC6454】有描述此头域值是如何构建的。<br>例如，下载子www.example.com的代码尝试建立连接到ww2.example.com，此头域的值应该是”<a href="http://www.example.com&quot;。" target="_blank" rel="noopener">http://www.example.com&quot;。</a></p>
</li>
<li><p>请求必须包含名为Sec-WebSocket-Version的头域，其值必须是13。<br>注意：Althoughdraft versions of this document (-09, -10, -11, and -12) were posted (they were mostlycomprised of editorial changesand clarifications and not changes to the wire protocol), values 9, 10, 11, and 12 were notused as valid valuesfor Sec-WebSocket-Version. These values were reserved in the IANA registrybut were not and will not be used.</p>
</li>
<li><p>请求可能包含名为Sec-WebSocket-Protocol的头域。如果有，此值指示客户端希望使用的一个或多个逗号分隔的子协议，按优选顺序。组成此值的元素必须是非空字符串，字符范围在U+0021到U+007E，不包括在【RFC2616】定义的分隔符，而且必须是唯一的字符串。此头域值的ABNF是1#token，构建和规则在【RFC2616】定义。</p>
</li>
<li><p>请求可能包含名为Sec-WebSocket-Extensions的头域。如果有，其值指示了客户端希望使用的协议级别的扩展。此头域的解释和格式在9.1节描述。</p>
</li>
<li><p>请求可能包含任意的其他头域。例如cookies和/或认证相关的头域，如Authorization头域。</p>
</li>
</ol>
<p>一旦客户端打开握手发送出去，在发送任何数据之前，客户端必须等待服务器的响应。客户端必须按如下步骤验证响应：<br>1、如果从服务器接收到的状态码不是101，按HTTP【RFC2616】程序处理响应。在特殊情况下，如果客户端接收到401状态码，可能执行认证；服务器可能用3xx状态码重定向客户端（但不要求客户端遵循他们），等等。否则按下面处理。</p>
<p>2、如果响应缺失Upgrade头域或Upgrade头域的值没有包含大小写不敏感的ASCII 值”websocket”，客户端必须使WebSocket连接失败。</p>
<p>3、如果响应缺失Connection头域或其值不包含大小写不敏感的ASCII值”Upgrade”，客户端必须使WebSocket连接失败。</p>
<p>4、如果响应缺失Sec-WebSocket-Accept头域或其值不包含 |Sec-WebSocket-Key |（作为字符串，非base64解码的）+ “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”的base64编码 SHA-1值，客户端必须使WebSocket连接失败。</p>
<p>5、如果响应包含Sec-WebSocket-Extensions头域，且其值指示使用的扩展不出现在客户端发送的握手（服务器指示的扩展不是客户端要求的），客户端必须使WebSocket连接失败。（解析此头域来决定哪个扩展是要求的在第9.1节描述。）</p>
<p>6、如果响应包含Sec-WebSocket-Protocol头域，且这个头域指示使用的子协议不包含在客户端的握手（服务器指示的子协议不是客户端要求的），客户端必须使WebSocket连接失败。</p>
<p>如果服务器响应不遵从4.2.2节和本节定义服务器握手的要求，客户端必须使WebSocket连接失败。</p>
<p>请注意，依据RFC2616，所有HTTP请求和HTTP响应的头域都是大小写不敏感的。</p>
<p>如果服务器的响应符合上面的验证要求，说明WebSocket连接建立，WebSocket连接处于OPEN状态。The <em>Extensions InUse</em> isdefined to be a (possibly empty) string, the value of which is equal to the valueof the |Sec-WebSocket-Extensions| header field supplied by the server’s handshake or the nullvalue if that header fieldwas not present in the server’s handshake. The <em>Subprotocol In Use</em> is defined tobe the value of the |Sec-WebSocket-Protocol| header field in the server’s handshake or thenull value if that headerfield was not present in the server’s handshake. Additionally, if any header fields in theserver’s handshake indicatethat cookies should be set (as defined by [RFC6265]), these cookies are referred to as<em>Cookies Set During the Server’s Opening Handshake</em>.</p>
<h3 id="服务器端要求"><a href="#服务器端要求" class="headerlink" title="服务器端要求"></a>服务器端要求</h3><p>服务器可能把连接的管理卸载给其他的网络代理，如负载均衡器和反向代理。在这种情况下，用于此规范目的的服务器被认为包含了服务器端基础设施的所有部分，从第一个终结TCP连接的设备一路直到处理请求并发送响应的服务器。<br>例如：一个数据中心可能有一台服务器用合适的握手来响应WebSocket请求，然后把连接传递给另一台服务器来实际处理数据帧。在本规范的目的中，“服务器”是两台电脑的结合。</p>
<h3 id="读取客户端打开握手"><a href="#读取客户端打开握手" class="headerlink" title="读取客户端打开握手"></a>读取客户端打开握手</h3><p>当一个客户端开始WebSocket连接，它发送自己角色的打开握手。服务器必须解析至少部分的握手来获取需要的信息，来生成服务器角色的握手。</p>
<p>客户端握手包含下面的部分。如果服务器在读取握手时，发现客户端发送的握手不符合下面的描述（注意，安装RFC2616，头域的顺序是不重要的），包括但不限于任何违反ABNF语法指定的握手组件，服务器必须停止处理客户端握手，并返回恰当的HTTP响应，如 400 badrequest。验证步骤：<br>1、一个HTTP/1.1或更高的GET请求，包括应该解释为/resourcename/的”Request-URI”（或者是一个绝对的HTTP/HTTPS URI包含/resource name/）。</p>
<p>2、一个Host头域包含服务器的职权（authority）。</p>
<p>3、一个Upgrade头域包含一个ASCII大小写不敏感的值”websocket”。</p>
<p>4、一个Connection 头域包含一个ASCII大小写不敏感的令牌”Upgrade”。</p>
<p>5、一个Sec-WebSocket-Key 头域有一个base64编码的值，解码后是一个16字节长度。</p>
<p>6、一个Sec-WebSocket-Version 头域且值为13。</p>
<p>7、可选的一个Origin头域。此头域由所有的浏览器客户端发送。缺少这个头域的连接不应该解释为来自浏览器客户端。</p>
<p>8、可选的一个Sec-WebSocket-Protocol 头域，有一序列的值，表示客户端希望用来交流的协议，按优选排序。</p>
<p>9、可选的一个Sec-WebSocket-Extensions头域。有一序列的值，表示客户端希望用来交流的扩展，按优选排序。此头域的解释在9.1节讨论。</p>
<p>10、可选的其他头域，用于发送cookie或请求认证到服务器。按RFC2616，未知的头域将被忽略。</p>
<h3 id="发送服务器打开握手"><a href="#发送服务器打开握手" class="headerlink" title="发送服务器打开握手"></a>发送服务器打开握手</h3><p>当客户端建立一个到服务器的WebSocket连接，服务器必须完成下面的步骤来接受连接，并发送服务器打开握手。</p>
<p>1、如果连接在HTTPS（HTTP-over-TLS）端口上打开，在连接上执行TLS握手。如果失败了，关闭连接；否则，连接的所有后续的通信（包括服务器握手）必须在加密的通道上进行。</p>
<p>2、服务器可以执行额外的客户端验证，例如，通过返回401状态码和相应的|WWW-Authenticate|头域。</p>
<p>3、服务器可能用3xx状态码来重定向客户端。注意，这个步骤可以和上面描述的认证步骤 一起、之前或之后发生。</p>
<p>4、建立下面的信息：<br>/origin/<br>客户端握手的|Origin|头域指示了建立连接的脚本的起源。起源被序列化为ASCII，并转换为小写。服务器可能使用这个信息来作为决定是否接收连接的部分因素。如果服务器不能验证起源，它将接收来自任何地方的连接。如果服务器不想接收这个连接，它必须返回合适的HTTP错误码（如403Forbidden），并中止WebSocket握手，按本节的描述。更多细节，见第10章。</p>
<p>/key/<br>客户端握手的|Sec-WebSocket-Key|包含一个base64编码的值，如果解码，将是16字节长度。此值（编码后的）用于创建服务器握手，来指示接收连接。服务器没有必要base64解码此值。</p>
<p>/version/<br>客户端握手的|Sec-WebSocket-Version|包含WebSocket协议的版本，客户端用这个来尝试通信。如果这个版本不符合服务器能理解的版本，服务器必须中止WebSocket握手，发送一个合适HTTP错误码（如426 Upgrade Required），且有一个|Sec-WebSocket-Version|头域来指示服务器能够理解的版本。</p>
<p>/resource name/<br>一个用于服务器提供的服务的标识符。如果服务器提供了多个服务，值应该能从resourcename推断得到，从给定客户端握手的GET方法的”Request-URI”。如果请求的服务不可得，服务器必须发送合适的HTTP错误码（如404 Not Found），并中止WebSocket握手。</p>
<p>/subprotocol/<br>或者是空，或者是单个值表示服务器准备使用的子协议。值的选择必须从客户端握手推断得到，具体是从|Sec-WebSocket-Protocol|选择一个值，服务器将用于这个连接的。如果客户端握手不包含这样1个头域或者服务器不同意使用客户端请求的子协议，唯一可接受的值是null。没有这个域等价于null值（意味着如果服务器不打算使用任何推荐的子协议，它必须不发送回一个|Sec-WebSocket-Protocol|头域在它的响应里）。在这个目的上，Empty字符串不同于null值，且不是这个域的合法值。用于此头域值的ABNF是（token），构建和规则在RFC2616定义。</p>
<p>/extensions/<br>一个（可能空的）列表表示服务器准备使用的协议级扩展。如果服务器支持多个扩展，那么值必须从客户端握手推断得到，具体是从|Sec-WebSocket-Extensions|域选择一个或多个值。此域的缺失等价于null值。在这个目的上，Empty字符串不同于null值。没有列在客户端的扩展必须不被登记。选择和解释这些值的方法在9.1节讨论。</p>
<p>5、如果服务器选择接受连接，必须返回一个合法的HTTP响应，指示下面：</p>
<ol>
<li><p>一个状态行，有101响应码，按照RFC2616。这样一个响应看起来是这样：<br>“HTTP/1.1 101 Switching Protocols”</p>
</li>
<li><p>一个Upgrade 头域，值为”websocket”，按照RFC2616。</p>
</li>
<li><p>一个Connection头域，值为”Upgrade”。</p>
</li>
<li><p>一个Sec-WebSocket-Accept 头域。</p>
</li>
</ol>
<h2 id="数据成帧"><a href="#数据成帧" class="headerlink" title="数据成帧"></a>数据成帧</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在WebSocket协议，数据是用一序列帧来传输。为了避免使网络中间设施（如拦截代理）混乱和安全原因（更多讨论在10.3节），客户端必须标记所有发往服务器的帧（更多细节在5.3节）。（注意，进行标记是不管WebSocket协议是否使用了TLS。）当服务器接收到一个没有标记的帧时必须关闭连接。在这种情况下，服务器可能发送一个有状态码1002（协议错误）的关闭帧，如7.4.1节定义。服务器必须不标记它发给客户端的任何帧。客户端必须关闭连接，如果它检测到标记了的帧。在这种情况下，它可能使用1002状态码（协议错误）。（这些规则在未来的规范中可能放松。）</p>
<p>基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的”Extension data”和”Application data”，统称为”Payload data”。保留了一些特殊位和操作码供后期扩展。</p>
<p>在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送（见5.5.1节）。</p>
<h3 id="基本的帧协议"><a href="#基本的帧协议" class="headerlink" title="基本的帧协议"></a>基本的帧协议</h3><p>用于数据传输部分的有线格式用ABNF描述，细节在本节。（注意，不像本文档中的其他章节，本节的ABNF是作用于一组比特位上。每组比特位的长度在注释里指示。当在有线上编码后，最重要的比特的最左边的ABNF）。帧的一个高层概览见下图。当下图与ABNF有冲突时，图是权威的。</p>
<p><img src="http://7tsys1.com1.z0.glb.clouddn.com/Selection_062.png" alt="enter image description here"></p>
<p><strong><code>FIN</code></strong>： 1bit<br>表示此帧是否是消息的最后帧。第一帧也可能是最后帧。<br><strong><code>RSV1，RSV2，RSV3</code></strong>： 各1bit<br>必须是0，除非协商了扩展定义了非0的意义。如果接收到非0，且没有协商扩展定义  此值的意义，接收端必须使WebSocket连接失败。<br><strong><code>Opcode</code></strong>： 4bit<br>定义了”Payloaddata”的解释。如果接收到未知的操作码，接收端必须使WebSocket       连接失败。下面的值是定义了的。</p>
<ul>
<li>%x0 表示一个后续帧</li>
<li>%x1 表示一个文本帧</li>
<li>%x2 表示一个二进制帧</li>
<li>%x3-7 为以后的非控制帧保留</li>
<li>%x8 表示一个连接关闭</li>
<li>%x9 表示一个ping</li>
<li>%xA 表示一个pong</li>
<li>%xB-F 为以后的控制帧保留</li>
</ul>
<p><strong><code>Mask</code></strong>： 1bit<br>定义了”Payload data”是否标记了。如果设为1，必须有标记键出现在masking-key，用   来unmask “payload data”，见5.3节。所有从客户端发往服务器的帧必须把此位设为1。</p>
<p><strong><code>Payload length</code></strong>： 7bit, 7 + 16bit, 7 + 64bit<br>“Payloaddata”的长度，字节单位。如果值是0-125，则是有效载荷长度。如果是126，   接下来的2字节解释为16位无符号整数，作为有效载荷长度。如果127，接下来的8  字节解释为64位无符号整数（最高位必须是0），作为有效载荷长度。多字节长度数值    以网络字节序表示。注意，在任何情况下，必须用最小数量的字节来编码长度，例如，       124字节 长的字符串不能编码为序列126, 0, 124。有效载荷长度是”Extension data”的长     度加上”Application data”的长度。”Extension data”的长度可能是0，在这种情况下，    有效载荷长度是”Applicationdata”的长度。</p>
<p><strong><code>Masking-key</code></strong>：0或4字节<br>所有从客户端发往服务器的帧必须用32位值标记，此值在帧里。如果mask位设为1， 此字段（32位值）出现，否则缺失。更多的信息在5.3节，客户端到服务器标记。</p>
<p><strong><code>Payload data</code></strong>： (x + y)字节<br>“Payloaddata” 定义为”extensiondata” 后接”application data”。</p>
<p><strong><code>Extension data</code></strong>： x 字节<br>“Extensiondata”是0字节，除非协商了扩张。所有扩张必须指定”extensiondata”的长度，      或者如何计算长度，如何使用扩展必须在打开握手时进行协商。如果有，”Extension data”包括在有效载荷长度。</p>
<p><strong><code>Application data</code></strong>： y字节<br>任意”Applicationdata”占据了帧的剩余部分，在”Extensiondata”之后。 “Applicationdata”的长度等于有效载荷长度减去”Extensiondata”的长度。</p>
<h3 id="客户端到服务器标记"><a href="#客户端到服务器标记" class="headerlink" title="客户端到服务器标记"></a>客户端到服务器标记</h3><p>被标记的帧必须设置frame-masked域为1，如5.2节定义。标记键必须作为frame-masking-key完整包含在帧里，作为frame-masking-key，如5.2节定义。它用于标记”Payload data”。</p>
<p>标记键是由客户端随机选择的32位值。准备标记帧时，客户端必须从一组允许的32位值选择一个新的标记键。标记键应该是不可预测的，因此，标记键必须推断自强源的熵（strong source of entropy），给定帧的标记键必须不能简单到服务器或代理可以预测标记键是用于一序列帧的。不可预测的标记键是阻止恶意应用的作者从wire上获取数据的关键。RFC 4086  discusses what entails a suitable source of entropy forsecurity-sensitive applications.</p>
<p>标记不影响”Payloaddata”的长度。为了把标记数据转换为非标记数据，或反转，下面的算法将被应用。同样的算法将应用，而不管转换的方向，例如同样的步骤将用于标记数据和unmask数据。</p>
<p>转换后的数据八位字节i （transformed-octet-i）是 原始八位字节i（original-octet-i）与 标记键在 i 对 4 取模（j = i % 4）后的位序的八位字节（masking-key-octet-j）的 异或(XOR)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j  =   i  MOD  4</span><br><span class="line">transformed-octet-i = original-octec-i  XOR masking-key-octet-j</span><br></pre></td></tr></table></figure>
<p>译者给出的Scala语言实现：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mask</span></span>(key: <span class="type">Array</span>[<span class="type">Byte</span>],data: <span class="type">Array</span>[<span class="type">Byte</span>])&#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> untildata.length) &#123;</span><br><span class="line">    <span class="keyword">val</span> j = i &amp; <span class="number">3</span> <span class="comment">// 对4 取模</span></span><br><span class="line">    data(i) = (data(i) ^ key(j)).toByte</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>帧里的有效载荷长度指示frame-payload-length，不包括masking key的长度。它是”Payloaddata”，如，masking key的后续字节 的长度。</p>
<h3 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h3><p>分帧的首要目的是允许发送开始时不知道长度的消息，不需要缓存消息。如果消息不能分帧，那么终端得缓存整个消息，以便在发送前计算长度。有了分帧，服务器或中间设施可以选择一个合理大小的缓存，当缓存满时，把帧写到网络。</p>
<p>分帧的第二个用例是多路复用，在不值得大消息独占逻辑输出通道的地方，多路复用需要自由地把消息划分更小的帧来更好地共享输出通道。(注意，多路技术扩展不在本文档描述。)</p>
<p>除非另有扩展说明，分帧没有语义上的意义。中间设施可能合并 和/或分隔帧，如果客户端和服务器没有协商扩展，或协商了扩展，但中间设施明白所有协商了的扩展，并知道如何合并 和/或拆分帧。分帧的实现在没有扩展时，发送者和接收者必须不能依赖于帧的边界。</p>
<p>分帧的规则：<br>A、一个未分帧的消息包含单个帧，FIN设置为1，opcode非0。</p>
<p>B、一个分帧了的消息包含：<br>开始于：单个帧，FIN设为0，opcode非0；<br>后接  ：0个或多个帧，FIN设为0，opcode设为0；<br>终结于：单个帧，FIN设为1，opcode设为0。<br>一个分帧了消息在概念上等价于一个未分帧的大消息，它的有效载荷长度等于所有帧的       有效载荷长度的累加；然而，有扩展时，这可能不成立，因为扩展定义了出现的       “Extension data”的解释。例如，”Extensiondata”可能只出现在第一帧，并  用于后续的所有帧，或者”Extensiondata”出现于所有帧，且只应用于特定的那个  帧。在缺少”Extensiondata”时，下面的示例示范了分帧如何工作。</p>
<p>举例：如一个文本消息作为三个帧发送，第一帧的opcode是0x1，FIN是0，第二帧 的opcode是0x0，FIN是0，第三帧的opcode是0x0，FIN是1。</p>
<p>C、控制帧（见5.5节）可能被插入到分帧了消息中。控制帧必须不能被分帧。</p>
<p>D、消息的帧必须以发送者发送的顺序传递给接受者。</p>
<p>E、一个消息的帧必须不能交叉在其他帧的消息中，除非有扩展能够解释交叉。</p>
<p>F、一个终端必须能够处理消息帧中间的控制帧。</p>
<p>G、一个发送者可能对任意大小的非控制消息分帧。</p>
<p>H、客户端和服务器必须支持接收分帧和未分帧的消息。</p>
<p>I、由于控制帧不能分帧，中间设施必须不尝试改变控制帧。</p>
<p>J、中间设施必须不修改消息的帧，如果保留位的值已经被使用，且中间设施不明白这些值的含义。</p>
<p>在扩展已经被协商好，且中间设施不知道已协商扩展的语义的环境，中间设施必须不修改任何消息的帧。类似地，anintermediary that didn’t see theWebSocket handshake (and wasn’t notified about its content) that resulted in a WebSocketconnection MUST NOT change thefragmentation of any message of such connection.</p>
<p>K、作为这些规则的结果，一个消息的所有帧属于同样的类型，由第一个帧的opcdoe指定。由于控制帧不能分帧，消息的所有帧的类型要么是文本、二进制数据或保留的操作码中的一个。</p>
<p>注意：如果控制帧不能插入，例如，ping的延迟将会很长，如果是在一个大消息后面。因此要求处理消息帧中间的控制帧。</p>
<p>实现注意：如果没有任何扩展，接收者不需要为了处理而缓存整个帧。例如，如果使用了流API，帧的一部分可以传递给应用程序。然而，这个假设在未来的WebSocket扩展中可能不成立。</p>
<h3 id="控制帧"><a href="#控制帧" class="headerlink" title="控制帧"></a>控制帧</h3><p>控制帧由操作码标识，操作码的最高位是1。当前为控制帧定义的操作码有0x8（关闭）、0x9（Ping）和0xA（Pong），操作码0xB-0xF是保留的，未定义。</p>
<p>控制帧用来交流WebSocket的状态，能够插入到消息的多个帧的中间。</p>
<p>所有的控制帧必须有一个小于等于125字节的有效载荷长度，必须不能被分帧。</p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>关闭帧有个操作码0x8。</p>
<p>关闭帧可能包含一个主体（帧的应用数据部分）指明关闭的原因，如终端关闭，终端接收到的帧太大，或终端接收到的帧不符合终端的预期格式。如果有主体，主体的前2个字节必须是2字节的无符号整数（按网络字节序），表示以/code/（7.4节定义）的值为状态码。在2字节整数后，主体可能包含一个UTF-8编码的字符串表示原因。这些数据不一定要人类可读，但对调试友好，或给打开连接的脚本传递信息。由于不保证数据是人类可读的，客户端必须不显示给用户。</p>
<p>从客户端发送到服务器的关闭帧必须标记，按5.3节。</p>
<p>在发送关闭帧后，应用程序必须不再发送任何数据。</p>
<p>如果终端接收到一个关闭帧，且先前没有发送关闭帧，终端必须发送一个关闭帧作为响应。（当发送一个关闭帧作为响应时，终端典型地以接收到的状态码作为回应。）它应该尽快实施。终端可能延迟发送关闭帧，直到它的当前消息发送完成（例如，如果分帧消息的大部分已发送，终端可能在关闭帧之前发送剩余的帧）。然而，不保证已经发送了关闭帧的终端继续处理数据。</p>
<p>在发送和接收到关闭消息后，终端认为WebSocket连接已关闭，必须关闭底层的TCP连接。服务器必须立即关闭底层的TCP连接；客户端应该等待服务器关闭连接，但可能在发送和接收到关闭消息后关闭，例如，如果它在合理的时间间隔内没有收到TCP关闭。</p>
<p>如果客户端和服务器同时发送关闭消息，两端都已发送和接收到关闭消息，应该认为WebSocket连接已关闭，并关闭底层TCP连接。</p>
<h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>Ping帧包含操作码0x9。</p>
<p>一个Ping帧可能包含应用程序数据。</p>
<p>当接收到Ping帧，终端必须发送一个Pong帧响应，除非它已经接收到一个关闭帧。它应该尽快返回Pong帧作为响应。Pong帧在5.5.3节讨论。</p>
<p>终端可能在连接建立后、关闭前的任意时间内发送Ping帧。</p>
<p>注意：Ping帧可作为keepalive或作为验证远程终端是否可响应的手段。</p>
<h4 id="Pong"><a href="#Pong" class="headerlink" title="Pong"></a>Pong</h4><p>Pong帧包含操作码0xA。</p>
<p>5.5.2节的详细要求适用于Ping和Pong帧。</p>
<p>Pong 帧必须包含与被响应Ping帧的应用程序数据完全相同的数据。</p>
<p>如果终端接收到一个Ping 帧，且还没有对之前的Ping帧发送Pong 响应，终端可能选择发送一个Pong 帧给最近处理的Ping帧。</p>
<p>一个Pong 帧可能被主动发送，这作为单向心跳。对主动发送的Pong 帧的响应是不希望的。</p>
<h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p>数据帧（如非控制帧）由操作码标识，操作码的最高位是0。当前为数据帧定义的操作码有0x1（文本），0x2（二进制）。操作码0x3-0x7 为以后的非控制帧保留，未定义。</p>
<p>数据帧携带 应用程序层和/或扩展层 数据。操作码决定了数据的解释：<br>文本：<br>有效载荷数据是UTF-8编码的文本数据。注意，特定的文本帧可能包含部分的UTF-8   序列，然而，整个消息必须包含有效的UTF-8。重新聚合后的非法的UTF-8的处理在8.1  节描述。</p>
<p>二进制：<br>有效载荷数据是任意的二进制数据，它的解释由应用程序层唯一决定。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>单个未标记的文本消息帧：<br>0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f(contains “Hello”)</p>
<p>单个标记了的文本消息帧：<br>0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains “Hello”)</p>
<p>分帧了的未标记的文本消息：<br>0x01 0x03 0x48 0x65 0x6c (contains “Hel”)<br>0x80 0x02 0x6c 0x6f(contains “lo”)</p>
<p>未标记的Ping请求和标记了的Ping 响应：<br>0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f(contains a body of “Hello”, but the contents of the body arearbitrary)</p>
<p>0x8a0x85 0x37 0xfa 0x21 0x3d 0x7f0x9f 0x4d 0x51 0x58 (contains abody of “Hello”, matching the body of the ping)</p>
<p>含有256字节二进制数据消息的单个未标记帧：<br>0x82 0x7E 0x0100 [256 bytes of binary data]</p>
<p>64KB二进制数据消息在单个未标记帧：<br>0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>协议旨在允许扩展，将给基础协议添加功能。连接的终端必须在打开握手中协商使用任意的扩展。这个规范提供了操作码0x3到0x7和0xB到0xF，帧头的“Extensiondata”域，和frame-rsv1,frame-rsv2和frame-rsv3 位供扩展使用。扩展的协商在9.1节讨论。下面是一些期望的扩展使用，这个清单既不是完整的也不是规范。<br>A、”extensiondata” 可能在”applicationdata”之前放置。</p>
<p>B、保留位可能按帧的需要分配。</p>
<p>C、保留的操作码可以定义。</p>
<p>D、保留位可以分配给操作码域，如果需要更多的操作码。、</p>
<p>E、保留位或扩展操作码可以定义在”Payload data”外分配额外的位来定义更大的操作码或     更多的特定帧位。</p>
<h2 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h2><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>为在WebSocket连接上发送一个由/data/组成的WebSocket消息，终端必须执行下面的步骤：</p>
<ol>
<li><p>终端必须确保WebSocket连接处于OPEN状态。在任何时刻，如果WebSocket连接的    状态改变，终端必须终止下面的步骤。</p>
</li>
<li><p>终端必须按5.2节在WebSocket帧里封装数据。如果数据太大或者如果数据在终端准备 开始发送数据时不能完整可得，终端可能选择封装数据为一序列的帧，按5.4节。</p>
</li>
<li><p>包含数据的第一帧的操作码（frame-opcode）必须设置为恰当的值，按5.2节，因为这   决定数据将被接收者解释为文本或二进制数据。</p>
</li>
<li><p>包含数据的最后帧的FIN位（frame-fin）必须设置为1，如5.2节定义。</p>
</li>
<li><p>如果数据由客户端发送，帧必须被标记，如5.3节定义。</p>
</li>
<li><p>如果为WebSocket连接协商了扩展（第9章），额外的考虑可能按定义的扩展 应用。</p>
</li>
<li><p>已形成的帧必须在底层的网络连接上传输。</p>
</li>
</ol>
<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>为了接收WebSocket数据，终端监听底层的网络连接。到来的数据必须按5.2节定义的WebSocket帧解析。如果接收到控制帧，必须按5.5节的定义处理。当接收到数据帧时，终端必须知道数据的类型，通过操作码（frame-opcode）定义。帧的”Application data”是定义为消息的/data/的。如果帧包含一个未分帧的消息，就是说接收到一个包含类型和数据的WebSocket消息。如果帧是分帧了的消息的一部分，应用数据是后续帧的数据的拼接。当最后帧（有FIN位指示）接收到时，就是说WebSocket消息接收到了，数据由所有帧的应用数据拼接组成，类型由第一帧指示。后续的数据帧必须解释为属于新的WebSocket消息的。</p>
<p>扩展（第9章）可能改变如何读取数据的语义，具体包括什么组成消息的边界。扩展，在”Applicationdata”前添加”Extensiondata”，是计入有效载荷的，也可能修改”Application data”。</p>
<p>服务器必须移除从客户端接收到的数据帧的标记，如5.3节。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/WebSockets/Writing_WebSocket_client_applications" target="_blank" rel="noopener">Writing WebSocket client applications</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/websockets/basics/" target="_blank" rel="noopener">WebSockets 简介：将套接字引入网络</a></li>
</ul>


  
    <div class="comments" id="comments">
      
        <div onclick="showGitment()" id="gitment-display-button">如果你有不同看法？</div>
        <div id="gitment-container" style="display:none"></div>
      
    </div>
  

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div>




    
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    



      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.href, 
            owner: 'mickeyouyou',
            repo: 'blog_comment',
            
            lang: "en" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '27804beebc0d0aa2ae7271191fd5adac6d1b8cb7',
            
                client_id: '57e78fbfba943c338437'
            }});
        gitment.render('gitment-container');
      }

      
          function showGitment(){
            document.getElementById("gitment-display-button").style.display = "none";
            document.getElementById("gitment-container").style.display = "block";
            renderGitment();
          }
      
      </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    




</body>
</html>