<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <link rel="stylesheet" href="/css/main.css" type="text/css">
    <link rel="stylesheet" href="/css/style.css" type="text/css">
    
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="/images/icon.png">

    
    <title>php7-implementation-hashtable</title>
</head>

<body>

<h3 id="PHP7_内核的HashTable实现与数据结构的对比">PHP7 内核的HashTable实现与数据结构的对比</h3><h4 id="HashTable">HashTable</h4><p>即哈希表，又名散列表，是根据关键字（key value)直接访问在内存存储位置的数据结构。是一种将随机访问的数据结构转换为有序储存的数据结构。它通过把键值通过一个函数的计算，映射到表中一个位置来访问，此函数称为散列函数。现在很多高级程序语言中都有实现HashTable，而C语言中最常用的是uthashtable。</p>
<p>HashTable的结构有所变化，直接定义为了<code>_zend_array</code>，且从文件<code>zend_hash.h</code>移到了<code>zend_types.h</code>.</p>
<h4 id="数据结构">数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_array HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_array &#123;</span><br><span class="line">	zend_refcounted   gc;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar    flags,</span><br><span class="line">				zend_uchar    nApplyCount,</span><br><span class="line">				zend_uchar    nIteratorsCount,</span><br><span class="line">				zend_uchar    reserve)</span><br><span class="line">		&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> flags;</span><br><span class="line">	&#125; u;</span><br><span class="line">	<span class="keyword">uint32_t</span>          nTableMask;     <span class="comment">/* 掩码,用于根据hash值计算存储位置,永远等于nTableSize-1 */</span></span><br><span class="line">	Bucket           *arData;            <span class="comment">/* 存放实际数据 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>          nNumUsed;          <span class="comment">/* arData数组已经使用的数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>          nNumOfElements;    <span class="comment">/* hash表中元素个数 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>          nTableSize;        <span class="comment">/* hash表的大小 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>          nInternalPointer;  <span class="comment">/* 用于HashTable遍历 */</span></span><br><span class="line">	zend_long         nNextFreeElement;  <span class="comment">/* 下一个空闲可用位置的数字索引 */</span></span><br><span class="line">	<span class="keyword">dtor_func_t</span>       pDestructor;       <span class="comment">/* 析构函数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的结构定义中，<code>_zend_array</code>结构体构成一个完整的HashTable</p>
<h3 id="HashTable操作">HashTable操作</h3><h4 id="HashTable初始化">HashTable初始化</h4><p>创建一个HashTable有很多途径，最终调用的都是<code>_zend_hash_init</code>函数，</p>
<p>zend_hash.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API <span class="keyword">void</span> ZEND_FASTCALL _zend_hash_init(HashTable *ht, <span class="keyword">uint32_t</span> nSize, <span class="keyword">dtor_func_t</span> pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)</span><br><span class="line">&#123;</span><br><span class="line">	GC_REFCOUNT(ht) = <span class="number">1</span>;</span><br><span class="line">	GC_TYPE_INFO(ht) = IS_ARRAY;</span><br><span class="line">	ht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : <span class="number">0</span>) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;</span><br><span class="line">	ht-&gt;nTableSize = zend_hash_check_size(nSize);</span><br><span class="line">	ht-&gt;nTableMask = HT_MIN_MASK;</span><br><span class="line">	HT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket);</span><br><span class="line">	ht-&gt;nNumUsed = <span class="number">0</span>;</span><br><span class="line">	ht-&gt;nNumOfElements = <span class="number">0</span>;</span><br><span class="line">	ht-&gt;nInternalPointer = HT_INVALID_IDX;</span><br><span class="line">	ht-&gt;nNextFreeElement = <span class="number">0</span>;</span><br><span class="line">	ht-&gt;pDestructor = pDestructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pDestructor是HashTable元素的析构指针，在更新/销毁HashTable中的元素时候会使用。在这里并没有初始化arData，它会在使用HashTable的时候来创建。</p>
<h4 id="更新HashTable">更新HashTable</h4><p>新的实现中，将以前添加和更新元素的<code>api_zend_hash_add_or_update</code>变成了现在的<code>_zend_hash_add_or_update_i</code>，其他的对HashTable的新增和更新的操作全部是基于<code>_zend_hash_add_or_update_i</code>实现的宏。下面是<code>_zend_hash_add_or_update_i</code>的实现：<br>zend_hash.c </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_always_inline zval *_zend_hash_add_or_update_i(HashTable *ht, zend_string *key, zval *pData, <span class="keyword">uint32_t</span> flag ZEND_FILE_LINE_DC)</span><br><span class="line">&#123;</span><br><span class="line">	zend_ulong h;</span><br><span class="line">	<span class="keyword">uint32_t</span> nIndex;</span><br><span class="line">	<span class="keyword">uint32_t</span> idx;</span><br><span class="line">	Bucket *p;</span><br><span class="line"></span><br><span class="line">	IS_CONSISTENT(ht);</span><br><span class="line">	HT_ASSERT(GC_REFCOUNT(ht) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查hashtable是否初始化 */</span></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(!(ht-&gt;u.flags &amp; HASH_FLAG_INITIALIZED))) &#123; </span><br><span class="line">		CHECK_INIT(ht, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">add_t</span>o_hash;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ht-&gt;u.flags &amp; HASH_FLAG_PACKED) &#123;</span><br><span class="line">		<span class="keyword">zend_hash_packed_t</span>o_hash(ht);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flag &amp; HASH_ADD_NEW) == <span class="number">0</span>) &#123;</span><br><span class="line">		p = zend_hash_find_bucket(ht, key);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			zval *data;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* key已经存在产生添加冲突，退出 */</span></span><br><span class="line">			<span class="keyword">if</span> (flag &amp; HASH_ADD) &#123;</span><br><span class="line">				<span class="keyword">return</span> NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* key存在的情况下，值不一样做更新操作 */</span></span><br><span class="line">			ZEND_ASSERT(&amp;p-&gt;val != pData);</span><br><span class="line">			data = &amp;p-&gt;val;</span><br><span class="line">			<span class="keyword">if</span> ((flag &amp; HASH_UPDATE_INDIRECT) &amp;&amp; Z_TYPE_P(data) == IS_INDIRECT) &#123;</span><br><span class="line">				data = Z_INDIRECT_P(data);</span><br><span class="line">			&#125;</span><br><span class="line">			HANDLE_BLOCK_INTERRUPTIONS();</span><br><span class="line">			<span class="comment">/* 释放掉原来的data */</span></span><br><span class="line">			<span class="keyword">if</span> (ht-&gt;pDestructor) &#123;</span><br><span class="line">				ht-&gt;pDestructor(data);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 将新的pData值复制给原来的data */</span></span><br><span class="line">			ZVAL_COPY_VALUE(data, pData);</span><br><span class="line">			HANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ZEND_HASH_IF_FULL_DO_RESIZE(ht);		<span class="comment">/* If the Hash table is full, resize it */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_t</span>o_hash:</span><br><span class="line">	HANDLE_BLOCK_INTERRUPTIONS();</span><br><span class="line">	idx = ht-&gt;nNumUsed++;  <span class="comment">/* 已使用计数+1，并且用老的位置来做为索引 */</span></span><br><span class="line">	ht-&gt;nNumOfElements++;  <span class="comment">/* 元素个数加1 */</span></span><br><span class="line">	<span class="keyword">if</span> (ht-&gt;nInternalPointer == HT_INVALID_IDX) &#123;</span><br><span class="line">		ht-&gt;nInternalPointer = idx;</span><br><span class="line">	&#125;</span><br><span class="line">	zend_hash_iterators_update(ht, HT_INVALID_IDX, idx);</span><br><span class="line">	p = ht-&gt;arData + idx;   <span class="comment">/* 指针加法移位 */</span></span><br><span class="line">	p-&gt;key = key;</span><br><span class="line">	<span class="keyword">if</span> (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">		zend_string_addref(key);</span><br><span class="line">		ht-&gt;u.flags &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">		zend_string_hash_val(key);  <span class="comment">/* 计算key的hash值 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;h = h = ZSTR_H(key);</span><br><span class="line">	ZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class="line">	nIndex = h | ht-&gt;nTableMask; <span class="comment">/* 与tablemask进行计算得出hash索引 */</span></span><br><span class="line">	Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);  <span class="comment">/* 新的元素的hash冲突链表的next指向当前冲突链表的首部元素 */</span></span><br><span class="line">	HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx); <span class="comment">/* 新的元素放到当前hash冲突链表的头部 */</span></span><br><span class="line">	HANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;p-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的<code>api _zend_hash_add_or_update_i</code>可以看出，其实更新操作很简单的，验证key是否存在，key存在的情况下如果值相等的话不做任何的操作，值不相同做更新操作。<br>这里比较重要的是hash表的新增，这里会涉及hash索引以及hash冲突链表。上面代码中的<code>add_to_hash</code>部分的代码主要就是在做这部分的做操。从上面的代码中可以看出，<code>ht-&gt;arData</code> 其实就是一个不定长的Bucket数组，它利用 <code>ht-&gt;nNumUsed</code> 来计算这个数组下一个空闲位置,然后将新的Bucket放到这个位置上。计算得到传入的key的hash值，然后与 <code>ht-&gt;nTableMask</code>进行按位与得出新的bucket对应的 <code>ht-&gt;arHash</code>上的位置 ,这里就完成了hash表的构造。</p>
<p>但是还有个非常重要的地方，就是hash冲突的解决。hash冲突一直都是以一个链表来解决的，当出现hash冲突时候会将相同hash值的bucket连接成一个链表，然后进行查找时候是一个个的遍历，一个个的对比key值是否相同。和NG之前不同的是，现在的hash冲突链表被放到了<code>__zval_struct</code> 结构中，而不是以前的Bucket里面。下面先是新老结构的对比</p>
<h4 id="删除元素">删除元素</h4><p>Zend提供了一系列删除HashTable中元素的API，，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_always_inline <span class="keyword">void</span> _zend_hash_del_el_ex(HashTable *ht, <span class="keyword">uint32_t</span> idx, Bucket *p, Bucket *prev)</span><br><span class="line"><span class="keyword">static</span> zend_always_inline <span class="keyword">void</span> _zend_hash_del_el(HashTable *ht, <span class="keyword">uint32_t</span> idx, Bucket *p)</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> ZEND_FASTCALL <span class="title">zend_hash_del_bucket</span><span class="params">(HashTable *ht, Bucket *p)</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> ZEND_FASTCALL <span class="title">zend_hash_del</span><span class="params">(HashTable *ht, zend_string *key)</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> ZEND_FASTCALL <span class="title">zend_hash_del_ind</span><span class="params">(HashTable *ht, zend_string *key)</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> ZEND_FASTCALL <span class="title">zend_hash_str_del_ind</span><span class="params">(HashTable *ht, <span class="keyword">const</span> <span class="keyword">char</span> *str, size_t len)</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> ZEND_FASTCALL <span class="title">zend_hash_str_del</span><span class="params">(HashTable *ht, <span class="keyword">const</span> <span class="keyword">char</span> *str, size_t len)</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> ZEND_FASTCALL <span class="title">zend_hash_index_del</span><span class="params">(HashTable *ht, zend_ulong h)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_del(ht)</span><br></pre></td></tr></table></figure>
<h4 id="清空HashTable">清空HashTable</h4><p><code>zend_hash_clean(ht)</code></p>
<h4 id="销毁HashTable">销毁HashTable</h4><p>HashTable的销毁是由<code>zend_hash_destroy</code>来负责的，使用：<br><code>zend_hash_destroy(ht)</code><br>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> ZEND_FASTCALL <span class="title">zend_hash_destroy</span><span class="params">(HashTable *ht)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Bucket *p, *end;</span><br><span class="line"></span><br><span class="line">	IS_CONSISTENT(ht);</span><br><span class="line">	HT_ASSERT(GC_REFCOUNT(ht) &lt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ht-&gt;nNumUsed) &#123;</span><br><span class="line">		p = ht-&gt;arData;</span><br><span class="line">		end = p + ht-&gt;nNumUsed;</span><br><span class="line">		<span class="keyword">if</span> (ht-&gt;pDestructor) &#123;</span><br><span class="line">			SET_INCONSISTENT(HT_IS_DESTROYING);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ht-&gt;u.flags &amp; (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ht-&gt;nNumUsed == ht-&gt;nNumOfElements) &#123;</span><br><span class="line">					<span class="keyword">do</span> &#123;</span><br><span class="line">						ht-&gt;pDestructor(&amp;p-&gt;val);</span><br><span class="line">					&#125; <span class="keyword">while</span> (++p != end);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">do</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (EXPECTED(Z_TYPE(p-&gt;val) != IS_UNDEF)) &#123;</span><br><span class="line">							ht-&gt;pDestructor(&amp;p-&gt;val);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">while</span> (++p != end);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ht-&gt;nNumUsed == ht-&gt;nNumOfElements) &#123;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					ht-&gt;pDestructor(&amp;p-&gt;val);</span><br><span class="line">					<span class="keyword">if</span> (EXPECTED(p-&gt;key)) &#123;</span><br><span class="line">						zend_string_release(p-&gt;key);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">while</span> (++p != end);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (EXPECTED(Z_TYPE(p-&gt;val) != IS_UNDEF)) &#123;</span><br><span class="line">						ht-&gt;pDestructor(&amp;p-&gt;val);</span><br><span class="line">						<span class="keyword">if</span> (EXPECTED(p-&gt;key)) &#123;</span><br><span class="line">							zend_string_release(p-&gt;key);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">while</span> (++p != end);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			SET_INCONSISTENT(HT_DESTROYED);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(ht-&gt;u.flags &amp; (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS))) &#123;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (EXPECTED(Z_TYPE(p-&gt;val) != IS_UNDEF)) &#123;</span><br><span class="line">						<span class="keyword">if</span> (EXPECTED(p-&gt;key)) &#123;</span><br><span class="line">							zend_string_release(p-&gt;key);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">while</span> (++p != end);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		zend_hash_iterators_remove(ht);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (EXPECTED(!(ht-&gt;u.flags &amp; HASH_FLAG_INITIALIZED))) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pefree(HT_GET_DATA_ADDR(ht), ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清空和销毁的区别">清空和销毁的区别</h4><p><code>zend_hash_destroy</code>与<code>zend_hash_clean</code>的区别<br><code>zend_hash_destory</code>之后此HashTable就不能再利用了，而<code>zend_hash_clean</code>之后的HashTable还可能再次利用</p>
<h4 id="其他高级操作函数">其他高级操作函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API void ZEND_FASTCALL _zend_hash_merge(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, zend_bool overwrite ZEND_FILE_LINE_DC)&#10;static zend_bool ZEND_FASTCALL zend_hash_replace_checker_wrapper(HashTable *target, zval *source_data, Bucket *p, void *pParam, merge_checker_func_t merge_checker_func)&#10;ZEND_API void ZEND_FASTCALL zend_hash_merge_ex(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, merge_checker_func_t pMergeSource, void *pParam)&#10;ZEND_API int zend_hash_compare(HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered)&#10;static zend_always_inline int zend_hash_compare_impl(HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered)&#10;ZEND_API int ZEND_FASTCALL _zend_handle_numeric_str_ex(const char *key, size_t length, zend_ulong *idx)</span><br></pre></td></tr></table></figure>
<h4 id="参考">参考</h4><p><a href="http://www.phpboy.net/2013-12/27-php-hashtable-analysis.html" target="_blank" rel="external">PHP内核之HashTable实现分析与使用（以php-5.4为例）</a></p>
<p><a href="http://blog.csdn.net/heiyeshuwu/article/details/44259865" target="_blank" rel="external">PHP NG内核之HashTable实现</a></p>


<!--<a href="http://yoursite.com/2015-9-16-php7-implementation-hashtable.html#disqus_thread" class="article-comment-link">Comments</a>-->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = mickeyouyou; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=1254090228&web_id=1254090228" language="JavaScript"></script>script>
</div>







</body>
</html>